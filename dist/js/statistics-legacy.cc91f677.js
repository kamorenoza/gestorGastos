(self.webpackChunkgestor_gastos = self.webpackChunkgestor_gastos || []).push([[193], {
  66312: function (t, e, i) { 'use strict'; i.d(e, { Z: function () { return d } }); const n = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'm-select-period' }, [i('b-icon', { attrs: { icon: 'chevron-left' }, on: { click: function (e) { return t.changePeriod() } } }), i('div', { staticClass: 'm-select-period__calendar' }, [i('b-form-datepicker', { attrs: { id: 'datepicker-2', locale: 'es', 'button-only': '', 'today-button': '', 'label-today-button': 'Seleccionar hoy' }, model: { value: t.date, callback: function (e) { t.date = e }, expression: 'date' } }), i('p', [t._v(t._s(t._f('formatDateMonthYear')(t.currentPeriod)) + ' ')])], 1), i('b-icon', { attrs: { icon: 'chevron-right' }, on: { click: function (e) { return t.changePeriod(!0) } } })], 1) }; const a = []; const r = i(4367); const o = i(14511); const s = i(34665); const l = { name: 'SelectPeriod', data: function () { return { date: this.currentPeriod } }, watch: { date: function (t) { t !== this.currentPeriod && this.setCurrentPeriod(t) }, currentPeriod: function (t) { t !== this.date && (this.date = t) } }, computed: (0, r.Z)({}, (0, s.rn)('expensesStore', ['currentPeriod'])), methods: (0, r.Z)({ changePeriod: function (t) { t ? this.setCurrentPeriod(o.P.sumMonths(this.currentPeriod, 1)) : this.setCurrentPeriod(o.P.subtractMonths(this.currentPeriod, 1)) } }, (0, s.OI)('expensesStore', ['setCurrentPeriod'])) }; const h = l; const u = i(1001); const c = (0, u.Z)(h, n, a, !1, null, null, null); var d = c.exports },
  48391: function (t, e, i) {
    'use strict'; i.r(e), i.d(e, { default: function () { return iu } }); const n = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'l-all-content' }, [i('div', { staticClass: 'l-title-graph' }, [i('p', { staticClass: 'title pl-2 mb-4' }, [t._v('Estadísticas')]), i('select-period', { staticClass: 'm-select-period--graph' })], 1), i('pie-chart')], 1) }; const a = []; const r = i(66312); const o = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'card card--graph' }, [i('p', { staticClass: 'text-medium text-book mb-2' }, [t._v('Movimientos por categorías')]), i('b-tabs', { attrs: { 'content-class': 'mt-3' } }, [i('b-tab', { attrs: { title: 'Gastos', active: '' }, on: { click: function (e) { return t.setType('credit') } } }), i('b-tab', { attrs: { title: 'Ingresos' }, on: { click: function (e) { return t.setType('debit') } } })], 1), i('div', [i('Pie', { attrs: { 'chart-options': t.chartOptions, 'chart-data': t.chartData, 'chart-id': t.chartId, 'dataset-id-key': t.datasetIdKey, plugins: t.plugins, 'css-classes': t.cssClasses, styles: t.styles, width: t.width, height: t.height } }), i('div', { staticClass: 'mt-2' }, t._l(t.categoriesArr, function (e, n) { return i('label-chart', { key: n, attrs: { color: e.backgroundColor, label: e.label, value: e.total, total: t.totalArr, 'show-percentage': '' } }) }), 1)], 1)], 1) }; const s = []; const l = i(67906); const h = i(16198); const u = i(4367); const c = (i(9653), i(74916), i(23123), i(41539), i(54747), i(56977), i(92222), i(26833), i(47941), i(68932)); const d = (i(21249), i(69826), i(26699), i(21703), i(43263)); const f = i(50460); const v = i(87349); const g = i(99418); const p = i(6812); const y = i(75200); const m = i(23796); const b = i(62032); const x = i(9726); const _ = i(76133); const k = i(92751); i(51532), i(78783), i(33948), i(36210), i(57327), i(41825), i(43371), i(40561), i(2707), i(47042), i(23157), i(34553), i(30489), i(69600), i(70189), i(91038), i(32023), i(43290), i(4129), i(44363), i(55994), i(27852), i(40658), i(52420), i(15306), i(39714), i(24603), i(28450), i(88386), i(4723), i(39341), i(73706), i(10408), i(82526), i(41817), i(95683), i(81299), i(39361), i(51037), i(67556), i(93299), i(38862); const w = (function () { return typeof window === 'undefined' ? function (t) { return t() } : window.requestAnimationFrame }()); function M (t, e, i) { const n = i || function (t) { return Array.prototype.slice.call(t) }; let a = !1; let r = []; return function () { for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++)o[s] = arguments[s]; r = n(o), a || (a = !0, w.call(window, function () { a = !1, t.apply(e, r) })) } } function S (t, e) { let i; return function () { for (var n = arguments.length, a = new Array(n), r = 0; r < n; r++)a[r] = arguments[r]; return e ? (clearTimeout(i), i = setTimeout(t, e, a)) : t.apply(this, a), e } } const P = function (t) { return t === 'start' ? 'left' : t === 'end' ? 'right' : 'center' }; const C = function (t, e, i) { return t === 'start' ? e : t === 'end' ? i : (e + i) / 2 }; const D = function (t, e, i, n) { const a = n ? 'left' : 'right'; return t === a ? i : t === 'center' ? (e + i) / 2 : e }; function O () {} const A = (function () { let t = 0; return function () { return t++ } }()); function T (t) { return t === null || typeof t === 'undefined' } function L (t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === '[object' && e.slice(-6) === 'Array]' } function R (t) { return t !== null && Object.prototype.toString.call(t) === '[object Object]' } const E = function (t) { return (typeof t === 'number' || t instanceof Number) && isFinite(+t) }; function I (t, e) { return E(t) ? t : e } function Z (t, e) { return typeof t === 'undefined' ? e : t } const z = function (t, e) { return typeof t === 'string' && t.endsWith('%') ? parseFloat(t) / 100 : t / e }; const F = function (t, e) { return typeof t === 'string' && t.endsWith('%') ? parseFloat(t) / 100 * e : +t }; function B (t, e, i) { if (t && typeof t.call === 'function') return t.apply(i, e) } function V (t, e, i, n) { let a, r, o; if (L(t)) if (r = t.length, n) for (a = r - 1; a >= 0; a--)e.call(i, t[a], a); else for (a = 0; a < r; a++)e.call(i, t[a], a); else if (R(t)) for (o = Object.keys(t), r = o.length, a = 0; a < r; a++)e.call(i, t[o[a]], o[a]) } function W (t, e) { let i, n, a, r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i) if (a = t[i], r = e[i], a.datasetIndex !== r.datasetIndex || a.index !== r.index) return !1; return !0 } function N (t) { if (L(t)) return t.map(N); if (R(t)) { for (var e = Object.create(null), i = Object.keys(t), n = i.length, a = 0; a < n; ++a)e[i[a]] = N(t[i[a]]); return e } return t } function H (t) { return ['__proto__', 'prototype', 'constructor'].indexOf(t) === -1 } function j (t, e, i, n) { if (H(t)) { const a = e[t]; const r = i[t]; R(a) && R(r) ? $(a, r, n) : e[t] = N(r) } } function $ (t, e, i) { const n = L(e) ? e : [e]; const a = n.length; if (!R(t)) return t; i = i || {}; for (let r = i.merger || j, o = 0; o < a; ++o) if (e = n[o], R(e)) for (let s = Object.keys(e), l = 0, h = s.length; l < h; ++l)r(s[l], t, e, i); return t } function Y (t, e) { return $(t, e, { merger: U }) } function U (t, e, i) { if (H(t)) { const n = e[t]; const a = i[t]; R(n) && R(a) ? Y(n, a) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = N(a)) } } const X = ''; const q = '.'; function K (t, e) { const i = t.indexOf(q, e); return i === -1 ? t.length : i } function G (t, e) { if (e === X) return t; let i = 0; let n = K(e, i); while (t && n > i)t = t[e.slice(i, n)], i = n + 1, n = K(e, i); return t } function J (t) { return t.charAt(0).toUpperCase() + t.slice(1) } const Q = function (t) { return typeof t !== 'undefined' }; const tt = function (t) { return typeof t === 'function' }; const et = function (t, e) { if (t.size !== e.size) return !1; let i; const n = (0, b.Z)(t); try { for (n.s(); !(i = n.n()).done;) { const a = i.value; if (!e.has(a)) return !1 } } catch (r) { n.e(r) } finally { n.f() } return !0 }; function it (t) { return t.type === 'mouseup' || t.type === 'click' || t.type === 'contextmenu' } const nt = Math.PI; const at = 2 * nt; const rt = at + nt; const ot = Number.POSITIVE_INFINITY; const st = nt / 180; const lt = nt / 2; const ht = nt / 4; const ut = 2 * nt / 3; const ct = Math.log10; const dt = Math.sign; function ft (t) { const e = Math.round(t); t = pt(t, e, t / 1e3) ? e : t; const i = Math.pow(10, Math.floor(ct(t))); const n = t / i; const a = n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10; return a * i } function vt (t) { let e; const i = []; const n = Math.sqrt(t); for (e = 1; e < n; e++)t % e === 0 && (i.push(e), i.push(t / e)); return n === (0 | n) && i.push(n), i.sort(function (t, e) { return t - e }).pop(), i } function gt (t) { return !isNaN(parseFloat(t)) && isFinite(t) } function pt (t, e, i) { return Math.abs(t - e) < i } function yt (t, e) { const i = Math.round(t); return i - e <= t && i + e >= t } function mt (t, e, i) { let n, a, r; for (n = 0, a = t.length; n < a; n++)r = t[n][i], isNaN(r) || (e.min = Math.min(e.min, r), e.max = Math.max(e.max, r)) } function bt (t) { return t * (nt / 180) } function xt (t) { return t * (180 / nt) } function _t (t) { if (E(t)) { let e = 1; let i = 0; while (Math.round(t * e) / e !== t)e *= 10, i++; return i } } function kt (t, e) { const i = e.x - t.x; const n = e.y - t.y; const a = Math.sqrt(i * i + n * n); let r = Math.atan2(n, i); return r < -0.5 * nt && (r += at), { angle: r, distance: a } } function wt (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function Mt (t, e) { return (t - e + rt) % at - nt } function St (t) { return (t % at + at) % at } function Pt (t, e, i, n) { const a = St(t); const r = St(e); const o = St(i); const s = St(r - a); const l = St(o - a); const h = St(a - r); const u = St(a - o); return a === r || a === o || n && r === o || s > l && h < u } function Ct (t, e, i) { return Math.max(e, Math.min(i, t)) } function Dt (t) { return Ct(t, -32768, 32767) } function Ot (t, e, i) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-6; return t >= Math.min(e, i) - n && t <= Math.max(e, i) + n } const At = function (t) { return t === 0 || t === 1 }; const Tt = function (t, e, i) { return -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * at / i) }; const Lt = function (t, e, i) { return Math.pow(2, -10 * t) * Math.sin((t - e) * at / i) + 1 }; var Rt = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return -t * (t - 2) }, easeInOutQuad: function (t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return (t -= 1) * t * t + 1 }, easeInOutCubic: function (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return -((t -= 1) * t * t * t - 1) }, easeInOutQuart: function (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint: function (t) { return t * t * t * t * t }, easeOutQuint: function (t) { return (t -= 1) * t * t * t * t + 1 }, easeInOutQuint: function (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine: function (t) { return 1 - Math.cos(t * lt) }, easeOutSine: function (t) { return Math.sin(t * lt) }, easeInOutSine: function (t) { return -0.5 * (Math.cos(nt * t) - 1) }, easeInExpo: function (t) { return t === 0 ? 0 : Math.pow(2, 10 * (t - 1)) }, easeOutExpo: function (t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t) }, easeInOutExpo: function (t) { return At(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (2 * t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (2 * t - 1))) }, easeInCirc: function (t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1) }, easeOutCirc: function (t) { return Math.sqrt(1 - (t -= 1) * t) }, easeInOutCirc: function (t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic: function (t) { return At(t) ? t : Tt(t, 0.075, 0.3) }, easeOutElastic: function (t) { return At(t) ? t : Lt(t, 0.075, 0.3) }, easeInOutElastic: function (t) { const e = 0.1125; const i = 0.45; return At(t) ? t : t < 0.5 ? 0.5 * Tt(2 * t, e, i) : 0.5 + 0.5 * Lt(2 * t - 1, e, i) }, easeInBack: function (t) { const e = 1.70158; return t * t * ((e + 1) * t - e) }, easeOutBack: function (t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1 }, easeInOutBack: function (t) { let e = 1.70158; return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: function (t) { return 1 - Rt.easeOutBounce(1 - t) }, easeOutBounce: function (t) { const e = 7.5625; const i = 2.75; return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + 0.75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + 0.9375 : e * (t -= 2.625 / i) * t + 0.984375 }, easeInOutBounce: function (t) { return t < 0.5 ? 0.5 * Rt.easeInBounce(2 * t) : 0.5 * Rt.easeOutBounce(2 * t - 1) + 0.5 } }
    /*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
    function Et (t) { return t + 0.5 | 0 } const It = function (t, e, i) { return Math.max(Math.min(t, i), e) }; function Zt (t) { return It(Et(2.55 * t), 0, 255) } function zt (t) { return It(Et(255 * t), 0, 255) } function Ft (t) { return It(Et(t / 2.55) / 100, 0, 1) } function Bt (t) { return It(Et(100 * t), 0, 100) } const Vt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }; const Wt = (0, c.Z)('0123456789ABCDEF'); const Nt = function (t) { return Wt[15 & t] }; const Ht = function (t) { return Wt[(240 & t) >> 4] + Wt[15 & t] }; const jt = function (t) { return (240 & t) >> 4 === (15 & t) }; const $t = function (t) { return jt(t.r) && jt(t.g) && jt(t.b) && jt(t.a) }; function Yt (t) { let e; const i = t.length; return t[0] === '#' && (i === 4 || i === 5 ? e = { r: 255 & 17 * Vt[t[1]], g: 255 & 17 * Vt[t[2]], b: 255 & 17 * Vt[t[3]], a: i === 5 ? 17 * Vt[t[4]] : 255 } : i !== 7 && i !== 9 || (e = { r: Vt[t[1]] << 4 | Vt[t[2]], g: Vt[t[3]] << 4 | Vt[t[4]], b: Vt[t[5]] << 4 | Vt[t[6]], a: i === 9 ? Vt[t[7]] << 4 | Vt[t[8]] : 255 })), e } const Ut = function (t, e) { return t < 255 ? e(t) : '' }; function Xt (t) { const e = $t(t) ? Nt : Ht; return t ? '#' + e(t.r) + e(t.g) + e(t.b) + Ut(t.a, e) : void 0 } const qt = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function Kt (t, e, i) { const n = e * Math.min(i, 1 - i); const a = function (e) { const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (e + t / 30) % 12; return i - n * Math.max(Math.min(a - 3, 9 - a, 1), -1) }; return [a(0), a(8), a(4)] } function Gt (t, e, i) { const n = function (n) { const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (n + t / 60) % 6; return i - i * e * Math.max(Math.min(a, 4 - a, 1), 0) }; return [n(5), n(3), n(1)] } function Jt (t, e, i) { let n; const a = Kt(t, 1, 0.5); for (e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++)a[n] *= 1 - e - i, a[n] += e; return a } function Qt (t, e, i, n, a) { return t === a ? (e - i) / n + (e < i ? 6 : 0) : e === a ? (i - t) / n + 2 : (t - e) / n + 4 } function te (t) { let e; let i; let n; const a = 255; const r = t.r / a; const o = t.g / a; const s = t.b / a; const l = Math.max(r, o, s); const h = Math.min(r, o, s); const u = (l + h) / 2; return l !== h && (n = l - h, i = u > 0.5 ? n / (2 - l - h) : n / (l + h), e = Qt(r, o, s, n, l), e = 60 * e + 0.5), [0 | e, i || 0, u] } function ee (t, e, i, n) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(zt) } function ie (t, e, i) { return ee(Kt, t, e, i) } function ne (t, e, i) { return ee(Jt, t, e, i) } function ae (t, e, i) { return ee(Gt, t, e, i) } function re (t) { return (t % 360 + 360) % 360 } function oe (t) { let e; const i = qt.exec(t); let n = 255; if (i) { i[5] !== e && (n = i[6] ? Zt(+i[5]) : zt(+i[5])); const a = re(+i[2]); const r = +i[3] / 100; const o = +i[4] / 100; return e = i[1] === 'hwb' ? ne(a, r, o) : i[1] === 'hsv' ? ae(a, r, o) : ie(a, r, o), { r: e[0], g: e[1], b: e[2], a: n } } } function se (t, e) { let i = te(t); i[0] = re(i[0] + e), i = ie(i), t.r = i[0], t.g = i[1], t.b = i[2] } function le (t) { if (t) { const e = te(t); const i = e[0]; const n = Bt(e[1]); const a = Bt(e[2]); return t.a < 255 ? 'hsla('.concat(i, ', ').concat(n, '%, ').concat(a, '%, ').concat(Ft(t.a), ')') : 'hsl('.concat(i, ', ').concat(n, '%, ').concat(a, '%)') } } let he; const ue = { x: 'dark', Z: 'light', Y: 're', X: 'blu', W: 'gr', V: 'medium', U: 'slate', A: 'ee', T: 'ol', S: 'or', B: 'ra', C: 'lateg', D: 'ights', R: 'in', Q: 'turquois', E: 'hi', P: 'ro', O: 'al', N: 'le', M: 'de', L: 'yello', F: 'en', K: 'ch', G: 'arks', H: 'ea', I: 'ightg', J: 'wh' }; const ce = { OiceXe: 'f0f8ff', antiquewEte: 'faebd7', aqua: 'ffff', aquamarRe: '7fffd4', azuY: 'f0ffff', beige: 'f5f5dc', bisque: 'ffe4c4', black: '0', blanKedOmond: 'ffebcd', Xe: 'ff', XeviTet: '8a2be2', bPwn: 'a52a2a', burlywood: 'deb887', caMtXe: '5f9ea0', KartYuse: '7fff00', KocTate: 'd2691e', cSO: 'ff7f50', cSnflowerXe: '6495ed', cSnsilk: 'fff8dc', crimson: 'dc143c', cyan: 'ffff', xXe: '8b', xcyan: '8b8b', xgTMnPd: 'b8860b', xWay: 'a9a9a9', xgYF: '6400', xgYy: 'a9a9a9', xkhaki: 'bdb76b', xmagFta: '8b008b', xTivegYF: '556b2f', xSange: 'ff8c00', xScEd: '9932cc', xYd: '8b0000', xsOmon: 'e9967a', xsHgYF: '8fbc8f', xUXe: '483d8b', xUWay: '2f4f4f', xUgYy: '2f4f4f', xQe: 'ced1', xviTet: '9400d3', dAppRk: 'ff1493', dApskyXe: 'bfff', dimWay: '696969', dimgYy: '696969', dodgerXe: '1e90ff', fiYbrick: 'b22222', flSOwEte: 'fffaf0', foYstWAn: '228b22', fuKsia: 'ff00ff', gaRsbSo: 'dcdcdc', ghostwEte: 'f8f8ff', gTd: 'ffd700', gTMnPd: 'daa520', Way: '808080', gYF: '8000', gYFLw: 'adff2f', gYy: '808080', honeyMw: 'f0fff0', hotpRk: 'ff69b4', RdianYd: 'cd5c5c', Rdigo: '4b0082', ivSy: 'fffff0', khaki: 'f0e68c', lavFMr: 'e6e6fa', lavFMrXsh: 'fff0f5', lawngYF: '7cfc00', NmoncEffon: 'fffacd', ZXe: 'add8e6', ZcSO: 'f08080', Zcyan: 'e0ffff', ZgTMnPdLw: 'fafad2', ZWay: 'd3d3d3', ZgYF: '90ee90', ZgYy: 'd3d3d3', ZpRk: 'ffb6c1', ZsOmon: 'ffa07a', ZsHgYF: '20b2aa', ZskyXe: '87cefa', ZUWay: '778899', ZUgYy: '778899', ZstAlXe: 'b0c4de', ZLw: 'ffffe0', lime: 'ff00', limegYF: '32cd32', lRF: 'faf0e6', magFta: 'ff00ff', maPon: '800000', VaquamarRe: '66cdaa', VXe: 'cd', VScEd: 'ba55d3', VpurpN: '9370db', VsHgYF: '3cb371', VUXe: '7b68ee', VsprRggYF: 'fa9a', VQe: '48d1cc', VviTetYd: 'c71585', midnightXe: '191970', mRtcYam: 'f5fffa', mistyPse: 'ffe4e1', moccasR: 'ffe4b5', navajowEte: 'ffdead', navy: '80', Tdlace: 'fdf5e6', Tive: '808000', TivedBb: '6b8e23', Sange: 'ffa500', SangeYd: 'ff4500', ScEd: 'da70d6', pOegTMnPd: 'eee8aa', pOegYF: '98fb98', pOeQe: 'afeeee', pOeviTetYd: 'db7093', papayawEp: 'ffefd5', pHKpuff: 'ffdab9', peru: 'cd853f', pRk: 'ffc0cb', plum: 'dda0dd', powMrXe: 'b0e0e6', purpN: '800080', YbeccapurpN: '663399', Yd: 'ff0000', Psybrown: 'bc8f8f', PyOXe: '4169e1', saddNbPwn: '8b4513', sOmon: 'fa8072', sandybPwn: 'f4a460', sHgYF: '2e8b57', sHshell: 'fff5ee', siFna: 'a0522d', silver: 'c0c0c0', skyXe: '87ceeb', UXe: '6a5acd', UWay: '708090', UgYy: '708090', snow: 'fffafa', sprRggYF: 'ff7f', stAlXe: '4682b4', tan: 'd2b48c', teO: '8080', tEstN: 'd8bfd8', tomato: 'ff6347', Qe: '40e0d0', viTet: 'ee82ee', JHt: 'f5deb3', wEte: 'ffffff', wEtesmoke: 'f5f5f5', Lw: 'ffff00', LwgYF: '9acd32' }; function de () { let t; let e; let i; let n; let a; const r = {}; const o = Object.keys(ce); const s = Object.keys(ue); for (t = 0; t < o.length; t++) { for (n = a = o[t], e = 0; e < s.length; e++)i = s[e], a = a.replace(i, ue[i]); i = parseInt(ce[n], 16), r[a] = [i >> 16 & 255, i >> 8 & 255, 255 & i] } return r } function fe (t) { he || (he = de(), he.transparent = [0, 0, 0, 0]); const e = he[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const ve = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function ge (t) { let e; let i; let n; const a = ve.exec(t); let r = 255; if (a) { if (a[7] !== e) { const o = +a[7]; r = a[8] ? Zt(o) : It(255 * o, 0, 255) } return e = +a[1], i = +a[3], n = +a[5], e = 255 & (a[2] ? Zt(e) : It(e, 0, 255)), i = 255 & (a[4] ? Zt(i) : It(i, 0, 255)), n = 255 & (a[6] ? Zt(n) : It(n, 0, 255)), { r: e, g: i, b: n, a: r } } } function pe (t) { return t && (t.a < 255 ? 'rgba('.concat(t.r, ', ').concat(t.g, ', ').concat(t.b, ', ').concat(Ft(t.a), ')') : 'rgb('.concat(t.r, ', ').concat(t.g, ', ').concat(t.b, ')')) } const ye = function (t) { return t <= 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055 }; const me = function (t) { return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4) }; function be (t, e, i) { const n = me(Ft(t.r)); const a = me(Ft(t.g)); const r = me(Ft(t.b)); return { r: zt(ye(n + i * (me(Ft(e.r)) - n))), g: zt(ye(a + i * (me(Ft(e.g)) - a))), b: zt(ye(r + i * (me(Ft(e.b)) - r))), a: t.a + i * (e.a - t.a) } } function xe (t, e, i) { if (t) { let n = te(t); n[e] = Math.max(0, Math.min(n[e] + n[e] * i, e === 0 ? 360 : 1)), n = ie(n), t.r = n[0], t.g = n[1], t.b = n[2] } } function _e (t, e) { return t ? Object.assign(e || {}, t) : t } function ke (t) { let e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = zt(t[3]))) : (e = _e(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = zt(e.a)), e } function we (t) { return t.charAt(0) === 'r' ? ge(t) : oe(t) } const Me = (function () { function t (e) { if ((0, _.Z)(this, t), e instanceof t) return e; let i; const n = (0, x.Z)(e); n === 'object' ? i = ke(e) : n === 'string' && (i = Yt(e) || fe(e) || we(e)), this._rgb = i, this._valid = !!i } return (0, k.Z)(t, [{ key: 'valid', get: function () { return this._valid } }, { key: 'rgb', get: function () { const t = _e(this._rgb); return t && (t.a = Ft(t.a)), t }, set: function (t) { this._rgb = ke(t) } }, { key: 'rgbString', value: function () { return this._valid ? pe(this._rgb) : void 0 } }, { key: 'hexString', value: function () { return this._valid ? Xt(this._rgb) : void 0 } }, { key: 'hslString', value: function () { return this._valid ? le(this._rgb) : void 0 } }, { key: 'mix', value: function (t, e) { if (t) { let i; const n = this.rgb; const a = t.rgb; const r = e === i ? 0.5 : e; const o = 2 * r - 1; const s = n.a - a.a; const l = ((o * s === -1 ? o : (o + s) / (1 + o * s)) + 1) / 2; i = 1 - l, n.r = 255 & l * n.r + i * a.r + 0.5, n.g = 255 & l * n.g + i * a.g + 0.5, n.b = 255 & l * n.b + i * a.b + 0.5, n.a = r * n.a + (1 - r) * a.a, this.rgb = n } return this } }, { key: 'interpolate', value: function (t, e) { return t && (this._rgb = be(this._rgb, t._rgb, e)), this } }, { key: 'clone', value: function () { return new t(this.rgb) } }, { key: 'alpha', value: function (t) { return this._rgb.a = zt(t), this } }, { key: 'clearer', value: function (t) { const e = this._rgb; return e.a *= 1 - t, this } }, { key: 'greyscale', value: function () { const t = this._rgb; const e = Et(0.3 * t.r + 0.59 * t.g + 0.11 * t.b); return t.r = t.g = t.b = e, this } }, { key: 'opaquer', value: function (t) { const e = this._rgb; return e.a *= 1 + t, this } }, { key: 'negate', value: function () { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } }, { key: 'lighten', value: function (t) { return xe(this._rgb, 2, t), this } }, { key: 'darken', value: function (t) { return xe(this._rgb, 2, -t), this } }, { key: 'saturate', value: function (t) { return xe(this._rgb, 1, t), this } }, { key: 'desaturate', value: function (t) { return xe(this._rgb, 1, -t), this } }, { key: 'rotate', value: function (t) { return se(this._rgb, t), this } }]), t }()); function Se (t) { return new Me(t) } function Pe (t) { if (t && (0, x.Z)(t) === 'object') { const e = t.toString(); return e === '[object CanvasPattern]' || e === '[object CanvasGradient]' } return !1 } function Ce (t) { return Pe(t) ? t : Se(t) } function De (t) { return Pe(t) ? t : Se(t).saturate(0.5).darken(0.1).hexString() } const Oe = Object.create(null); const Ae = Object.create(null); function Te (t, e) { if (!e) return t; for (let i = e.split('.'), n = 0, a = i.length; n < a; ++n) { const r = i[n]; t = t[r] || (t[r] = Object.create(null)) } return t } function Le (t, e, i) { return typeof e === 'string' ? $(Te(t, e), i) : $(Te(t, ''), e) } const Re = (function () { function t (e) { (0, _.Z)(this, t), this.animation = void 0, this.backgroundColor = 'rgba(0,0,0,0.1)', this.borderColor = 'rgba(0,0,0,0.1)', this.color = '#666', this.datasets = {}, this.devicePixelRatio = function (t) { return t.chart.platform.getDevicePixelRatio() }, this.elements = {}, this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: 'normal', lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = function (t, e) { return De(e.backgroundColor) }, this.hoverBorderColor = function (t, e) { return De(e.borderColor) }, this.hoverColor = function (t, e) { return De(e.color) }, this.indexAxis = 'x', this.interaction = { mode: 'nearest', intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e) } return (0, k.Z)(t, [{ key: 'set', value: function (t, e) { return Le(this, t, e) } }, { key: 'get', value: function (t) { return Te(this, t) } }, { key: 'describe', value: function (t, e) { return Le(Ae, t, e) } }, { key: 'override', value: function (t, e) { return Le(Oe, t, e) } }, { key: 'route', value: function (t, e, i, n) { let a; const r = Te(this, t); const o = Te(this, i); const s = '_' + e; Object.defineProperties(r, (a = {}, (0, m.Z)(a, s, { value: r[e], writable: !0 }), (0, m.Z)(a, e, { enumerable: !0, get: function () { const t = this[s]; const e = o[n]; return R(t) ? Object.assign({}, e, t) : Z(t, e) }, set: function (t) { this[s] = t } }), a)) } }]), t }()); const Ee = new Re({ _scriptable: function (t) { return !t.startsWith('on') }, _indexable: function (t) { return t !== 'events' }, hover: { _fallback: 'interaction' }, interaction: { _scriptable: !1, _indexable: !1 } }); function Ie (t) { return !t || T(t.size) || T(t.family) ? null : (t.style ? t.style + ' ' : '') + (t.weight ? t.weight + ' ' : '') + t.size + 'px ' + t.family } function Ze (t, e, i, n, a) { let r = e[a]; return r || (r = e[a] = t.measureText(a).width, i.push(a)), r > n && (n = r), n } function ze (t, e, i, n) { n = n || {}; let a = n.data = n.data || {}; let r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, r = n.garbageCollect = [], n.font = e), t.save(), t.font = e; let o; let s; let l; let h; let u; let c = 0; const d = i.length; for (o = 0; o < d; o++) if (h = i[o], void 0 !== h && h !== null && !0 !== L(h))c = Ze(t, a, r, c, h); else if (L(h)) for (s = 0, l = h.length; s < l; s++)u = h[s], void 0 === u || u === null || L(u) || (c = Ze(t, a, r, c, u)); t.restore(); const f = r.length / 2; if (f > i.length) { for (o = 0; o < f; o++) delete a[r[o]]; r.splice(0, f) } return c } function Fe (t, e, i) { const n = t.currentDevicePixelRatio; const a = i !== 0 ? Math.max(i / 2, 0.5) : 0; return Math.round((e - a) * n) / n + a } function Be (t, e) { e = e || t.getContext('2d'), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function Ve (t, e, i, n) { We(t, e, i, n, null) } function We (t, e, i, n, a) { let r; let o; let s; let l; let h; let u; const c = e.pointStyle; const d = e.rotation; const f = e.radius; let v = (d || 0) * st; if (c && (0, x.Z)(c) === 'object' && (r = c.toString(), r === '[object HTMLImageElement]' || r === '[object HTMLCanvasElement]')) return t.save(), t.translate(i, n), t.rotate(v), t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void t.restore(); if (!(isNaN(f) || f <= 0)) { switch (t.beginPath(), c) { default:a ? t.ellipse(i, n, a / 2, f, 0, 0, at) : t.arc(i, n, f, 0, at), t.closePath(); break; case 'triangle':t.moveTo(i + Math.sin(v) * f, n - Math.cos(v) * f), v += ut, t.lineTo(i + Math.sin(v) * f, n - Math.cos(v) * f), v += ut, t.lineTo(i + Math.sin(v) * f, n - Math.cos(v) * f), t.closePath(); break; case 'rectRounded':h = 0.516 * f, l = f - h, o = Math.cos(v + ht) * l, s = Math.sin(v + ht) * l, t.arc(i - o, n - s, h, v - nt, v - lt), t.arc(i + s, n - o, h, v - lt, v), t.arc(i + o, n + s, h, v, v + lt), t.arc(i - s, n + o, h, v + lt, v + nt), t.closePath(); break; case 'rect':if (!d) { l = Math.SQRT1_2 * f, u = a ? a / 2 : l, t.rect(i - u, n - l, 2 * u, 2 * l); break }v += ht; case 'rectRot':o = Math.cos(v) * f, s = Math.sin(v) * f, t.moveTo(i - o, n - s), t.lineTo(i + s, n - o), t.lineTo(i + o, n + s), t.lineTo(i - s, n + o), t.closePath(); break; case 'crossRot':v += ht; case 'cross':o = Math.cos(v) * f, s = Math.sin(v) * f, t.moveTo(i - o, n - s), t.lineTo(i + o, n + s), t.moveTo(i + s, n - o), t.lineTo(i - s, n + o); break; case 'star':o = Math.cos(v) * f, s = Math.sin(v) * f, t.moveTo(i - o, n - s), t.lineTo(i + o, n + s), t.moveTo(i + s, n - o), t.lineTo(i - s, n + o), v += ht, o = Math.cos(v) * f, s = Math.sin(v) * f, t.moveTo(i - o, n - s), t.lineTo(i + o, n + s), t.moveTo(i + s, n - o), t.lineTo(i - s, n + o); break; case 'line':o = a ? a / 2 : Math.cos(v) * f, s = Math.sin(v) * f, t.moveTo(i - o, n - s), t.lineTo(i + o, n + s); break; case 'dash':t.moveTo(i, n), t.lineTo(i + Math.cos(v) * f, n + Math.sin(v) * f); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function Ne (t, e, i) { return i = i || 0.5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i } function He (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function je (t) { t.restore() } function $e (t, e, i, n, a) { if (!e) return t.lineTo(i.x, i.y); if (a === 'middle') { const r = (e.x + i.x) / 2; t.lineTo(r, e.y), t.lineTo(r, i.y) } else a === 'after' !== !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y); t.lineTo(i.x, i.y) } function Ye (t, e, i, n) { if (!e) return t.lineTo(i.x, i.y); t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y) } function Ue (t, e, i, n, a) { let r; let o; const s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; const l = L(e) ? e : [e]; const h = s.strokeWidth > 0 && s.strokeColor !== ''; for (t.save(), t.font = a.string, Xe(t, s), r = 0; r < l.length; ++r)o = l[r], h && (s.strokeColor && (t.strokeStyle = s.strokeColor), T(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(o, i, n, s.maxWidth)), t.fillText(o, i, n, s.maxWidth), qe(t, i, n, o, s), n += a.lineHeight; t.restore() } function Xe (t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), T(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function qe (t, e, i, n, a) { if (a.strikethrough || a.underline) { const r = t.measureText(n); const o = e - r.actualBoundingBoxLeft; const s = e + r.actualBoundingBoxRight; const l = i - r.actualBoundingBoxAscent; const h = i + r.actualBoundingBoxDescent; const u = a.strikethrough ? (l + h) / 2 : h; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = a.decorationWidth || 2, t.moveTo(o, u), t.lineTo(s, u), t.stroke() } } function Ke (t, e) { const i = e.x; const n = e.y; const a = e.w; const r = e.h; const o = e.radius; t.arc(i + o.topLeft, n + o.topLeft, o.topLeft, -lt, nt, !0), t.lineTo(i, n + r - o.bottomLeft), t.arc(i + o.bottomLeft, n + r - o.bottomLeft, o.bottomLeft, nt, lt, !0), t.lineTo(i + a - o.bottomRight, n + r), t.arc(i + a - o.bottomRight, n + r - o.bottomRight, o.bottomRight, lt, 0, !0), t.lineTo(i + a, n + o.topRight), t.arc(i + a - o.topRight, n + o.topRight, o.topRight, 0, -lt, !0), t.lineTo(i + o.topLeft, n) } const Ge = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); const Je = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/); function Qe (t, e) { const i = ('' + t).match(Ge); if (!i || i[1] === 'normal') return 1.2 * e; switch (t = +i[2], i[3]) { case 'px':return t; case '%':t /= 100; break } return e * t } const ti = function (t) { return +t || 0 }; function ei (t, e) { let i; const n = {}; const a = R(e); const r = a ? Object.keys(e) : e; const o = R(t) ? a ? function (i) { return Z(t[i], t[e[i]]) } : function (e) { return t[e] } : function () { return t }; const s = (0, b.Z)(r); try { for (s.s(); !(i = s.n()).done;) { const l = i.value; n[l] = ti(o(l)) } } catch (h) { s.e(h) } finally { s.f() } return n } function ii (t) { return ei(t, { top: 'y', right: 'x', bottom: 'y', left: 'x' }) } function ni (t) { return ei(t, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) } function ai (t) { const e = ii(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function ri (t, e) { t = t || {}, e = e || Ee.font; let i = Z(t.size, e.size); typeof i === 'string' && (i = parseInt(i, 10)); let n = Z(t.style, e.style); n && !('' + n).match(Je) && (console.warn('Invalid font style specified: "' + n + '"'), n = ''); const a = { family: Z(t.family, e.family), lineHeight: Qe(Z(t.lineHeight, e.lineHeight), i), size: i, style: n, weight: Z(t.weight, e.weight), string: '' }; return a.string = Ie(a), a } function oi (t, e, i, n) { let a; let r; let o; let s = !0; for (a = 0, r = t.length; a < r; ++a) if (o = t[a], void 0 !== o && (void 0 !== e && typeof o === 'function' && (o = o(e), s = !1), void 0 !== i && L(o) && (o = o[i % o.length], s = !1), void 0 !== o)) return n && !s && (n.cacheable = !1), o } function si (t, e, i) { const n = t.min; const a = t.max; const r = F(e, (a - n) / 2); const o = function (t, e) { return i && t === 0 ? 0 : t + e }; return { min: o(n, -Math.abs(r)), max: o(a, r) } } function li (t, e) { return Object.assign(Object.create(t), e) } function hi (t, e, i) { i = i || function (i) { return t[i] < e }; let n; let a = t.length - 1; let r = 0; while (a - r > 1)n = r + a >> 1, i(n) ? r = n : a = n; return { lo: r, hi: a } } const ui = function (t, e, i) { return hi(t, i, function (n) { return t[n][e] < i }) }; const ci = function (t, e, i) { return hi(t, i, function (n) { return t[n][e] >= i }) }; function di (t, e, i) { let n = 0; let a = t.length; while (n < a && t[n] < e)n++; while (a > n && t[a - 1] > i)a--; return n > 0 || a < t.length ? t.slice(n, a) : t } const fi = ['push', 'pop', 'shift', 'splice', 'unshift']; function vi (t, e) { t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, '_chartjs', { configurable: !0, enumerable: !1, value: { listeners: [e] } }), fi.forEach(function (e) { const i = '_onData' + J(e); const n = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: function () { for (var e = arguments.length, a = new Array(e), r = 0; r < e; r++)a[r] = arguments[r]; const o = n.apply(this, a); return t._chartjs.listeners.forEach(function (t) { typeof t[i] === 'function' && t[i].apply(t, a) }), o } }) })) } function gi (t, e) { const i = t._chartjs; if (i) { const n = i.listeners; const a = n.indexOf(e); a !== -1 && n.splice(a, 1), n.length > 0 || (fi.forEach(function (e) { delete t[e] }), delete t._chartjs) } } function pi (t) { let e; let i; const n = new Set(); for (e = 0, i = t.length; e < i; ++e)n.add(t[e]); return n.size === i ? t : Array.from(n) } function yi (t) { let e; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ['']; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t; let a = arguments.length > 3 ? arguments[3] : void 0; const r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function () { return t[0] }; Q(a) || (a = Ri('_fallback', t)); const o = (e = {}, (0, m.Z)(e, Symbol.toStringTag, 'Object'), (0, m.Z)(e, '_cacheable', !0), (0, m.Z)(e, '_scopes', t), (0, m.Z)(e, '_rootScopes', n), (0, m.Z)(e, '_fallback', a), (0, m.Z)(e, '_getTarget', r), (0, m.Z)(e, 'override', function (e) { return yi([e].concat((0, c.Z)(t)), i, n, a) }), e); return new Proxy(o, { deleteProperty: function (e, i) { return delete e[i], delete e._keys, delete t[0][i], !0 }, get: function (e, n) { return ki(e, n, function () { return Li(n, i, t, e) }) }, getOwnPropertyDescriptor: function (t, e) { return Reflect.getOwnPropertyDescriptor(t._scopes[0], e) }, getPrototypeOf: function () { return Reflect.getPrototypeOf(t[0]) }, has: function (t, e) { return Ei(t).includes(e) }, ownKeys: function (t) { return Ei(t) }, set: function (t, e, i) { const n = t._storage || (t._storage = r()); return t[e] = n[e] = i, delete t._keys, !0 } }) } function mi (t, e, i, n) { const a = { _cacheable: !1, _proxy: t, _context: e, _subProxy: i, _stack: new Set(), _descriptors: bi(t, n), setContext: function (e) { return mi(t, e, i, n) }, override: function (a) { return mi(t.override(a), e, i, n) } }; return new Proxy(a, { deleteProperty: function (e, i) { return delete e[i], delete t[i], !0 }, get: function (t, e, i) { return ki(t, e, function () { return wi(t, e, i) }) }, getOwnPropertyDescriptor: function (e, i) { return e._descriptors.allKeys ? Reflect.has(t, i) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, i) }, getPrototypeOf: function () { return Reflect.getPrototypeOf(t) }, has: function (e, i) { return Reflect.has(t, i) }, ownKeys: function () { return Reflect.ownKeys(t) }, set: function (e, i, n) { return t[i] = n, delete e[i], !0 } }) } function bi (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { scriptable: !0, indexable: !0 }; const i = t._scriptable; const n = void 0 === i ? e.scriptable : i; const a = t._indexable; const r = void 0 === a ? e.indexable : a; const o = t._allKeys; const s = void 0 === o ? e.allKeys : o; return { allKeys: s, scriptable: n, indexable: r, isScriptable: tt(n) ? n : function () { return n }, isIndexable: tt(r) ? r : function () { return r } } } const xi = function (t, e) { return t ? t + J(e) : e }; const _i = function (t, e) { return R(e) && t !== 'adapters' && (Object.getPrototypeOf(e) === null || e.constructor === Object) }; function ki (t, e, i) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const n = i(); return t[e] = n, n } function wi (t, e, i) { const n = t._proxy; const a = t._context; const r = t._subProxy; const o = t._descriptors; let s = n[e]; return tt(s) && o.isScriptable(e) && (s = Mi(e, s, t, i)), L(s) && s.length && (s = Si(e, s, t, o.isIndexable)), _i(e, s) && (s = mi(s, a, r && r[e], o)), s } function Mi (t, e, i, n) { const a = i._proxy; const r = i._context; const o = i._subProxy; const s = i._stack; if (s.has(t)) throw new Error('Recursion detected: ' + Array.from(s).join('->') + '->' + t); return s.add(t), e = e(r, o || n), s.delete(t), _i(t, e) && (e = Oi(a._scopes, a, t, e)), e } function Si (t, e, i, n) { const a = i._proxy; const r = i._context; const o = i._subProxy; const s = i._descriptors; if (Q(r.index) && n(t))e = e[r.index % e.length]; else if (R(e[0])) { const l = e; const h = a._scopes.filter(function (t) { return t !== l }); e = []; let u; const c = (0, b.Z)(l); try { for (c.s(); !(u = c.n()).done;) { const d = u.value; const f = Oi(h, a, t, d); e.push(mi(f, r, o && o[t], s)) } } catch (v) { c.e(v) } finally { c.f() } } return e } function Pi (t, e, i) { return tt(t) ? t(e, i) : t } const Ci = function (t, e) { return !0 === t ? e : typeof t === 'string' ? G(e, t) : void 0 }; function Di (t, e, i, n, a) { let r; const o = (0, b.Z)(e); try { for (o.s(); !(r = o.n()).done;) { const s = r.value; const l = Ci(i, s); if (l) { t.add(l); const h = Pi(l._fallback, i, a); if (Q(h) && h !== i && h !== n) return h } else if (!1 === l && Q(n) && i !== n) return null } } catch (u) { o.e(u) } finally { o.f() } return !1 } function Oi (t, e, i, n) { const a = e._rootScopes; const r = Pi(e._fallback, i, n); const o = [].concat((0, c.Z)(t), (0, c.Z)(a)); const s = new Set(); s.add(n); let l = Ai(s, o, i, r || i, n); return l !== null && ((!Q(r) || r === i || (l = Ai(s, o, r, l, n), l !== null)) && yi(Array.from(s), [''], a, r, function () { return Ti(e, i, n) })) } function Ai (t, e, i, n, a) { while (i)i = Di(t, e, i, n, a); return i } function Ti (t, e, i) { const n = t._getTarget(); e in n || (n[e] = {}); const a = n[e]; return L(a) && R(i) ? i : a } function Li (t, e, i, n) { let a; let r; const o = (0, b.Z)(e); try { for (o.s(); !(r = o.n()).done;) { const s = r.value; if (a = Ri(xi(s, t), i), Q(a)) return _i(t, a) ? Oi(i, n, t, a) : a } } catch (l) { o.e(l) } finally { o.f() } } function Ri (t, e) { let i; const n = (0, b.Z)(e); try { for (n.s(); !(i = n.n()).done;) { const a = i.value; if (a) { const r = a[t]; if (Q(r)) return r } } } catch (o) { n.e(o) } finally { n.f() } } function Ei (t) { let e = t._keys; return e || (e = t._keys = Ii(t._scopes)), e } function Ii (t) { let e; const i = new Set(); const n = (0, b.Z)(t); try { for (n.s(); !(e = n.n()).done;) { var a; const r = e.value; const o = (0, b.Z)(Object.keys(r).filter(function (t) { return !t.startsWith('_') })); try { for (o.s(); !(a = o.n()).done;) { const s = a.value; i.add(s) } } catch (l) { o.e(l) } finally { o.f() } } } catch (l) { n.e(l) } finally { n.f() } return Array.from(i) } function Zi (t, e, i, n) { let a; let r; let o; let s; const l = t.iScale; const h = this._parsing.key; const u = void 0 === h ? 'r' : h; const c = new Array(n); for (a = 0, r = n; a < r; ++a)o = a + i, s = e[o], c[a] = { r: l.parse(G(s, u), o) }; return c } const zi = Number.EPSILON || 1e-14; const Fi = function (t, e) { return e < t.length && !t[e].skip && t[e] }; const Bi = function (t) { return t === 'x' ? 'y' : 'x' }; function Vi (t, e, i, n) { const a = t.skip ? e : t; const r = e; const o = i.skip ? e : i; const s = wt(r, a); const l = wt(o, r); let h = s / (s + l); let u = l / (s + l); h = isNaN(h) ? 0 : h, u = isNaN(u) ? 0 : u; const c = n * h; const d = n * u; return { previous: { x: r.x - c * (o.x - a.x), y: r.y - c * (o.y - a.y) }, next: { x: r.x + d * (o.x - a.x), y: r.y + d * (o.y - a.y) } } } function Wi (t, e, i) { for (var n, a, r, o, s, l = t.length, h = Fi(t, 0), u = 0; u < l - 1; ++u)s = h, h = Fi(t, u + 1), s && h && (pt(e[u], 0, zi) ? i[u] = i[u + 1] = 0 : (n = i[u] / e[u], a = i[u + 1] / e[u], o = Math.pow(n, 2) + Math.pow(a, 2), o <= 9 || (r = 3 / Math.sqrt(o), i[u] = n * r * e[u], i[u + 1] = a * r * e[u]))) } function Ni (t, e) { for (var i, n, a, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'x', o = Bi(r), s = t.length, l = Fi(t, 0), h = 0; h < s; ++h) if (n = a, a = l, l = Fi(t, h + 1), a) { const u = a[r]; const c = a[o]; n && (i = (u - n[r]) / 3, a['cp1'.concat(r)] = u - i, a['cp1'.concat(o)] = c - i * e[h]), l && (i = (l[r] - u) / 3, a['cp2'.concat(r)] = u + i, a['cp2'.concat(o)] = c + i * e[h]) } } function Hi (t) { let e; let i; let n; const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'x'; const r = Bi(a); const o = t.length; const s = Array(o).fill(0); const l = Array(o); let h = Fi(t, 0); for (e = 0; e < o; ++e) if (i = n, n = h, h = Fi(t, e + 1), n) { if (h) { const u = h[a] - n[a]; s[e] = u !== 0 ? (h[r] - n[r]) / u : 0 }l[e] = i ? h ? dt(s[e - 1]) !== dt(s[e]) ? 0 : (s[e - 1] + s[e]) / 2 : s[e - 1] : s[e] }Wi(t, s, l), Ni(t, l, a) } function ji (t, e, i) { return Math.max(Math.min(t, i), e) } function $i (t, e) { let i; let n; let a; let r; let o; let s = Ne(t[0], e); for (i = 0, n = t.length; i < n; ++i)o = r, r = s, s = i < n - 1 && Ne(t[i + 1], e), r && (a = t[i], o && (a.cp1x = ji(a.cp1x, e.left, e.right), a.cp1y = ji(a.cp1y, e.top, e.bottom)), s && (a.cp2x = ji(a.cp2x, e.left, e.right), a.cp2y = ji(a.cp2y, e.top, e.bottom))) } function Yi (t, e, i, n, a) { let r, o, s, l; if (e.spanGaps && (t = t.filter(function (t) { return !t.skip })), e.cubicInterpolationMode === 'monotone')Hi(t, a); else { let h = n ? t[t.length - 1] : t[0]; for (r = 0, o = t.length; r < o; ++r)s = t[r], l = Vi(h, s, t[Math.min(r + 1, o - (n ? 0 : 1)) % o], e.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, h = s }e.capBezierPoints && $i(t, i) } function Ui () { return typeof window !== 'undefined' && typeof document !== 'undefined' } function Xi (t) { let e = t.parentNode; return e && e.toString() === '[object ShadowRoot]' && (e = e.host), e } function qi (t, e, i) { let n; return typeof t === 'string' ? (n = parseInt(t, 10), t.indexOf('%') !== -1 && (n = n / 100 * e.parentNode[i])) : n = t, n } const Ki = function (t) { return window.getComputedStyle(t, null) }; function Gi (t, e) { return Ki(t).getPropertyValue(e) } const Ji = ['top', 'right', 'bottom', 'left']; function Qi (t, e, i) { const n = {}; i = i ? '-' + i : ''; for (let a = 0; a < 4; a++) { const r = Ji[a]; n[r] = parseFloat(t[e + '-' + r + i]) || 0 } return n.width = n.left + n.right, n.height = n.top + n.bottom, n } const tn = function (t, e, i) { return (t > 0 || e > 0) && (!i || !i.shadowRoot) }; function en (t, e) { let i; let n; const a = t.touches; const r = a && a.length ? a[0] : t; const o = r.offsetX; const s = r.offsetY; let l = !1; if (tn(o, s, t.target))i = o, n = s; else { const h = e.getBoundingClientRect(); i = r.clientX - h.left, n = r.clientY - h.top, l = !0 } return { x: i, y: n, box: l } } function nn (t, e) { if ('native' in t) return t; const i = e.canvas; const n = e.currentDevicePixelRatio; const a = Ki(i); const r = a.boxSizing === 'border-box'; const o = Qi(a, 'padding'); const s = Qi(a, 'border', 'width'); const l = en(t, i); const h = l.x; const u = l.y; const c = l.box; const d = o.left + (c && s.left); const f = o.top + (c && s.top); let v = e.width; let g = e.height; return r && (v -= o.width + s.width, g -= o.height + s.height), { x: Math.round((h - d) / v * i.width / n), y: Math.round((u - f) / g * i.height / n) } } function an (t, e, i) { let n, a; if (void 0 === e || void 0 === i) { const r = Xi(t); if (r) { const o = r.getBoundingClientRect(); const s = Ki(r); const l = Qi(s, 'border', 'width'); const h = Qi(s, 'padding'); e = o.width - h.width - l.width, i = o.height - h.height - l.height, n = qi(s.maxWidth, r, 'clientWidth'), a = qi(s.maxHeight, r, 'clientHeight') } else e = t.clientWidth, i = t.clientHeight } return { width: e, height: i, maxWidth: n || ot, maxHeight: a || ot } } const rn = function (t) { return Math.round(10 * t) / 10 }; function on (t, e, i, n) { const a = Ki(t); const r = Qi(a, 'margin'); const o = qi(a.maxWidth, t, 'clientWidth') || ot; const s = qi(a.maxHeight, t, 'clientHeight') || ot; const l = an(t, e, i); let h = l.width; let u = l.height; if (a.boxSizing === 'content-box') { const c = Qi(a, 'border', 'width'); const d = Qi(a, 'padding'); h -= d.width + c.width, u -= d.height + c.height } return h = Math.max(0, h - r.width), u = Math.max(0, n ? Math.floor(h / n) : u - r.height), h = rn(Math.min(h, o, l.maxWidth)), u = rn(Math.min(u, s, l.maxHeight)), h && !u && (u = rn(h / 2)), { width: h, height: u } } function sn (t, e, i) { const n = e || 1; const a = Math.floor(t.height * n); const r = Math.floor(t.width * n); t.height = a / n, t.width = r / n; const o = t.canvas; return o.style && (i || !o.style.height && !o.style.width) && (o.style.height = ''.concat(t.height, 'px'), o.style.width = ''.concat(t.width, 'px')), (t.currentDevicePixelRatio !== n || o.height !== a || o.width !== r) && (t.currentDevicePixelRatio = n, o.height = a, o.width = r, t.ctx.setTransform(n, 0, 0, n, 0, 0), !0) } const ln = (function () { let t = !1; try { const e = { get passive () { return t = !0, !1 } }; window.addEventListener('test', null, e), window.removeEventListener('test', null, e) } catch (i) {} return t }()); function hn (t, e) { const i = Gi(t, e); const n = i && i.match(/^(\d+)(\.\d+)?px$/); return n ? +n[1] : void 0 } function un (t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) } } function cn (t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: n === 'middle' ? i < 0.5 ? t.y : e.y : n === 'after' ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y } } function dn (t, e, i, n) { const a = { x: t.cp2x, y: t.cp2y }; const r = { x: e.cp1x, y: e.cp1y }; const o = un(t, a, i); const s = un(a, r, i); const l = un(r, e, i); const h = un(o, s, i); const u = un(s, l, i); return un(h, u, i) } const fn = new Map(); function vn (t, e) { e = e || {}; const i = t + JSON.stringify(e); let n = fn.get(i); return n || (n = new Intl.NumberFormat(t, e), fn.set(i, n)), n } function gn (t, e, i) { return vn(e, i).format(t) } const pn = function (t, e) { return { x: function (i) { return t + t + e - i }, setWidth: function (t) { e = t }, textAlign: function (t) { return t === 'center' ? t : t === 'right' ? 'left' : 'right' }, xPlus: function (t, e) { return t - e }, leftForLtr: function (t, e) { return t - e } } }; const yn = function () { return { x: function (t) { return t }, setWidth: function (t) {}, textAlign: function (t) { return t }, xPlus: function (t, e) { return t + e }, leftForLtr: function (t, e) { return t } } }; function mn (t, e, i) { return t ? pn(e, i) : yn() } function bn (t, e) { let i, n; e !== 'ltr' && e !== 'rtl' || (i = t.canvas.style, n = [i.getPropertyValue('direction'), i.getPropertyPriority('direction')], i.setProperty('direction', e, 'important'), t.prevTextDirection = n) } function xn (t, e) { void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty('direction', e[0], e[1])) } function _n (t) { return t === 'angle' ? { between: Pt, compare: Mt, normalize: St } : { between: Ot, compare: function (t, e) { return t - e }, normalize: function (t) { return t } } } function kn (t) { const e = t.start; const i = t.end; const n = t.count; const a = t.loop; const r = t.style; return { start: e % n, end: i % n, loop: a && (i - e + 1) % n === 0, style: r } } function wn (t, e, i) { let n; let a; const r = i.property; const o = i.start; const s = i.end; const l = _n(r); const h = l.between; const u = l.normalize; const c = e.length; let d = t.start; let f = t.end; const v = t.loop; if (v) { for (d += c, f += c, n = 0, a = c; n < a; ++n) { if (!h(u(e[d % c][r]), o, s)) break; d--, f-- }d %= c, f %= c } return f < d && (f += c), { start: d, end: f, loop: v, style: t.style } } function Mn (t, e, i) { if (!i) return [t]; for (var n, a, r, o = i.property, s = i.start, l = i.end, h = e.length, u = _n(o), c = u.compare, d = u.between, f = u.normalize, v = wn(t, e, i), g = v.start, p = v.end, y = v.loop, m = v.style, b = [], x = !1, _ = null, k = function () { return d(s, r, n) && c(s, r) !== 0 }, w = function () { return c(l, n) === 0 || d(l, r, n) }, M = function () { return x || k() }, S = function () { return !x || w() }, P = g, C = g; P <= p; ++P)a = e[P % h], a.skip || (n = f(a[o]), n !== r && (x = d(n, s, l), _ === null && M() && (_ = c(n, s) === 0 ? P : C), _ !== null && S() && (b.push(kn({ start: _, end: P, loop: y, count: h, style: m })), _ = null), C = P, r = n)); return _ !== null && b.push(kn({ start: _, end: p, loop: y, count: h, style: m })), b } function Sn (t, e) { for (var i = [], n = t.segments, a = 0; a < n.length; a++) { const r = Mn(n[a], t.points, e); r.length && i.push.apply(i, (0, c.Z)(r)) } return i } function Pn (t, e, i, n) { let a = 0; let r = e - 1; if (i && !n) while (a < e && !t[a].skip)a++; while (a < e && t[a].skip)a++; a %= e, i && (r += a); while (r > a && t[r % e].skip)r--; return r %= e, { start: a, end: r } } function Cn (t, e, i, n) { let a; const r = t.length; const o = []; let s = e; let l = t[e]; for (a = e + 1; a <= i; ++a) { const h = t[a % r]; h.skip || h.stop ? l.skip || (n = !1, o.push({ start: e % r, end: (a - 1) % r, loop: n }), e = s = h.stop ? a : null) : (s = a, l.skip && (e = a)), l = h } return s !== null && o.push({ start: e % r, end: s % r, loop: n }), o } function Dn (t, e) { const i = t.points; const n = t.options.spanGaps; const a = i.length; if (!a) return []; const r = !!t._loop; const o = Pn(i, a, r, n); const s = o.start; const l = o.end; if (!0 === n) return On(t, [{ start: s, end: l, loop: r }], i, e); const h = l < s ? l + a : l; const u = !!t._fullLoop && s === 0 && l === a - 1; return On(t, Cn(i, s, h, u), i, e) } function On (t, e, i, n) { return n && n.setContext && i ? An(t, e, i, n) : e } function An (t, e, i, n) { const a = t._chart.getContext(); const r = Tn(t.options); const o = t._datasetIndex; const s = t.options.spanGaps; const l = i.length; const h = []; let u = r; let c = e[0].start; let d = c; function f (t, e, n, a) { const r = s ? -1 : 1; if (t !== e) { t += l; while (i[t % l].skip)t -= r; while (i[e % l].skip)e += r; t % l !== e % l && (h.push({ start: t % l, end: e % l, loop: n, style: a }), u = a, c = e % l) } } let v; const g = (0, b.Z)(e); try { for (g.s(); !(v = g.n()).done;) { const p = v.value; c = s ? c : p.start; let y = i[c % l]; let m = void 0; for (d = c + 1; d <= p.end; d++) { const x = i[d % l]; m = Tn(n.setContext(li(a, { type: 'segment', p0: y, p1: x, p0DataIndex: (d - 1) % l, p1DataIndex: d % l, datasetIndex: o }))), Ln(m, u) && f(c, d - 1, p.loop, u), y = x, u = m }c < d - 1 && f(c, d - 1, p.loop, u) } } catch (_) { g.e(_) } finally { g.f() } return h } function Tn (t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function Ln (t, e) { return e && JSON.stringify(t) !== JSON.stringify(e) }
    /*!
 * Chart.js v3.8.2
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
    const Rn = (function () { function t () { (0, _.Z)(this, t), this._request = null, this._charts = new Map(), this._running = !1, this._lastDate = void 0 } return (0, k.Z)(t, [{ key: '_notify', value: function (t, e, i, n) { const a = e.listeners[n]; const r = e.duration; a.forEach(function (n) { return n({ chart: t, initial: e.initial, numSteps: r, currentStep: Math.min(i - e.start, r) }) }) } }, { key: '_refresh', value: function () { const t = this; this._request || (this._running = !0, this._request = w.call(window, function () { t._update(), t._request = null, t._running && t._refresh() })) } }, { key: '_update', value: function () { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Date.now(); let i = 0; this._charts.forEach(function (n, a) { if (n.running && n.items.length) { for (var r, o = n.items, s = o.length - 1, l = !1; s >= 0; --s)r = o[s], r._active ? (r._total > n.duration && (n.duration = r._total), r.tick(e), l = !0) : (o[s] = o[o.length - 1], o.pop()); l && (a.draw(), t._notify(a, n, e, 'progress')), o.length || (n.running = !1, t._notify(a, n, e, 'complete'), n.initial = !1), i += o.length } }), this._lastDate = e, i === 0 && (this._running = !1) } }, { key: '_getAnims', value: function (t) { const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } }, { key: 'listen', value: function (t, e, i) { this._getAnims(t).listeners[e].push(i) } }, { key: 'add', value: function (t, e) { let i; e && e.length && (i = this._getAnims(t).items).push.apply(i, (0, c.Z)(e)) } }, { key: 'has', value: function (t) { return this._getAnims(t).items.length > 0 } }, { key: 'start', value: function (t) { const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(function (t, e) { return Math.max(t, e._duration) }, 0), this._refresh()) } }, { key: 'running', value: function (t) { if (!this._running) return !1; const e = this._charts.get(t); return !!(e && e.running && e.items.length) } }, { key: 'stop', value: function (t) { const e = this._charts.get(t); if (e && e.items.length) { for (let i = e.items, n = i.length - 1; n >= 0; --n)i[n].cancel(); e.items = [], this._notify(t, e, Date.now(), 'complete') } } }, { key: 'remove', value: function (t) { return this._charts.delete(t) } }]), t }()); const En = new Rn(); const In = 'transparent'; const Zn = { boolean: function (t, e, i) { return i > 0.5 ? e : t }, color: function (t, e, i) { const n = Ce(t || In); const a = n.valid && Ce(e || In); return a && a.valid ? a.mix(n, i).hexString() : e }, number: function (t, e, i) { return t + (e - t) * i } }; const zn = (function () { function t (e, i, n, a) { (0, _.Z)(this, t); const r = i[n]; a = oi([e.to, a, r, e.from]); const o = oi([e.from, r, a]); this._active = !0, this._fn = e.fn || Zn[e.type || (0, x.Z)(o)], this._easing = Rt[e.easing] || Rt.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = i, this._prop = n, this._from = o, this._to = a, this._promises = void 0 } return (0, k.Z)(t, [{ key: 'active', value: function () { return this._active } }, { key: 'update', value: function (t, e, i) { if (this._active) { this._notify(!1); const n = this._target[this._prop]; const a = i - this._start; const r = this._duration - a; this._start = i, this._duration = Math.floor(Math.max(r, t.duration)), this._total += a, this._loop = !!t.loop, this._to = oi([t.to, e, n, t.from]), this._from = oi([t.from, n, e]) } } }, { key: 'cancel', value: function () { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } }, { key: 'tick', value: function (t) { let e; const i = t - this._start; const n = this._duration; const a = this._prop; const r = this._from; const o = this._loop; const s = this._to; if (this._active = r !== s && (o || i < n), !this._active) return this._target[a] = s, void this._notify(!0); i < 0 ? this._target[a] = r : (e = i / n % 2, e = o && e > 1 ? 2 - e : e, e = this._easing(Math.min(1, Math.max(0, e))), this._target[a] = this._fn(r, s, e)) } }, { key: 'wait', value: function () { const t = this._promises || (this._promises = []); return new Promise(function (e, i) { t.push({ res: e, rej: i }) }) } }, { key: '_notify', value: function (t) { for (let e = t ? 'res' : 'rej', i = this._promises || [], n = 0; n < i.length; n++)i[n][e]() } }]), t }()); const Fn = ['x', 'y', 'borderWidth', 'radius', 'tension']; const Bn = ['color', 'borderColor', 'backgroundColor']; Ee.set('animation', { delay: void 0, duration: 1e3, easing: 'easeOutQuart', fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }); const Vn = Object.keys(Ee.animation); Ee.describe('animation', { _fallback: !1, _indexable: !1, _scriptable: function (t) { return t !== 'onProgress' && t !== 'onComplete' && t !== 'fn' } }), Ee.set('animations', { colors: { type: 'color', properties: Bn }, numbers: { type: 'number', properties: Fn } }), Ee.describe('animations', { _fallback: 'animation' }), Ee.set('transitions', { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: 'transparent' }, visible: { type: 'boolean', duration: 0 } } }, hide: { animations: { colors: { to: 'transparent' }, visible: { type: 'boolean', easing: 'linear', fn: function (t) { return 0 | t } } } } }); const Wn = (function () { function t (e, i) { (0, _.Z)(this, t), this._chart = e, this._properties = new Map(), this.configure(i) } return (0, k.Z)(t, [{ key: 'configure', value: function (t) { if (R(t)) { const e = this._properties; Object.getOwnPropertyNames(t).forEach(function (i) { const n = t[i]; if (R(n)) { let a; const r = {}; const o = (0, b.Z)(Vn); try { for (o.s(); !(a = o.n()).done;) { const s = a.value; r[s] = n[s] } } catch (l) { o.e(l) } finally { o.f() }(L(n.properties) && n.properties || [i]).forEach(function (t) { t !== i && e.has(t) || e.set(t, r) }) } }) } } }, { key: '_animateOptions', value: function (t, e) { const i = e.options; const n = Hn(t, i); if (!n) return []; const a = this._createAnimations(n, i); return i.$shared && Nn(t.options.$animations, i).then(function () { t.options = i }, function () {}), a } }, { key: '_createAnimations', value: function (t, e) { let i; const n = this._properties; const a = []; const r = t.$animations || (t.$animations = {}); const o = Object.keys(e); const s = Date.now(); for (i = o.length - 1; i >= 0; --i) { const l = o[i]; if (l.charAt(0) !== '$') if (l !== 'options') { const h = e[l]; let u = r[l]; const d = n.get(l); if (u) { if (d && u.active()) { u.update(d, h, s); continue }u.cancel() }d && d.duration ? (r[l] = u = new zn(d, t, l, h), a.push(u)) : t[l] = h } else a.push.apply(a, (0, c.Z)(this._animateOptions(t, e))) } return a } }, { key: 'update', value: function (t, e) { if (this._properties.size !== 0) { const i = this._createAnimations(t, e); return i.length ? (En.add(this._chart, i), !0) : void 0 }Object.assign(t, e) } }]), t }()); function Nn (t, e) { for (var i = [], n = Object.keys(e), a = 0; a < n.length; a++) { const r = t[n[a]]; r && r.active() && i.push(r.wait()) } return Promise.all(i) } function Hn (t, e) { if (e) { let i = t.options; if (i) return i.$shared && (t.options = i = Object.assign({}, i, { $shared: !1, $animations: {} })), i; t.options = e } } function jn (t, e) { const i = t && t.options || {}; const n = i.reverse; const a = void 0 === i.min ? e : 0; const r = void 0 === i.max ? e : 0; return { start: n ? r : a, end: n ? a : r } } function $n (t, e, i) { if (!1 === i) return !1; const n = jn(t, i); const a = jn(e, i); return { top: a.end, right: n.end, bottom: a.start, left: n.start } } function Yn (t) { let e, i, n, a; return R(t) ? (e = t.top, i = t.right, n = t.bottom, a = t.left) : e = i = n = a = t, { top: e, right: i, bottom: n, left: a, disabled: !1 === t } } function Un (t, e) { let i; let n; const a = []; const r = t._getSortedDatasetMetas(e); for (i = 0, n = r.length; i < n; ++i)a.push(r[i].index); return a } function Xn (t, e, i) { let n; let a; let r; let o; const s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const l = t.keys; const h = s.mode === 'single'; if (e !== null) { for (n = 0, a = l.length; n < a; ++n) { if (r = +l[n], r === i) { if (s.all) continue; break }o = t.values[r], E(o) && (h || e === 0 || dt(e) === dt(o)) && (e += o) } return e } } function qn (t) { let e; let i; let n; const a = Object.keys(t); const r = new Array(a.length); for (e = 0, i = a.length; e < i; ++e)n = a[e], r[e] = { x: n, y: t[n] }; return r } function Kn (t, e) { const i = t && t.options.stacked; return i || void 0 === i && void 0 !== e.stack } function Gn (t, e, i) { return ''.concat(t.id, '.').concat(e.id, '.').concat(i.stack || i.type) } function Jn (t) { const e = t.getUserBounds(); const i = e.min; const n = e.max; const a = e.minDefined; const r = e.maxDefined; return { min: a ? i : Number.NEGATIVE_INFINITY, max: r ? n : Number.POSITIVE_INFINITY } } function Qn (t, e, i) { const n = t[e] || (t[e] = {}); return n[i] || (n[i] = {}) } function ta (t, e, i, n) { let a; const r = (0, b.Z)(e.getMatchingVisibleMetas(n).reverse()); try { for (r.s(); !(a = r.n()).done;) { const o = a.value; const s = t[o.index]; if (i && s > 0 || !i && s < 0) return o.index } } catch (l) { r.e(l) } finally { r.f() } return null } function ea (t, e) { for (var i, n = t.chart, a = t._cachedMeta, r = n._stacks || (n._stacks = {}), o = a.iScale, s = a.vScale, l = a.index, h = o.axis, u = s.axis, c = Gn(o, s, a), d = e.length, f = 0; f < d; ++f) { const v = e[f]; const g = v[h]; const p = v[u]; const y = v._stacks || (v._stacks = {}); i = y[u] = Qn(r, c, g), i[l] = p, i._top = ta(i, s, !0, a.type), i._bottom = ta(i, s, !1, a.type) } } function ia (t, e) { const i = t.scales; return Object.keys(i).filter(function (t) { return i[t].axis === e }).shift() } function na (t, e) { return li(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: 'default', type: 'dataset' }) } function aa (t, e, i) { return li(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: i, index: e, mode: 'default', type: 'data' }) } function ra (t, e) { const i = t.controller.index; const n = t.vScale && t.vScale.axis; if (n) { e = e || t._parsed; let a; const r = (0, b.Z)(e); try { for (r.s(); !(a = r.n()).done;) { const o = a.value; const s = o._stacks; if (!s || void 0 === s[n] || void 0 === s[n][i]) return; delete s[n][i] } } catch (l) { r.e(l) } finally { r.f() } } } const oa = function (t) { return t === 'reset' || t === 'none' }; const sa = function (t, e) { return e ? t : Object.assign({}, t) }; const la = function (t, e, i) { return t && !e.hidden && e._stacked && { keys: Un(i, !0), values: null } }; const ha = (function () { function t (e, i) { (0, _.Z)(this, t), this.chart = e, this._ctx = e.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize() } return (0, k.Z)(t, [{ key: 'initialize', value: function () { const t = this._cachedMeta; this.configure(), this.linkScales(), t._stacked = Kn(t.vScale, t), this.addElements() } }, { key: 'updateIndex', value: function (t) { this.index !== t && ra(this._cachedMeta), this.index = t } }, { key: 'linkScales', value: function () { const t = this.chart; const e = this._cachedMeta; const i = this.getDataset(); const n = function (t, e, i, n) { return t === 'x' ? e : t === 'r' ? n : i }; const a = e.xAxisID = Z(i.xAxisID, ia(t, 'x')); const r = e.yAxisID = Z(i.yAxisID, ia(t, 'y')); const o = e.rAxisID = Z(i.rAxisID, ia(t, 'r')); const s = e.indexAxis; const l = e.iAxisID = n(s, a, r, o); const h = e.vAxisID = n(s, r, a, o); e.xScale = this.getScaleForId(a), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(o), e.iScale = this.getScaleForId(l), e.vScale = this.getScaleForId(h) } }, { key: 'getDataset', value: function () { return this.chart.data.datasets[this.index] } }, { key: 'getMeta', value: function () { return this.chart.getDatasetMeta(this.index) } }, { key: 'getScaleForId', value: function (t) { return this.chart.scales[t] } }, { key: '_getOtherScale', value: function (t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale } }, { key: 'reset', value: function () { this._update('reset') } }, { key: '_destroy', value: function () { const t = this._cachedMeta; this._data && gi(this._data, this), t._stacked && ra(t) } }, { key: '_dataCheck', value: function () { const t = this.getDataset(); const e = t.data || (t.data = []); const i = this._data; if (R(e)) this._data = qn(e); else if (i !== e) { if (i) { gi(i, this); const n = this._cachedMeta; ra(n), n._parsed = [] }e && Object.isExtensible(e) && vi(e, this), this._syncList = [], this._data = e } } }, { key: 'addElements', value: function () { const t = this._cachedMeta; this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType()) } }, { key: 'buildOrUpdateElements', value: function (t) { const e = this._cachedMeta; const i = this.getDataset(); let n = !1; this._dataCheck(); const a = e._stacked; e._stacked = Kn(e.vScale, e), e.stack !== i.stack && (n = !0, ra(e), e.stack = i.stack), this._resyncElements(t), (n || a !== e._stacked) && ea(this, e._parsed) } }, { key: 'configure', value: function () { const t = this.chart.config; const e = t.datasetScopeKeys(this._type); const i = t.getOptionScopes(this.getDataset(), e, !0); this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } }, { key: 'parse', value: function (t, e) { let i; let n; let a; const r = this._cachedMeta; const o = this._data; const s = r.iScale; const l = r._stacked; const h = s.axis; let u = t === 0 && e === o.length || r._sorted; let c = t > 0 && r._parsed[t - 1]; if (!1 === this._parsing)r._parsed = o, r._sorted = !0, a = o; else { a = L(o[t]) ? this.parseArrayData(r, o, t, e) : R(o[t]) ? this.parseObjectData(r, o, t, e) : this.parsePrimitiveData(r, o, t, e); const d = function () { return n[h] === null || c && n[h] < c[h] }; for (i = 0; i < e; ++i)r._parsed[i + t] = n = a[i], u && (d() && (u = !1), c = n); r._sorted = u }l && ea(this, a) } }, { key: 'parsePrimitiveData', value: function (t, e, i, n) { let a; let r; let o; const s = t.iScale; const l = t.vScale; const h = s.axis; const u = l.axis; const c = s.getLabels(); const d = s === l; const f = new Array(n); for (a = 0, r = n; a < r; ++a) { var v; o = a + i, f[a] = (v = {}, (0, m.Z)(v, h, d || s.parse(c[o], o)), (0, m.Z)(v, u, l.parse(e[o], o)), v) } return f } }, { key: 'parseArrayData', value: function (t, e, i, n) { let a; let r; let o; let s; const l = t.xScale; const h = t.yScale; const u = new Array(n); for (a = 0, r = n; a < r; ++a)o = a + i, s = e[o], u[a] = { x: l.parse(s[0], o), y: h.parse(s[1], o) }; return u } }, { key: 'parseObjectData', value: function (t, e, i, n) { let a; let r; let o; let s; const l = t.xScale; const h = t.yScale; const u = this._parsing; const c = u.xAxisKey; const d = void 0 === c ? 'x' : c; const f = u.yAxisKey; const v = void 0 === f ? 'y' : f; const g = new Array(n); for (a = 0, r = n; a < r; ++a)o = a + i, s = e[o], g[a] = { x: l.parse(G(s, d), o), y: h.parse(G(s, v), o) }; return g } }, { key: 'getParsed', value: function (t) { return this._cachedMeta._parsed[t] } }, { key: 'getDataElement', value: function (t) { return this._cachedMeta.data[t] } }, { key: 'applyStack', value: function (t, e, i) { const n = this.chart; const a = this._cachedMeta; const r = e[t.axis]; const o = { keys: Un(n, !0), values: e._stacks[t.axis] }; return Xn(o, r, a.index, { mode: i }) } }, { key: 'updateRangeFromParsed', value: function (t, e, i, n) { const a = i[e.axis]; let r = a === null ? NaN : a; const o = n && i._stacks[e.axis]; n && o && (n.values = o, r = Xn(n, a, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r) } }, { key: 'getMinMax', value: function (t, e) { let i; let n; const a = this._cachedMeta; const r = a._parsed; const o = a._sorted && t === a.iScale; const s = r.length; const l = this._getOtherScale(t); const h = la(e, a, this.chart); const u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; const c = Jn(l); const d = c.min; const f = c.max; function v () { n = r[i]; const e = n[l.axis]; return !E(n[t.axis]) || d > e || f < e } for (i = 0; i < s; ++i) if (!v() && (this.updateRangeFromParsed(u, t, n, h), o)) break; if (o) for (i = s - 1; i >= 0; --i) if (!v()) { this.updateRangeFromParsed(u, t, n, h); break } return u } }, { key: 'getAllParsedValues', value: function (t) { let e; let i; let n; const a = this._cachedMeta._parsed; const r = []; for (e = 0, i = a.length; e < i; ++e)n = a[e][t.axis], E(n) && r.push(n); return r } }, { key: 'getMaxOverflow', value: function () { return !1 } }, { key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta; const i = e.iScale; const n = e.vScale; const a = this.getParsed(t); return { label: i ? '' + i.getLabelForValue(a[i.axis]) : '', value: n ? '' + n.getLabelForValue(a[n.axis]) : '' } } }, { key: '_update', value: function (t) { const e = this._cachedMeta; this.update(t || 'default'), e._clip = Yn(Z(this.options.clip, $n(e.xScale, e.yScale, this.getMaxOverflow()))) } }, { key: 'update', value: function (t) {} }, { key: 'draw', value: function () { let t; const e = this._ctx; const i = this.chart; const n = this._cachedMeta; const a = n.data || []; const r = i.chartArea; const o = []; const s = this._drawStart || 0; const l = this._drawCount || a.length - s; const h = this.options.drawActiveElementsOnTop; for (n.dataset && n.dataset.draw(e, r, s, l), t = s; t < s + l; ++t) { const u = a[t]; u.hidden || (u.active && h ? o.push(u) : u.draw(e, r)) } for (t = 0; t < o.length; ++t)o[t].draw(e, r) } }, { key: 'getStyle', value: function (t, e) { const i = e ? 'active' : 'default'; return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i) } }, { key: 'getContext', value: function (t, e, i) { let n; const a = this.getDataset(); if (t >= 0 && t < this._cachedMeta.data.length) { const r = this._cachedMeta.data[t]; n = r.$context || (r.$context = aa(this.getContext(), t, r)), n.parsed = this.getParsed(t), n.raw = a.data[t], n.index = n.dataIndex = t } else n = this.$context || (this.$context = na(this.chart.getContext(), this.index)), n.dataset = a, n.index = n.datasetIndex = this.index; return n.active = !!e, n.mode = i, n } }, { key: 'resolveDatasetElementOptions', value: function (t) { return this._resolveElementOptions(this.datasetElementType.id, t) } }, { key: 'resolveDataElementOptions', value: function (t, e) { return this._resolveElementOptions(this.dataElementType.id, e, t) } }, { key: '_resolveElementOptions', value: function (t) { const e = this; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'default'; const n = arguments.length > 2 ? arguments[2] : void 0; const a = i === 'active'; const r = this._cachedDataOpts; const o = t + '-' + i; const s = r[o]; const l = this.enableOptionSharing && Q(n); if (s) return sa(s, l); const h = this.chart.config; const u = h.datasetElementScopeKeys(this._type, t); const c = a ? [''.concat(t, 'Hover'), 'hover', t, ''] : [t, '']; const d = h.getOptionScopes(this.getDataset(), u); const f = Object.keys(Ee.elements[t]); const v = function () { return e.getContext(n, a) }; const g = h.resolveNamedOptions(d, f, v, c); return g.$shared && (g.$shared = l, r[o] = Object.freeze(sa(g, l))), g } }, { key: '_resolveAnimations', value: function (t, e, i) { let n; const a = this.chart; const r = this._cachedDataOpts; const o = 'animation-'.concat(e); const s = r[o]; if (s) return s; if (!1 !== a.options.animation) { const l = this.chart.config; const h = l.datasetAnimationScopeKeys(this._type, e); const u = l.getOptionScopes(this.getDataset(), h); n = l.createResolver(u, this.getContext(t, i, e)) } const c = new Wn(a, n && n.animations); return n && n._cacheable && (r[o] = Object.freeze(c)), c } }, { key: 'getSharedOptions', value: function (t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } }, { key: 'includeOptions', value: function (t, e) { return !e || oa(t) || this.chart._animationsDisabled } }, { key: '_getSharedOptions', value: function (t, e) { const i = this.resolveDataElementOptions(t, e); const n = this._sharedOptions; const a = this.getSharedOptions(i); const r = this.includeOptions(e, a) || a !== n; return this.updateSharedOptions(a, e, i), { sharedOptions: a, includeOptions: r } } }, { key: 'updateElement', value: function (t, e, i, n) { oa(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i) } }, { key: 'updateSharedOptions', value: function (t, e, i) { t && !oa(e) && this._resolveAnimations(void 0, e).update(t, i) } }, { key: '_setStyle', value: function (t, e, i, n) { t.active = n; const a = this.getStyle(e, n); this._resolveAnimations(e, i, n).update(t, { options: !n && this.getSharedOptions(a) || a }) } }, { key: 'removeHoverStyle', value: function (t, e, i) { this._setStyle(t, i, 'active', !1) } }, { key: 'setHoverStyle', value: function (t, e, i) { this._setStyle(t, i, 'active', !0) } }, { key: '_removeDatasetHoverStyle', value: function () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, 'active', !1) } }, { key: '_setDatasetHoverStyle', value: function () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, 'active', !0) } }, { key: '_resyncElements', value: function (t) { let e; const i = this._data; const n = this._cachedMeta.data; const a = (0, b.Z)(this._syncList); try { for (a.s(); !(e = a.n()).done;) { const r = (0, y.Z)(e.value, 3); const o = r[0]; const s = r[1]; const l = r[2]; this[o](s, l) } } catch (d) { a.e(d) } finally { a.f() } this._syncList = []; const h = n.length; const u = i.length; const c = Math.min(u, h); c && this.parse(0, c), u > h ? this._insertElements(h, u - h, t) : u < h && this._removeElements(u, h - u) } }, { key: '_insertElements', value: function (t, e) { let i; const n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const a = this._cachedMeta; const r = a.data; const o = t + e; const s = function (t) { for (t.length += e, i = t.length - 1; i >= o; i--)t[i] = t[i - e] }; for (s(r), i = t; i < o; ++i)r[i] = new this.dataElementType(); this._parsing && s(a._parsed), this.parse(t, e), n && this.updateElements(r, t, e, 'reset') } }, { key: 'updateElements', value: function (t, e, i, n) {} }, { key: '_removeElements', value: function (t, e) { const i = this._cachedMeta; if (this._parsing) { const n = i._parsed.splice(t, e); i._stacked && ra(i, n) }i.data.splice(t, e) } }, { key: '_sync', value: function (t) { if (this._parsing) this._syncList.push(t); else { const e = (0, y.Z)(t, 3); const i = e[0]; const n = e[1]; const a = e[2]; this[i](n, a) } this.chart._dataChanges.push([this.index].concat((0, c.Z)(t))) } }, { key: '_onDataPush', value: function () { const t = arguments.length; this._sync(['_insertElements', this.getDataset().data.length - t, t]) } }, { key: '_onDataPop', value: function () { this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]) } }, { key: '_onDataShift', value: function () { this._sync(['_removeElements', 0, 1]) } }, { key: '_onDataSplice', value: function (t, e) { e && this._sync(['_removeElements', t, e]); const i = arguments.length - 2; i && this._sync(['_insertElements', t, i]) } }, { key: '_onDataUnshift', value: function () { this._sync(['_insertElements', 0, arguments.length]) } }]), t }()); function ua (t, e) { if (!t._cache.$bar) { for (var i = t.getMatchingVisibleMetas(e), n = [], a = 0, r = i.length; a < r; a++)n = n.concat(i[a].controller.getAllParsedValues(t)); t._cache.$bar = pi(n.sort(function (t, e) { return t - e })) } return t._cache.$bar } function ca (t) { let e; let i; let n; let a; const r = t.iScale; const o = ua(r, t.type); let s = r._length; const l = function () { n !== 32767 && n !== -32768 && (Q(a) && (s = Math.min(s, Math.abs(n - a) || s)), a = n) }; for (e = 0, i = o.length; e < i; ++e)n = r.getPixelForValue(o[e]), l(); for (a = void 0, e = 0, i = r.ticks.length; e < i; ++e)n = r.getPixelForTick(e), l(); return s } function da (t, e, i, n) { let a; let r; const o = i.barThickness; return T(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), { chunk: a / n, ratio: r, start: e.pixels[t] - a / 2 } } function fa (t, e, i, n) { const a = e.pixels; const r = a[t]; let o = t > 0 ? a[t - 1] : null; let s = t < a.length - 1 ? a[t + 1] : null; const l = i.categoryPercentage; o === null && (o = r - (s === null ? e.end - e.start : s - r)), s === null && (s = r + r - o); const h = r - (r - Math.min(o, s)) / 2 * l; const u = Math.abs(s - o) / 2 * l; return { chunk: u / n, ratio: i.barPercentage, start: h } } function va (t, e, i, n) { const a = i.parse(t[0], n); const r = i.parse(t[1], n); const o = Math.min(a, r); const s = Math.max(a, r); let l = o; let h = s; Math.abs(o) > Math.abs(s) && (l = s, h = o), e[i.axis] = h, e._custom = { barStart: l, barEnd: h, start: a, end: r, min: o, max: s } } function ga (t, e, i, n) { return L(t) ? va(t, e, i, n) : e[i.axis] = i.parse(t, n), e } function pa (t, e, i, n) { let a; let r; let o; let s; const l = t.iScale; const h = t.vScale; const u = l.getLabels(); const c = l === h; const d = []; for (a = i, r = i + n; a < r; ++a)s = e[a], o = {}, o[l.axis] = c || l.parse(u[a], a), d.push(ga(s, o, h, a)); return d } function ya (t) { return t && void 0 !== t.barStart && void 0 !== t.barEnd } function ma (t, e, i) { return t !== 0 ? dt(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1) } function ba (t) { let e, i, n, a, r; return t.horizontal ? (e = t.base > t.x, i = 'left', n = 'right') : (e = t.base < t.y, i = 'bottom', n = 'top'), e ? (a = 'end', r = 'start') : (a = 'start', r = 'end'), { start: i, end: n, reverse: e, top: a, bottom: r } } function xa (t, e, i, n) { let a = e.borderSkipped; const r = {}; if (a) { const o = ba(t); const s = o.start; const l = o.end; const h = o.reverse; const u = o.top; const c = o.bottom; a === 'middle' && i && (t.enableBorderRadius = !0, (i._top || 0) === n ? a = u : (i._bottom || 0) === n ? a = c : (r[_a(c, s, l, h)] = !0, a = u)), r[_a(a, s, l, h)] = !0, t.borderSkipped = r } else t.borderSkipped = r } function _a (t, e, i, n) { return n ? (t = ka(t, e, i), t = wa(t, i, e)) : t = wa(t, e, i), t } function ka (t, e, i) { return t === e ? i : t === i ? e : t } function wa (t, e, i) { return t === 'start' ? e : t === 'end' ? i : t } function Ma (t, e, i) { const n = e.inflateAmount; t.inflateAmount = n === 'auto' ? i === 1 ? 0.33 : 0 : n }ha.defaults = {}, ha.prototype.datasetElementType = null, ha.prototype.dataElementType = null; const Sa = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'parsePrimitiveData', value: function (t, e, i, n) { return pa(t, e, i, n) } }, { key: 'parseArrayData', value: function (t, e, i, n) { return pa(t, e, i, n) } }, { key: 'parseObjectData', value: function (t, e, i, n) { let a; let r; let o; let s; const l = t.iScale; const h = t.vScale; const u = this._parsing; const c = u.xAxisKey; const d = void 0 === c ? 'x' : c; const f = u.yAxisKey; const v = void 0 === f ? 'y' : f; const g = l.axis === 'x' ? d : v; const p = h.axis === 'x' ? d : v; const y = []; for (a = i, r = i + n; a < r; ++a)s = e[a], o = {}, o[l.axis] = l.parse(G(s, g), a), y.push(ga(G(s, p), o, h, a)); return y } }, { key: 'updateRangeFromParsed', value: function (t, e, n, a) { (0, f.Z)((0, v.Z)(i.prototype), 'updateRangeFromParsed', this).call(this, t, e, n, a); const r = n._custom; r && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, r.min), t.max = Math.max(t.max, r.max)) } }, { key: 'getMaxOverflow', value: function () { return 0 } }, { key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta; const i = e.iScale; const n = e.vScale; const a = this.getParsed(t); const r = a._custom; const o = ya(r) ? '[' + r.start + ', ' + r.end + ']' : '' + n.getLabelForValue(a[n.axis]); return { label: '' + i.getLabelForValue(a[i.axis]), value: o } } }, { key: 'initialize', value: function () { this.enableOptionSharing = !0, (0, f.Z)((0, v.Z)(i.prototype), 'initialize', this).call(this); const t = this._cachedMeta; t.stack = this.getDataset().stack } }, { key: 'update', value: function (t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) } }, { key: 'updateElements', value: function (t, e, i, n) { for (let a = n === 'reset', r = this.index, o = this._cachedMeta.vScale, s = o.getBasePixel(), l = o.isHorizontal(), h = this._getRuler(), u = this._getSharedOptions(e, n), c = u.sharedOptions, d = u.includeOptions, f = e; f < e + i; f++) { const v = this.getParsed(f); const g = a || T(v[o.axis]) ? { base: s, head: s } : this._calculateBarValuePixels(f); const p = this._calculateBarIndexPixels(f, h); const y = (v._stacks || {})[o.axis]; const m = { horizontal: l, base: g.base, enableBorderRadius: !y || ya(v._custom) || r === y._top || r === y._bottom, x: l ? g.head : p.center, y: l ? p.center : g.head, height: l ? p.size : Math.abs(g.size), width: l ? Math.abs(g.size) : p.size }; d && (m.options = c || this.resolveDataElementOptions(f, t[f].active ? 'active' : n)); const b = m.options || t[f].options; xa(m, b, y, r), Ma(m, b, h.ratio), this.updateElement(t[f], f, m, n) } } }, { key: '_getStacks', value: function (t, e) { let i; const n = this._cachedMeta.iScale; const a = n.getMatchingVisibleMetas(this._type).filter(function (t) { return t.controller.options.grouped }); const r = n.options.stacked; const o = []; const s = function (t) { const i = t.controller.getParsed(e); const n = i && i[t.vScale.axis]; if (T(n) || isNaN(n)) return !0 }; const l = (0, b.Z)(a); try { for (l.s(); !(i = l.n()).done;) { const h = i.value; if ((void 0 === e || !s(h)) && ((!1 === r || o.indexOf(h.stack) === -1 || void 0 === r && void 0 === h.stack) && o.push(h.stack), h.index === t)) break } } catch (u) { l.e(u) } finally { l.f() } return o.length || o.push(void 0), o } }, { key: '_getStackCount', value: function (t) { return this._getStacks(void 0, t).length } }, { key: '_getStackIndex', value: function (t, e, i) { const n = this._getStacks(t, i); const a = void 0 !== e ? n.indexOf(e) : -1; return a === -1 ? n.length - 1 : a } }, { key: '_getRuler', value: function () { let t; let e; const i = this.options; const n = this._cachedMeta; const a = n.iScale; const r = []; for (t = 0, e = n.data.length; t < e; ++t)r.push(a.getPixelForValue(this.getParsed(t)[a.axis], t)); const o = i.barThickness; const s = o || ca(n); return { min: s, pixels: r, start: a._startPixel, end: a._endPixel, stackCount: this._getStackCount(), scale: a, grouped: i.grouped, ratio: o ? 1 : i.categoryPercentage * i.barPercentage } } }, { key: '_calculateBarValuePixels', value: function (t) { let e; let i; const n = this._cachedMeta; const a = n.vScale; const r = n._stacked; const o = this.options; const s = o.base; const l = o.minBarLength; const h = s || 0; const u = this.getParsed(t); const c = u._custom; const d = ya(c); let f = u[a.axis]; let v = 0; let g = r ? this.applyStack(a, u, r) : f; g !== f && (v = g - f, g = f), d && (f = c.barStart, g = c.barEnd - c.barStart, f !== 0 && dt(f) !== dt(c.barEnd) && (v = 0), v += f); const p = T(s) || d ? v : s; let y = a.getPixelForValue(p); if (e = this.chart.getDataVisibility(t) ? a.getPixelForValue(v + g) : y, i = e - y, Math.abs(i) < l) { i = ma(i, a, h) * l, f === h && (y -= i / 2); const m = a.getPixelForDecimal(0); const b = a.getPixelForDecimal(1); const x = Math.min(m, b); const _ = Math.max(m, b); y = Math.max(Math.min(y, _), x), e = y + i } if (y === a.getPixelForValue(h)) { const k = dt(i) * a.getLineWidthForValue(h) / 2; y += k, i -= k } return { size: i, base: y, head: e, center: e + i / 2 } } }, { key: '_calculateBarIndexPixels', value: function (t, e) { let i; let n; const a = e.scale; const r = this.options; const o = r.skipNull; const s = Z(r.maxBarThickness, 1 / 0); if (e.grouped) { const l = o ? this._getStackCount(t) : e.stackCount; const h = r.barThickness === 'flex' ? fa(t, e, r, l) : da(t, e, r, l); const u = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0); i = h.start + h.chunk * u + h.chunk / 2, n = Math.min(s, h.chunk * h.ratio) } else i = a.getPixelForValue(this.getParsed(t)[a.axis], t), n = Math.min(s, e.min * e.ratio); return { base: i - n / 2, head: i + n / 2, center: i, size: n } } }, { key: 'draw', value: function () { for (let t = this._cachedMeta, e = t.vScale, i = t.data, n = i.length, a = 0; a < n; ++a) this.getParsed(a)[e.axis] !== null && i[a].draw(this._ctx) } }]), i }(ha)); Sa.id = 'bar', Sa.defaults = { datasetElementType: !1, dataElementType: 'bar', categoryPercentage: 0.8, barPercentage: 0.9, grouped: !0, animations: { numbers: { type: 'number', properties: ['x', 'y', 'base', 'width', 'height'] } } }, Sa.overrides = { scales: { _index_: { type: 'category', offset: !0, grid: { offset: !0 } }, _value_: { type: 'linear', beginAtZero: !0 } } }; const Pa = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'initialize', value: function () { this.enableOptionSharing = !0, (0, f.Z)((0, v.Z)(i.prototype), 'initialize', this).call(this) } }, { key: 'parsePrimitiveData', value: function (t, e, n, a) { for (var r = (0, f.Z)((0, v.Z)(i.prototype), 'parsePrimitiveData', this).call(this, t, e, n, a), o = 0; o < r.length; o++)r[o]._custom = this.resolveDataElementOptions(o + n).radius; return r } }, { key: 'parseArrayData', value: function (t, e, n, a) { for (var r = (0, f.Z)((0, v.Z)(i.prototype), 'parseArrayData', this).call(this, t, e, n, a), o = 0; o < r.length; o++) { const s = e[n + o]; r[o]._custom = Z(s[2], this.resolveDataElementOptions(o + n).radius) } return r } }, { key: 'parseObjectData', value: function (t, e, n, a) { for (var r = (0, f.Z)((0, v.Z)(i.prototype), 'parseObjectData', this).call(this, t, e, n, a), o = 0; o < r.length; o++) { const s = e[n + o]; r[o]._custom = Z(s && s.r && +s.r, this.resolveDataElementOptions(o + n).radius) } return r } }, { key: 'getMaxOverflow', value: function () { for (var t = this._cachedMeta.data, e = 0, i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2); return e > 0 && e } }, { key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta; const i = e.xScale; const n = e.yScale; const a = this.getParsed(t); const r = i.getLabelForValue(a.x); const o = n.getLabelForValue(a.y); const s = a._custom; return { label: e.label, value: '(' + r + ', ' + o + (s ? ', ' + s : '') + ')' } } }, { key: 'update', value: function (t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } }, { key: 'updateElements', value: function (t, e, i, n) { for (let a = n === 'reset', r = this._cachedMeta, o = r.iScale, s = r.vScale, l = this._getSharedOptions(e, n), h = l.sharedOptions, u = l.includeOptions, c = o.axis, d = s.axis, f = e; f < e + i; f++) { const v = t[f]; const g = !a && this.getParsed(f); const p = {}; const y = p[c] = a ? o.getPixelForDecimal(0.5) : o.getPixelForValue(g[c]); const m = p[d] = a ? s.getBasePixel() : s.getPixelForValue(g[d]); p.skip = isNaN(y) || isNaN(m), u && (p.options = h || this.resolveDataElementOptions(f, v.active ? 'active' : n), a && (p.options.radius = 0)), this.updateElement(v, f, p, n) } } }, { key: 'resolveDataElementOptions', value: function (t, e) { const n = this.getParsed(t); let a = (0, f.Z)((0, v.Z)(i.prototype), 'resolveDataElementOptions', this).call(this, t, e); a.$shared && (a = Object.assign({}, a, { $shared: !1 })); const r = a.radius; return e !== 'active' && (a.radius = 0), a.radius += Z(n && n._custom, r), a } }]), i }(ha)); function Ca (t, e, i) { let n = 1; let a = 1; let r = 0; let o = 0; if (e < at) { const s = t; const l = s + e; const h = Math.cos(s); const u = Math.sin(s); const c = Math.cos(l); const d = Math.sin(l); const f = function (t, e, n) { return Pt(t, s, l, !0) ? 1 : Math.max(e, e * i, n, n * i) }; const v = function (t, e, n) { return Pt(t, s, l, !0) ? -1 : Math.min(e, e * i, n, n * i) }; const g = f(0, h, c); const p = f(lt, u, d); const y = v(nt, h, c); const m = v(nt + lt, u, d); n = (g - y) / 2, a = (p - m) / 2, r = -(g + y) / 2, o = -(p + m) / 2 } return { ratioX: n, ratioY: a, offsetX: r, offsetY: o } }Pa.id = 'bubble', Pa.defaults = { datasetElementType: !1, dataElementType: 'point', animations: { numbers: { type: 'number', properties: ['x', 'y', 'borderWidth', 'radius'] } } }, Pa.overrides = { scales: { x: { type: 'linear' }, y: { type: 'linear' } }, plugins: { tooltip: { callbacks: { title: function () { return '' } } } } }; const Da = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t, n) { let a; return (0, _.Z)(this, i), a = e.call(this, t, n), a.enableOptionSharing = !0, a.innerRadius = void 0, a.outerRadius = void 0, a.offsetX = void 0, a.offsetY = void 0, a } return (0, k.Z)(i, [{ key: 'linkScales', value: function () {} }, { key: 'parse', value: function (t, e) { const i = this.getDataset().data; const n = this._cachedMeta; if (!1 === this._parsing)n._parsed = i; else { let a; let r; let o = function (t) { return +i[t] }; if (R(i[t])) { const s = this._parsing.key; const l = void 0 === s ? 'value' : s; o = function (t) { return +G(i[t], l) } } for (a = t, r = t + e; a < r; ++a)n._parsed[a] = o(a) } } }, { key: '_getRotation', value: function () { return bt(this.options.rotation - 90) } }, { key: '_getCircumference', value: function () { return bt(this.options.circumference) } }, { key: '_getRotationExtents', value: function () { for (var t = at, e = -at, i = 0; i < this.chart.data.datasets.length; ++i) if (this.chart.isDatasetVisible(i)) { const n = this.chart.getDatasetMeta(i).controller; const a = n._getRotation(); const r = n._getCircumference(); t = Math.min(t, a), e = Math.max(e, a + r) } return { rotation: t, circumference: e - t } } }, { key: 'update', value: function (t) { const e = this.chart; const i = e.chartArea; const n = this._cachedMeta; const a = n.data; const r = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing; const o = Math.max((Math.min(i.width, i.height) - r) / 2, 0); const s = Math.min(z(this.options.cutout, o), 1); const l = this._getRingWeight(this.index); const h = this._getRotationExtents(); const u = h.circumference; const c = h.rotation; const d = Ca(c, u, s); const f = d.ratioX; const v = d.ratioY; const g = d.offsetX; const p = d.offsetY; const y = (i.width - r) / f; const m = (i.height - r) / v; const b = Math.max(Math.min(y, m) / 2, 0); const x = F(this.options.radius, b); const _ = Math.max(x * s, 0); const k = (x - _) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * x, this.offsetY = p * x, n.total = this.calculateTotal(), this.outerRadius = x - k * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - k * l, 0), this.updateElements(a, 0, a.length, t) } }, { key: '_circumference', value: function (t, e) { const i = this.options; const n = this._cachedMeta; const a = this._getCircumference(); return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * a / at) } }, { key: 'updateElements', value: function (t, e, i, n) { let a; const r = n === 'reset'; const o = this.chart; const s = o.chartArea; const l = o.options; const h = l.animation; const u = (s.left + s.right) / 2; const c = (s.top + s.bottom) / 2; const d = r && h.animateScale; const f = d ? 0 : this.innerRadius; const v = d ? 0 : this.outerRadius; const g = this._getSharedOptions(e, n); const p = g.sharedOptions; const y = g.includeOptions; let m = this._getRotation(); for (a = 0; a < e; ++a)m += this._circumference(a, r); for (a = e; a < e + i; ++a) { const b = this._circumference(a, r); const x = t[a]; const _ = { x: u + this.offsetX, y: c + this.offsetY, startAngle: m, endAngle: m + b, circumference: b, outerRadius: v, innerRadius: f }; y && (_.options = p || this.resolveDataElementOptions(a, x.active ? 'active' : n)), m += b, this.updateElement(x, a, _, n) } } }, { key: 'calculateTotal', value: function () { let t; const e = this._cachedMeta; const i = e.data; let n = 0; for (t = 0; t < i.length; t++) { const a = e._parsed[t]; a === null || isNaN(a) || !this.chart.getDataVisibility(t) || i[t].hidden || (n += Math.abs(a)) } return n } }, { key: 'calculateCircumference', value: function (t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? at * (Math.abs(t) / e) : 0 } }, { key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta; const i = this.chart; const n = i.data.labels || []; const a = gn(e._parsed[t], i.options.locale); return { label: n[t] || '', value: a } } }, { key: 'getMaxBorderWidth', value: function (t) { let e; let i; let n; let a; let r; let o = 0; const s = this.chart; if (!t) for (e = 0, i = s.data.datasets.length; e < i; ++e) if (s.isDatasetVisible(e)) { n = s.getDatasetMeta(e), t = n.data, a = n.controller; break } if (!t) return 0; for (e = 0, i = t.length; e < i; ++e)r = a.resolveDataElementOptions(e), r.borderAlign !== 'inner' && (o = Math.max(o, r.borderWidth || 0, r.hoverBorderWidth || 0)); return o } }, { key: 'getMaxOffset', value: function (t) { for (var e = 0, i = 0, n = t.length; i < n; ++i) { const a = this.resolveDataElementOptions(i); e = Math.max(e, a.offset || 0, a.hoverOffset || 0) } return e } }, { key: '_getRingWeightOffset', value: function (t) { for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i)); return e } }, { key: '_getRingWeight', value: function (t) { return Math.max(Z(this.chart.data.datasets[t].weight, 1), 0) } }, { key: '_getVisibleDatasetWeightTotal', value: function () { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } }]), i }(ha)); Da.id = 'doughnut', Da.defaults = { datasetElementType: !1, dataElementType: 'arc', animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: 'number', properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing'] } }, cutout: '50%', rotation: 0, circumference: 360, radius: '100%', spacing: 0, indexAxis: 'r' }, Da.descriptors = { _scriptable: function (t) { return t !== 'spacing' }, _indexable: function (t) { return t !== 'spacing' } }, Da.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels: function (t) { const e = t.data; if (e.labels.length && e.datasets.length) { const i = t.legend.options.labels.pointStyle; return e.labels.map(function (e, n) { const a = t.getDatasetMeta(0); const r = a.controller.getStyle(n); return { text: e, fillStyle: r.backgroundColor, strokeStyle: r.borderColor, lineWidth: r.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(n), index: n } }) } return [] } }, onClick: function (t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: function () { return '' }, label: function (t) { let e = t.label; const i = ': ' + t.formattedValue; return L(e) ? (e = e.slice(), e[0] += i) : e += i, e } } } } }; const Oa = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'initialize', value: function () { this.enableOptionSharing = !0, this.supportsDecimation = !0, (0, f.Z)((0, v.Z)(i.prototype), 'initialize', this).call(this) } }, { key: 'update', value: function (t) { const e = this._cachedMeta; const i = e.dataset; const n = e.data; const a = void 0 === n ? [] : n; const r = e._dataset; const o = this.chart._animationsDisabled; const s = Aa(e, a, o); let l = s.start; let h = s.count; this._drawStart = l, this._drawCount = h, Ta(e) && (l = 0, h = a.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!r._decimated, i.points = a; const u = this.resolveDatasetElementOptions(t); this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(i, void 0, { animated: !o, options: u }, t), this.updateElements(a, l, h, t) } }, { key: 'updateElements', value: function (t, e, i, n) { for (let a = n === 'reset', r = this._cachedMeta, o = r.iScale, s = r.vScale, l = r._stacked, h = r._dataset, u = this._getSharedOptions(e, n), c = u.sharedOptions, d = u.includeOptions, f = o.axis, v = s.axis, g = this.options, p = g.spanGaps, y = g.segment, m = gt(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || a || n === 'none', x = e > 0 && this.getParsed(e - 1), _ = e; _ < e + i; ++_) { const k = t[_]; const w = this.getParsed(_); const M = b ? k : {}; const S = T(w[v]); const P = M[f] = o.getPixelForValue(w[f], _); const C = M[v] = a || S ? s.getBasePixel() : s.getPixelForValue(l ? this.applyStack(s, w, l) : w[v], _); M.skip = isNaN(P) || isNaN(C) || S, M.stop = _ > 0 && Math.abs(w[f] - x[f]) > m, y && (M.parsed = w, M.raw = h.data[_]), d && (M.options = c || this.resolveDataElementOptions(_, k.active ? 'active' : n)), b || this.updateElement(k, _, M, n), x = w } } }, { key: 'getMaxOverflow', value: function () { const t = this._cachedMeta; const e = t.dataset; const i = e.options && e.options.borderWidth || 0; const n = t.data || []; if (!n.length) return i; const a = n[0].size(this.resolveDataElementOptions(0)); const r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1)); return Math.max(i, a, r) / 2 } }, { key: 'draw', value: function () { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), (0, f.Z)((0, v.Z)(i.prototype), 'draw', this).call(this) } }]), i }(ha)); function Aa (t, e, i) { const n = e.length; let a = 0; let r = n; if (t._sorted) { const o = t.iScale; const s = t._parsed; const l = o.axis; const h = o.getUserBounds(); const u = h.min; const c = h.max; const d = h.minDefined; const f = h.maxDefined; d && (a = Ct(Math.min(ui(s, o.axis, u).lo, i ? n : ui(e, l, o.getPixelForValue(u)).lo), 0, n - 1)), r = f ? Ct(Math.max(ui(s, o.axis, c).hi + 1, i ? 0 : ui(e, l, o.getPixelForValue(c)).hi + 1), a, n) - a : n - a } return { start: a, count: r } } function Ta (t) { const e = t.xScale; const i = t.yScale; const n = t._scaleRanges; const a = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; if (!n) return t._scaleRanges = a, !0; const r = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max; return Object.assign(n, a), r }Oa.id = 'line', Oa.defaults = { datasetElementType: 'line', dataElementType: 'point', showLine: !0, spanGaps: !1 }, Oa.overrides = { scales: { _index_: { type: 'category' }, _value_: { type: 'linear' } } }; const La = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t, n) { let a; return (0, _.Z)(this, i), a = e.call(this, t, n), a.innerRadius = void 0, a.outerRadius = void 0, a } return (0, k.Z)(i, [{ key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta; const i = this.chart; const n = i.data.labels || []; const a = gn(e._parsed[t].r, i.options.locale); return { label: n[t] || '', value: a } } }, { key: 'parseObjectData', value: function (t, e, i, n) { return Zi.bind(this)(t, e, i, n) } }, { key: 'update', value: function (t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } }, { key: 'getMinMax', value: function () { const t = this; const e = this._cachedMeta; const i = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return e.data.forEach(function (e, n) { const a = t.getParsed(n).r; !isNaN(a) && t.chart.getDataVisibility(n) && (a < i.min && (i.min = a), a > i.max && (i.max = a)) }), i } }, { key: '_updateRadius', value: function () { const t = this.chart; const e = t.chartArea; const i = t.options; const n = Math.min(e.right - e.left, e.bottom - e.top); const a = Math.max(n / 2, 0); const r = Math.max(i.cutoutPercentage ? a / 100 * i.cutoutPercentage : 1, 0); const o = (a - r) / t.getVisibleDatasetCount(); this.outerRadius = a - o * this.index, this.innerRadius = this.outerRadius - o } }, { key: 'updateElements', value: function (t, e, i, n) { let a; const r = n === 'reset'; const o = this.chart; const s = o.options; const l = s.animation; const h = this._cachedMeta.rScale; const u = h.xCenter; const c = h.yCenter; const d = h.getIndexAngle(0) - 0.5 * nt; let f = d; const v = 360 / this.countVisibleElements(); for (a = 0; a < e; ++a)f += this._computeAngle(a, n, v); for (a = e; a < e + i; a++) { const g = t[a]; let p = f; let y = f + this._computeAngle(a, n, v); let m = o.getDataVisibility(a) ? h.getDistanceFromCenterForValue(this.getParsed(a).r) : 0; f = y, r && (l.animateScale && (m = 0), l.animateRotate && (p = y = d)); const b = { x: u, y: c, innerRadius: 0, outerRadius: m, startAngle: p, endAngle: y, options: this.resolveDataElementOptions(a, g.active ? 'active' : n) }; this.updateElement(g, a, b, n) } } }, { key: 'countVisibleElements', value: function () { const t = this; const e = this._cachedMeta; let i = 0; return e.data.forEach(function (e, n) { !isNaN(t.getParsed(n).r) && t.chart.getDataVisibility(n) && i++ }), i } }, { key: '_computeAngle', value: function (t, e, i) { return this.chart.getDataVisibility(t) ? bt(this.resolveDataElementOptions(t, e).angle || i) : 0 } }]), i }(ha)); La.id = 'polarArea', La.defaults = { dataElementType: 'arc', animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: 'number', properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius'] } }, indexAxis: 'r', startAngle: 0 }, La.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels: function (t) { const e = t.data; if (e.labels.length && e.datasets.length) { const i = t.legend.options.labels.pointStyle; return e.labels.map(function (e, n) { const a = t.getDatasetMeta(0); const r = a.controller.getStyle(n); return { text: e, fillStyle: r.backgroundColor, strokeStyle: r.borderColor, lineWidth: r.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(n), index: n } }) } return [] } }, onClick: function (t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: function () { return '' }, label: function (t) { return t.chart.data.labels[t.dataIndex] + ': ' + t.formattedValue } } } }, scales: { r: { type: 'radialLinear', angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }; const Ra = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i) }(Da)); Ra.id = 'pie', Ra.defaults = { cutout: 0, rotation: 0, circumference: 360, radius: '100%' }; const Ea = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'getLabelAndValue', value: function (t) { const e = this._cachedMeta.vScale; const i = this.getParsed(t); return { label: e.getLabels()[t], value: '' + e.getLabelForValue(i[e.axis]) } } }, { key: 'parseObjectData', value: function (t, e, i, n) { return Zi.bind(this)(t, e, i, n) } }, { key: 'update', value: function (t) { const e = this._cachedMeta; const i = e.dataset; const n = e.data || []; const a = e.iScale.getLabels(); if (i.points = n, t !== 'resize') { const r = this.resolveDatasetElementOptions(t); this.options.showLine || (r.borderWidth = 0); const o = { _loop: !0, _fullLoop: a.length === n.length, options: r }; this.updateElement(i, void 0, o, t) } this.updateElements(n, 0, n.length, t) } }, { key: 'updateElements', value: function (t, e, i, n) { for (let a = this._cachedMeta.rScale, r = n === 'reset', o = e; o < e + i; o++) { const s = t[o]; const l = this.resolveDataElementOptions(o, s.active ? 'active' : n); const h = a.getPointPositionForValue(o, this.getParsed(o).r); const u = r ? a.xCenter : h.x; const c = r ? a.yCenter : h.y; const d = { x: u, y: c, angle: h.angle, skip: isNaN(u) || isNaN(c), options: l }; this.updateElement(s, o, d, n) } } }]), i }(ha)); Ea.id = 'radar', Ea.defaults = { datasetElementType: 'line', dataElementType: 'point', indexAxis: 'r', showLine: !0, elements: { line: { fill: 'start' } } }, Ea.overrides = { aspectRatio: 1, scales: { r: { type: 'radialLinear' } } }; const Ia = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i) }(Oa)); Ia.id = 'scatter', Ia.defaults = { showLine: !1, fill: !1 }, Ia.overrides = { interaction: { mode: 'point' }, plugins: { tooltip: { callbacks: { title: function () { return '' }, label: function (t) { return '(' + t.label + ', ' + t.formattedValue + ')' } } } }, scales: { x: { type: 'linear' }, y: { type: 'linear' } } }; function Za () { throw new Error('This method is not implemented: Check that a complete date adapter is provided.') } const za = (function () { function t (e) { (0, _.Z)(this, t), this.options = e || {} } return (0, k.Z)(t, [{ key: 'formats', value: function () { return Za() } }, { key: 'parse', value: function (t, e) { return Za() } }, { key: 'format', value: function (t, e) { return Za() } }, { key: 'add', value: function (t, e, i) { return Za() } }, { key: 'diff', value: function (t, e, i) { return Za() } }, { key: 'startOf', value: function (t, e, i) { return Za() } }, { key: 'endOf', value: function (t, e) { return Za() } }]), t }()); za.override = function (t) { Object.assign(za.prototype, t) }; const Fa = { _date: za }; function Ba (t, e, i, n) { const a = t.controller; const r = t.data; const o = t._sorted; const s = a._cachedMeta.iScale; if (s && e === s.axis && e !== 'r' && o && r.length) { const l = s._reversePixels ? ci : ui; if (!n) return l(r, e, i); if (a._sharedOptions) { const h = r[0]; const u = typeof h.getRange === 'function' && h.getRange(e); if (u) { const c = l(r, e, i - u); const d = l(r, e, i + u); return { lo: c.lo, hi: d.hi } } } } return { lo: 0, hi: r.length - 1 } } function Va (t, e, i, n, a) { for (let r = t.getSortedVisibleDatasetMetas(), o = i[e], s = 0, l = r.length; s < l; ++s) for (let h = r[s], u = h.index, c = h.data, d = Ba(r[s], e, o, a), f = d.lo, v = d.hi, g = f; g <= v; ++g) { const p = c[g]; p.skip || n(p, u, g) } } function Wa (t) { const e = t.indexOf('x') !== -1; const i = t.indexOf('y') !== -1; return function (t, n) { const a = e ? Math.abs(t.x - n.x) : 0; const r = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(a, 2) + Math.pow(r, 2)) } } function Na (t, e, i, n, a) { const r = []; if (!a && !t.isPointInArea(e)) return r; const o = function (i, o, s) { (a || Ne(i, t.chartArea, 0)) && i.inRange(e.x, e.y, n) && r.push({ element: i, datasetIndex: o, index: s }) }; return Va(t, i, e, o, !0), r } function Ha (t, e, i, n) { const a = []; function r (t, i, r) { const o = t.getProps(['startAngle', 'endAngle'], n); const s = o.startAngle; const l = o.endAngle; const h = kt(t, { x: e.x, y: e.y }); const u = h.angle; Pt(u, s, l) && a.push({ element: t, datasetIndex: i, index: r }) } return Va(t, i, e, r), a } function ja (t, e, i, n, a, r) { let o = []; const s = Wa(i); let l = Number.POSITIVE_INFINITY; function h (i, h, u) { const c = i.inRange(e.x, e.y, a); if (!n || c) { const d = i.getCenterPoint(a); const f = !!r || t.isPointInArea(d); if (f || c) { const v = s(e, d); v < l ? (o = [{ element: i, datasetIndex: h, index: u }], l = v) : v === l && o.push({ element: i, datasetIndex: h, index: u }) } } } return Va(t, i, e, h), o } function $a (t, e, i, n, a, r) { return r || t.isPointInArea(e) ? i !== 'r' || n ? ja(t, e, i, n, a, r) : Ha(t, e, i, a) : [] } function Ya (t, e, i, n, a) { const r = []; const o = i === 'x' ? 'inXRange' : 'inYRange'; let s = !1; return Va(t, i, e, function (t, n, l) { t[o](e[i], a) && (r.push({ element: t, datasetIndex: n, index: l }), s = s || t.inRange(e.x, e.y, a)) }), n && !s ? [] : r } const Ua = { evaluateInteractionItems: Va, modes: { index: function (t, e, i, n) { const a = nn(e, t); const r = i.axis || 'x'; const o = i.includeInvisible || !1; const s = i.intersect ? Na(t, a, r, n, o) : $a(t, a, r, !1, n, o); const l = []; return s.length ? (t.getSortedVisibleDatasetMetas().forEach(function (t) { const e = s[0].index; const i = t.data[e]; i && !i.skip && l.push({ element: i, datasetIndex: t.index, index: e }) }), l) : [] }, dataset: function (t, e, i, n) { const a = nn(e, t); const r = i.axis || 'xy'; const o = i.includeInvisible || !1; let s = i.intersect ? Na(t, a, r, n, o) : $a(t, a, r, !1, n, o); if (s.length > 0) { const l = s[0].datasetIndex; const h = t.getDatasetMeta(l).data; s = []; for (let u = 0; u < h.length; ++u)s.push({ element: h[u], datasetIndex: l, index: u }) } return s }, point: function (t, e, i, n) { const a = nn(e, t); const r = i.axis || 'xy'; const o = i.includeInvisible || !1; return Na(t, a, r, n, o) }, nearest: function (t, e, i, n) { const a = nn(e, t); const r = i.axis || 'xy'; const o = i.includeInvisible || !1; return $a(t, a, r, i.intersect, n, o) }, x: function (t, e, i, n) { const a = nn(e, t); return Ya(t, a, 'x', i.intersect, n) }, y: function (t, e, i, n) { const a = nn(e, t); return Ya(t, a, 'y', i.intersect, n) } } }; const Xa = ['left', 'top', 'right', 'bottom']; function qa (t, e) { return t.filter(function (t) { return t.pos === e }) } function Ka (t, e) { return t.filter(function (t) { return Xa.indexOf(t.pos) === -1 && t.box.axis === e }) } function Ga (t, e) { return t.sort(function (t, i) { const n = e ? i : t; const a = e ? t : i; return n.weight === a.weight ? n.index - a.index : n.weight - a.weight }) } function Ja (t) { let e; let i; let n; let a; let r; let o; const s = []; for (e = 0, i = (t || []).length; e < i; ++e) { n = t[e]; const l = n; a = l.position; const h = l.options; r = h.stack; const u = h.stackWeight; o = void 0 === u ? 1 : u, s.push({ index: e, box: n, pos: a, horizontal: n.isHorizontal(), weight: n.weight, stack: r && a + r, stackWeight: o }) } return s } function Qa (t) { let e; const i = {}; const n = (0, b.Z)(t); try { for (n.s(); !(e = n.n()).done;) { const a = e.value; const r = a.stack; const o = a.pos; const s = a.stackWeight; if (r && Xa.includes(o)) { const l = i[r] || (i[r] = { count: 0, placed: 0, weight: 0, size: 0 }); l.count++, l.weight += s } } } catch (h) { n.e(h) } finally { n.f() } return i } function tr (t, e) { let i; let n; let a; const r = Qa(t); const o = e.vBoxMaxWidth; const s = e.hBoxMaxHeight; for (i = 0, n = t.length; i < n; ++i) { a = t[i]; const l = a.box.fullSize; const h = r[a.stack]; const u = h && a.stackWeight / h.weight; a.horizontal ? (a.width = u ? u * o : l && e.availableWidth, a.height = s) : (a.width = o, a.height = u ? u * s : l && e.availableHeight) } return r } function er (t) { const e = Ja(t); const i = Ga(e.filter(function (t) { return t.box.fullSize }), !0); const n = Ga(qa(e, 'left'), !0); const a = Ga(qa(e, 'right')); const r = Ga(qa(e, 'top'), !0); const o = Ga(qa(e, 'bottom')); const s = Ka(e, 'x'); const l = Ka(e, 'y'); return { fullSize: i, leftAndTop: n.concat(r), rightAndBottom: a.concat(l).concat(o).concat(s), chartArea: qa(e, 'chartArea'), vertical: n.concat(a).concat(l), horizontal: r.concat(o).concat(s) } } function ir (t, e, i, n) { return Math.max(t[i], e[i]) + Math.max(t[n], e[n]) } function nr (t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function ar (t, e, i, n) { const a = i.pos; const r = i.box; const o = t.maxPadding; if (!R(a)) { i.size && (t[a] -= i.size); const s = n[i.stack] || { size: 0, count: 1 }; s.size = Math.max(s.size, i.horizontal ? r.height : r.width), i.size = s.size / s.count, t[a] += i.size }r.getPadding && nr(o, r.getPadding()); const l = Math.max(0, e.outerWidth - ir(o, t, 'left', 'right')); const h = Math.max(0, e.outerHeight - ir(o, t, 'top', 'bottom')); const u = l !== t.w; const c = h !== t.h; return t.w = l, t.h = h, i.horizontal ? { same: u, other: c } : { same: c, other: u } } function rr (t) { const e = t.maxPadding; function i (i) { const n = Math.max(e[i] - t[i], 0); return t[i] += n, n }t.y += i('top'), t.x += i('left'), i('right'), i('bottom') } function or (t, e) { const i = e.maxPadding; function n (t) { const n = { left: 0, top: 0, right: 0, bottom: 0 }; return t.forEach(function (t) { n[t] = Math.max(e[t], i[t]) }), n } return n(t ? ['left', 'right'] : ['top', 'bottom']) } function sr (t, e, i, n) { let a; let r; let o; let s; let l; let h; const u = []; for (a = 0, r = t.length, l = 0; a < r; ++a) { o = t[a], s = o.box, s.update(o.width || e.w, o.height || e.h, or(o.horizontal, e)); const c = ar(e, i, o, n); const d = c.same; const f = c.other; l |= d && u.length, h = h || f, s.fullSize || u.push(o) } return l && sr(u, e, i, n) || h } function lr (t, e, i, n, a) { t.top = i, t.left = e, t.right = e + n, t.bottom = i + a, t.width = n, t.height = a } function hr (t, e, i, n) { let a; const r = i.padding; let o = e.x; let s = e.y; const l = (0, b.Z)(t); try { for (l.s(); !(a = l.n()).done;) { const h = a.value; const u = h.box; const c = n[h.stack] || { count: 1, placed: 0, weight: 1 }; const d = h.stackWeight / c.weight || 1; if (h.horizontal) { const f = e.w * d; const v = c.size || u.height; Q(c.start) && (s = c.start), u.fullSize ? lr(u, r.left, s, i.outerWidth - r.right - r.left, v) : lr(u, e.left + c.placed, s, f, v), c.start = s, c.placed += f, s = u.bottom } else { const g = e.h * d; const p = c.size || u.width; Q(c.start) && (o = c.start), u.fullSize ? lr(u, o, r.top, p, i.outerHeight - r.bottom - r.top) : lr(u, o, e.top + c.placed, p, g), c.start = o, c.placed += g, o = u.right } } } catch (y) { l.e(y) } finally { l.f() }e.x = o, e.y = s }Ee.set('layout', { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }); const ur = { addBox: function (t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || 'top', e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw: function (t) { e.draw(t) } }] }, t.boxes.push(e) }, removeBox: function (t, e) { const i = t.boxes ? t.boxes.indexOf(e) : -1; i !== -1 && t.boxes.splice(i, 1) }, configure: function (t, e, i) { e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight }, update: function (t, e, i, n) { if (t) { const a = ai(t.options.layout.padding); const r = Math.max(e - a.width, 0); const o = Math.max(i - a.height, 0); const s = er(t.boxes); const l = s.vertical; const h = s.horizontal; V(t.boxes, function (t) { typeof t.beforeLayout === 'function' && t.beforeLayout() }); const u = l.reduce(function (t, e) { return e.box.options && !1 === e.box.options.display ? t : t + 1 }, 0) || 1; const c = Object.freeze({ outerWidth: e, outerHeight: i, padding: a, availableWidth: r, availableHeight: o, vBoxMaxWidth: r / 2 / u, hBoxMaxHeight: o / 2 }); const d = Object.assign({}, a); nr(d, ai(n)); const f = Object.assign({ maxPadding: d, w: r, h: o, x: a.left, y: a.top }, a); const v = tr(l.concat(h), c); sr(s.fullSize, f, c, v), sr(l, f, c, v), sr(h, f, c, v) && sr(l, f, c, v), rr(f), hr(s.leftAndTop, f, c, v), f.x += f.w, f.y += f.h, hr(s.rightAndBottom, f, c, v), t.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, V(s.chartArea, function (e) { const i = e.box; Object.assign(i, t.chartArea), i.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } } }; const cr = (function () { function t () { (0, _.Z)(this, t) } return (0, k.Z)(t, [{ key: 'acquireContext', value: function (t, e) {} }, { key: 'releaseContext', value: function (t) { return !1 } }, { key: 'addEventListener', value: function (t, e, i) {} }, { key: 'removeEventListener', value: function (t, e, i) {} }, { key: 'getDevicePixelRatio', value: function () { return 1 } }, { key: 'getMaximumSize', value: function (t, e, i, n) { return e = Math.max(0, e || t.width), i = i || t.height, { width: e, height: Math.max(0, n ? Math.floor(e / n) : i) } } }, { key: 'isAttached', value: function (t) { return !0 } }, { key: 'updateConfig', value: function (t) {} }]), t }()); const dr = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'acquireContext', value: function (t) { return t && t.getContext && t.getContext('2d') || null } }, { key: 'updateConfig', value: function (t) { t.options.animation = !1 } }]), i }(cr)); const fr = '$chartjs'; const vr = { touchstart: 'mousedown', touchmove: 'mousemove', touchend: 'mouseup', pointerenter: 'mouseenter', pointerdown: 'mousedown', pointermove: 'mousemove', pointerup: 'mouseup', pointerleave: 'mouseout', pointerout: 'mouseout' }; const gr = function (t) { return t === null || t === '' }; function pr (t, e) { const i = t.style; const n = t.getAttribute('height'); const a = t.getAttribute('width'); if (t[fr] = { initial: { height: n, width: a, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || 'block', i.boxSizing = i.boxSizing || 'border-box', gr(a)) { const r = hn(t, 'width'); void 0 !== r && (t.width = r) } if (gr(n)) if (t.style.height === '')t.height = t.width / (e || 2); else { const o = hn(t, 'height'); void 0 !== o && (t.height = o) } return t } const yr = !!ln && { passive: !0 }; function mr (t, e, i) { t.addEventListener(e, i, yr) } function br (t, e, i) { t.canvas.removeEventListener(e, i, yr) } function xr (t, e) { const i = vr[t.type] || t.type; const n = nn(t, e); const a = n.x; const r = n.y; return { type: i, chart: e, native: t, x: void 0 !== a ? a : null, y: void 0 !== r ? r : null } } function _r (t, e) { let i; const n = (0, b.Z)(t); try { for (n.s(); !(i = n.n()).done;) { const a = i.value; if (a === e || a.contains(e)) return !0 } } catch (r) { n.e(r) } finally { n.f() } } function kr (t, e, i) { const n = t.canvas; const a = new MutationObserver(function (t) { let e; let a = !1; const r = (0, b.Z)(t); try { for (r.s(); !(e = r.n()).done;) { const o = e.value; a = a || _r(o.addedNodes, n), a = a && !_r(o.removedNodes, n) } } catch (s) { r.e(s) } finally { r.f() }a && i() }); return a.observe(document, { childList: !0, subtree: !0 }), a } function wr (t, e, i) { const n = t.canvas; const a = new MutationObserver(function (t) { let e; let a = !1; const r = (0, b.Z)(t); try { for (r.s(); !(e = r.n()).done;) { const o = e.value; a = a || _r(o.removedNodes, n), a = a && !_r(o.addedNodes, n) } } catch (s) { r.e(s) } finally { r.f() }a && i() }); return a.observe(document, { childList: !0, subtree: !0 }), a } const Mr = new Map(); let Sr = 0; function Pr () { const t = window.devicePixelRatio; t !== Sr && (Sr = t, Mr.forEach(function (e, i) { i.currentDevicePixelRatio !== t && e() })) } function Cr (t, e) { Mr.size || window.addEventListener('resize', Pr), Mr.set(t, e) } function Dr (t) { Mr.delete(t), Mr.size || window.removeEventListener('resize', Pr) } function Or (t, e, i) { const n = t.canvas; const a = n && Xi(n); if (a) { const r = M(function (t, e) { const n = a.clientWidth; i(t, e), n < a.clientWidth && i() }, window); const o = new ResizeObserver(function (t) { const e = t[0]; const i = e.contentRect.width; const n = e.contentRect.height; i === 0 && n === 0 || r(i, n) }); return o.observe(a), Cr(t, r), o } } function Ar (t, e, i) { i && i.disconnect(), e === 'resize' && Dr(t) } function Tr (t, e, i) { const n = t.canvas; const a = M(function (e) { t.ctx !== null && i(xr(e, t)) }, t, function (t) { const e = t[0]; return [e, e.offsetX, e.offsetY] }); return mr(n, e, a), a } const Lr = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'acquireContext', value: function (t, e) { const i = t && t.getContext && t.getContext('2d'); return i && i.canvas === t ? (pr(t, e), i) : null } }, { key: 'releaseContext', value: function (t) { const e = t.canvas; if (!e[fr]) return !1; const i = e[fr].initial; ['height', 'width'].forEach(function (t) { const n = i[t]; T(n) ? e.removeAttribute(t) : e.setAttribute(t, n) }); const n = i.style || {}; return Object.keys(n).forEach(function (t) { e.style[t] = n[t] }), e.width = e.width, delete e[fr], !0 } }, { key: 'addEventListener', value: function (t, e, i) { this.removeEventListener(t, e); const n = t.$proxies || (t.$proxies = {}); const a = { attach: kr, detach: wr, resize: Or }; const r = a[e] || Tr; n[e] = r(t, e, i) } }, { key: 'removeEventListener', value: function (t, e) { const i = t.$proxies || (t.$proxies = {}); const n = i[e]; if (n) { const a = { attach: Ar, detach: Ar, resize: Ar }; const r = a[e] || br; r(t, e, n), i[e] = void 0 } } }, { key: 'getDevicePixelRatio', value: function () { return window.devicePixelRatio } }, { key: 'getMaximumSize', value: function (t, e, i, n) { return on(t, e, i, n) } }, { key: 'isAttached', value: function (t) { const e = Xi(t); return !(!e || !e.isConnected) } }]), i }(cr)); function Rr (t) { return !Ui() || typeof OffscreenCanvas !== 'undefined' && t instanceof OffscreenCanvas ? dr : Lr } const Er = (function () { function t () { (0, _.Z)(this, t), this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0 } return (0, k.Z)(t, [{ key: 'tooltipPosition', value: function (t) { const e = this.getProps(['x', 'y'], t); const i = e.x; const n = e.y; return { x: i, y: n } } }, { key: 'hasValue', value: function () { return gt(this.x) && gt(this.y) } }, { key: 'getProps', value: function (t, e) { const i = this; const n = this.$animations; if (!e || !n) return this; const a = {}; return t.forEach(function (t) { a[t] = n[t] && n[t].active() ? n[t]._to : i[t] }), a } }]), t }()); Er.defaults = {}, Er.defaultRoutes = void 0; var Ir = { values: function (t) { return L(t) ? t : '' + t }, numeric: function (t, e, i) { if (t === 0) return '0'; let n; const a = this.chart.options.locale; let r = t; if (i.length > 1) { const o = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value)); (o < 1e-4 || o > 1e15) && (n = 'scientific'), r = Zr(t, i) } const s = ct(Math.abs(r)); const l = Math.max(Math.min(-1 * Math.floor(s), 20), 0); const h = { notation: n, minimumFractionDigits: l, maximumFractionDigits: l }; return Object.assign(h, this.options.ticks.format), gn(t, a, h) }, logarithmic: function (t, e, i) { if (t === 0) return '0'; const n = t / Math.pow(10, Math.floor(ct(t))); return n === 1 || n === 2 || n === 5 ? Ir.numeric.call(this, t, e, i) : '' } }; function Zr (t, e) { let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t)), i } const zr = { formatters: Ir }; function Fr (t, e) { const i = t.options.ticks; const n = i.maxTicksLimit || Br(t); const a = i.major.enabled ? Wr(e) : []; const r = a.length; const o = a[0]; const s = a[r - 1]; const l = []; if (r > n) return Nr(e, l, a, r / n), l; const h = Vr(a, e, n); if (r > 0) { let u; let c; const d = r > 1 ? Math.round((s - o) / (r - 1)) : null; for (Hr(e, l, h, T(d) ? 0 : o - d, o), u = 0, c = r - 1; u < c; u++)Hr(e, l, h, a[u], a[u + 1]); return Hr(e, l, h, s, T(d) ? e.length : s + d), l } return Hr(e, l, h), l } function Br (t) { const e = t.options.offset; const i = t._tickSize(); const n = t._length / i + (e ? 0 : 1); const a = t._maxLength / i; return Math.floor(Math.min(n, a)) } function Vr (t, e, i) { const n = jr(t); const a = e.length / i; if (!n) return Math.max(a, 1); for (let r = vt(n), o = 0, s = r.length - 1; o < s; o++) { const l = r[o]; if (l > a) return l } return Math.max(a, 1) } function Wr (t) { let e; let i; const n = []; for (e = 0, i = t.length; e < i; e++)t[e].major && n.push(e); return n } function Nr (t, e, i, n) { let a; let r = 0; let o = i[0]; for (n = Math.ceil(n), a = 0; a < t.length; a++)a === o && (e.push(t[a]), r++, o = i[r * n]) } function Hr (t, e, i, n, a) { let r; let o; let s; const l = Z(n, 0); const h = Math.min(Z(a, t.length), t.length); let u = 0; i = Math.ceil(i), a && (r = a - n, i = r / Math.floor(r / i)), s = l; while (s < 0)u++, s = Math.round(l + u * i); for (o = Math.max(l, 0); o < h; o++)o === s && (e.push(t[o]), u++, s = Math.round(l + u * i)) } function jr (t) { let e; let i; const n = t.length; if (n < 2) return !1; for (i = t[0], e = 1; e < n; ++e) if (t[e] - t[e - 1] !== i) return !1; return i }Ee.set('scale', { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: 'ticks', grace: 0, grid: { display: !0, lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: function (t, e) { return e.lineWidth }, tickColor: function (t, e) { return e.color }, offset: !1, borderDash: [], borderDashOffset: 0, borderWidth: 1 }, title: { display: !1, text: '', padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: '', padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: zr.formatters.values, minor: {}, major: {}, align: 'center', crossAlign: 'near', showLabelBackdrop: !1, backdropColor: 'rgba(255, 255, 255, 0.75)', backdropPadding: 2 } }), Ee.route('scale.ticks', 'color', '', 'color'), Ee.route('scale.grid', 'color', '', 'borderColor'), Ee.route('scale.grid', 'borderColor', '', 'borderColor'), Ee.route('scale.title', 'color', '', 'color'), Ee.describe('scale', { _fallback: !1, _scriptable: function (t) { return !t.startsWith('before') && !t.startsWith('after') && t !== 'callback' && t !== 'parser' }, _indexable: function (t) { return t !== 'borderDash' && t !== 'tickBorderDash' } }), Ee.describe('scales', { _fallback: 'scale' }), Ee.describe('scale.ticks', { _scriptable: function (t) { return t !== 'backdropPadding' && t !== 'callback' }, _indexable: function (t) { return t !== 'backdropPadding' } }); const $r = function (t) { return t === 'left' ? 'right' : t === 'right' ? 'left' : t }; const Yr = function (t, e, i) { return e === 'top' || e === 'left' ? t[e] + i : t[e] - i }; function Ur (t, e) { for (var i = [], n = t.length / e, a = t.length, r = 0; r < a; r += n)i.push(t[Math.floor(r)]); return i } function Xr (t, e, i) { let n; const a = t.ticks.length; const r = Math.min(e, a - 1); const o = t._startPixel; const s = t._endPixel; const l = 1e-6; let h = t.getPixelForTick(r); if (!(i && (n = a === 1 ? Math.max(h - o, s - h) : e === 0 ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(r - 1)) / 2, h += r < e ? n : -n, h < o - l || h > s + l))) return h } function qr (t, e) { V(t, function (t) { let i; const n = t.gc; const a = n.length / 2; if (a > e) { for (i = 0; i < a; ++i) delete t.data[n[i]]; n.splice(0, a) } }) } function Kr (t) { return t.drawTicks ? t.tickLength : 0 } function Gr (t, e) { if (!t.display) return 0; const i = ri(t.font, e); const n = ai(t.padding); const a = L(t.text) ? t.text.length : 1; return a * i.lineHeight + n.height } function Jr (t, e) { return li(t, { scale: e, type: 'scale' }) } function Qr (t, e, i) { return li(t, { tick: i, index: e, type: 'tick' }) } function to (t, e, i) { let n = P(t); return (i && e !== 'right' || !i && e === 'right') && (n = $r(n)), n } function eo (t, e, i, n) { let a; let r; let o; const s = t.top; const l = t.left; const h = t.bottom; const u = t.right; const c = t.chart; const d = c.chartArea; const f = c.scales; let v = 0; const g = h - s; const p = u - l; if (t.isHorizontal()) { if (r = C(n, l, u), R(i)) { const y = Object.keys(i)[0]; const m = i[y]; o = f[y].getPixelForValue(m) + g - e } else o = i === 'center' ? (d.bottom + d.top) / 2 + g - e : Yr(t, i, e); a = u - l } else { if (R(i)) { const b = Object.keys(i)[0]; const x = i[b]; r = f[b].getPixelForValue(x) - p + e } else r = i === 'center' ? (d.left + d.right) / 2 - p + e : Yr(t, i, e); o = C(n, h, s), v = i === 'left' ? -lt : lt } return { titleX: r, titleY: o, maxWidth: a, rotation: v } } const io = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.id = t.id, n.type = t.type, n.options = void 0, n.ctx = t.ctx, n.chart = t.chart, n.top = void 0, n.bottom = void 0, n.left = void 0, n.right = void 0, n.width = void 0, n.height = void 0, n._margins = { left: 0, right: 0, top: 0, bottom: 0 }, n.maxWidth = void 0, n.maxHeight = void 0, n.paddingTop = void 0, n.paddingBottom = void 0, n.paddingLeft = void 0, n.paddingRight = void 0, n.axis = void 0, n.labelRotation = void 0, n.min = void 0, n.max = void 0, n._range = void 0, n.ticks = [], n._gridLineItems = null, n._labelItems = null, n._labelSizes = null, n._length = 0, n._maxLength = 0, n._longestTextCache = {}, n._startPixel = void 0, n._endPixel = void 0, n._reversePixels = !1, n._userMax = void 0, n._userMin = void 0, n._suggestedMax = void 0, n._suggestedMin = void 0, n._ticksLength = 0, n._borderValue = 0, n._cache = {}, n._dataLimitsCached = !1, n.$context = void 0, n } return (0, k.Z)(i, [{ key: 'init', value: function (t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } }, { key: 'parse', value: function (t, e) { return t } }, { key: 'getUserBounds', value: function () { let t = this._userMin; let e = this._userMax; let i = this._suggestedMin; let n = this._suggestedMax; return t = I(t, Number.POSITIVE_INFINITY), e = I(e, Number.NEGATIVE_INFINITY), i = I(i, Number.POSITIVE_INFINITY), n = I(n, Number.NEGATIVE_INFINITY), { min: I(t, i), max: I(e, n), minDefined: E(t), maxDefined: E(e) } } }, { key: 'getMinMax', value: function (t) { let e; const i = this.getUserBounds(); let n = i.min; let a = i.max; const r = i.minDefined; const o = i.maxDefined; if (r && o) return { min: n, max: a }; for (let s = this.getMatchingVisibleMetas(), l = 0, h = s.length; l < h; ++l)e = s[l].controller.getMinMax(this, t), r || (n = Math.min(n, e.min)), o || (a = Math.max(a, e.max)); return n = o && n > a ? a : n, a = r && n > a ? n : a, { min: I(n, I(a, n)), max: I(a, I(n, a)) } } }, { key: 'getPadding', value: function () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } }, { key: 'getTicks', value: function () { return this.ticks } }, { key: 'getLabels', value: function () { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } }, { key: 'beforeLayout', value: function () { this._cache = {}, this._dataLimitsCached = !1 } }, { key: 'beforeUpdate', value: function () { B(this.options.beforeUpdate, [this]) } }, { key: 'update', value: function (t, e, i) { const n = this.options; const a = n.beginAtZero; const r = n.grace; const o = n.ticks; const s = o.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = si(this, r, a), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = s < this.ticks.length; this._convertTicksToLabels(l ? Ur(this.ticks, s) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === 'auto') && (this.ticks = Fr(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } }, { key: 'configure', value: function () { let t; let e; let i = this.options.reverse; this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels } }, { key: 'afterUpdate', value: function () { B(this.options.afterUpdate, [this]) } }, { key: 'beforeSetDimensions', value: function () { B(this.options.beforeSetDimensions, [this]) } }, { key: 'setDimensions', value: function () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } }, { key: 'afterSetDimensions', value: function () { B(this.options.afterSetDimensions, [this]) } }, { key: '_callHooks', value: function (t) { this.chart.notifyPlugins(t, this.getContext()), B(this.options[t], [this]) } }, { key: 'beforeDataLimits', value: function () { this._callHooks('beforeDataLimits') } }, { key: 'determineDataLimits', value: function () {} }, { key: 'afterDataLimits', value: function () { this._callHooks('afterDataLimits') } }, { key: 'beforeBuildTicks', value: function () { this._callHooks('beforeBuildTicks') } }, { key: 'buildTicks', value: function () { return [] } }, { key: 'afterBuildTicks', value: function () { this._callHooks('afterBuildTicks') } }, { key: 'beforeTickToLabelConversion', value: function () { B(this.options.beforeTickToLabelConversion, [this]) } }, { key: 'generateTickLabels', value: function (t) { let e; let i; let n; const a = this.options.ticks; for (e = 0, i = t.length; e < i; e++)n = t[e], n.label = B(a.callback, [n.value, e, t], this) } }, { key: 'afterTickToLabelConversion', value: function () { B(this.options.afterTickToLabelConversion, [this]) } }, { key: 'beforeCalculateLabelRotation', value: function () { B(this.options.beforeCalculateLabelRotation, [this]) } }, { key: 'calculateLabelRotation', value: function () { let t; let e; let i; const n = this.options; const a = n.ticks; const r = this.ticks.length; const o = a.minRotation || 0; const s = a.maxRotation; let l = o; if (!this._isVisible() || !a.display || o >= s || r <= 1 || !this.isHorizontal()) this.labelRotation = o; else { const h = this._getLabelSizes(); const u = h.widest.width; const c = h.highest.height; const d = Ct(this.chart.width - u, 0, this.maxWidth); t = n.offset ? this.maxWidth / r : d / (r - 1), u + 6 > t && (t = d / (r - (n.offset ? 0.5 : 1)), e = this.maxHeight - Kr(n.grid) - a.padding - Gr(n.title, this.chart.options.font), i = Math.sqrt(u * u + c * c), l = xt(Math.min(Math.asin(Ct((h.highest.height + 6) / t, -1, 1)), Math.asin(Ct(e / i, -1, 1)) - Math.asin(Ct(c / i, -1, 1)))), l = Math.max(o, Math.min(s, l))), this.labelRotation = l } } }, { key: 'afterCalculateLabelRotation', value: function () { B(this.options.afterCalculateLabelRotation, [this]) } }, { key: 'afterAutoSkip', value: function () {} }, { key: 'beforeFit', value: function () { B(this.options.beforeFit, [this]) } }, { key: 'fit', value: function () { const t = { width: 0, height: 0 }; const e = this.chart; const i = this.options; const n = i.ticks; const a = i.title; const r = i.grid; const o = this._isVisible(); const s = this.isHorizontal(); if (o) { const l = Gr(a, e.options.font); if (s ? (t.width = this.maxWidth, t.height = Kr(r) + l) : (t.height = this.maxHeight, t.width = Kr(r) + l), n.display && this.ticks.length) { const h = this._getLabelSizes(); const u = h.first; const c = h.last; const d = h.widest; const f = h.highest; const v = 2 * n.padding; const g = bt(this.labelRotation); const p = Math.cos(g); const y = Math.sin(g); if (s) { const m = n.mirror ? 0 : y * d.width + p * f.height; t.height = Math.min(this.maxHeight, t.height + m + v) } else { const b = n.mirror ? 0 : p * d.width + y * f.height; t.width = Math.min(this.maxWidth, t.width + b + v) } this._calculatePadding(u, c, y, p) } } this._handleMargins(), s ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom) } }, { key: '_calculatePadding', value: function (t, e, i, n) { const a = this.options; const r = a.ticks; const o = r.align; const s = r.padding; const l = a.position; const h = this.labelRotation !== 0; const u = l !== 'top' && this.axis === 'x'; if (this.isHorizontal()) { const c = this.getPixelForTick(0) - this.left; const d = this.right - this.getPixelForTick(this.ticks.length - 1); let f = 0; let v = 0; h ? u ? (f = n * t.width, v = i * e.height) : (f = i * t.height, v = n * e.width) : o === 'start' ? v = e.width : o === 'end' ? f = t.width : o !== 'inner' && (f = t.width / 2, v = e.width / 2), this.paddingLeft = Math.max((f - c + s) * this.width / (this.width - c), 0), this.paddingRight = Math.max((v - d + s) * this.width / (this.width - d), 0) } else { let g = e.height / 2; let p = t.height / 2; o === 'start' ? (g = 0, p = t.height) : o === 'end' && (g = e.height, p = 0), this.paddingTop = g + s, this.paddingBottom = p + s } } }, { key: '_handleMargins', value: function () { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } }, { key: 'afterFit', value: function () { B(this.options.afterFit, [this]) } }, { key: 'isHorizontal', value: function () { const t = this.options; const e = t.axis; const i = t.position; return i === 'top' || i === 'bottom' || e === 'x' } }, { key: 'isFullSize', value: function () { return this.options.fullSize } }, { key: '_convertTicksToLabels', value: function (t) { let e, i; for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)T(t[e].label) && (t.splice(e, 1), i--, e--); this.afterTickToLabelConversion() } }, { key: '_getLabelSizes', value: function () { let t = this._labelSizes; if (!t) { const e = this.options.ticks.sampleSize; let i = this.ticks; e < i.length && (i = Ur(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length) } return t } }, { key: '_computeLabelSizes', value: function (t, e) { let i; let n; let a; let r; let o; let s; let l; let h; let u; let c; let d; const f = this.ctx; const v = this._longestTextCache; const g = []; const p = []; let y = 0; let m = 0; for (i = 0; i < e; ++i) { if (r = t[i].label, o = this._resolveTickFontOptions(i), f.font = s = o.string, l = v[s] = v[s] || { data: {}, gc: [] }, h = o.lineHeight, u = c = 0, T(r) || L(r)) { if (L(r)) for (n = 0, a = r.length; n < a; ++n)d = r[n], T(d) || L(d) || (u = Ze(f, l.data, l.gc, u, d), c += h) } else u = Ze(f, l.data, l.gc, u, r), c = h; g.push(u), p.push(c), y = Math.max(u, y), m = Math.max(c, m) }qr(v, e); const b = g.indexOf(y); const x = p.indexOf(m); const _ = function (t) { return { width: g[t] || 0, height: p[t] || 0 } }; return { first: _(0), last: _(e - 1), widest: _(b), highest: _(x), widths: g, heights: p } } }, { key: 'getLabelForValue', value: function (t) { return t } }, { key: 'getPixelForValue', value: function (t, e) { return NaN } }, { key: 'getValueForPixel', value: function (t) {} }, { key: 'getPixelForTick', value: function (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } }, { key: 'getPixelForDecimal', value: function (t) { this._reversePixels && (t = 1 - t); const e = this._startPixel + t * this._length; return Dt(this._alignToPixels ? Fe(this.chart, e, 0) : e) } }, { key: 'getDecimalForPixel', value: function (t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } }, { key: 'getBasePixel', value: function () { return this.getPixelForValue(this.getBaseValue()) } }, { key: 'getBaseValue', value: function () { const t = this.min; const e = this.max; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } }, { key: 'getContext', value: function (t) { const e = this.ticks || []; if (t >= 0 && t < e.length) { const i = e[t]; return i.$context || (i.$context = Qr(this.getContext(), t, i)) } return this.$context || (this.$context = Jr(this.chart.getContext(), this)) } }, { key: '_tickSize', value: function () { const t = this.options.ticks; const e = bt(this.labelRotation); const i = Math.abs(Math.cos(e)); const n = Math.abs(Math.sin(e)); const a = this._getLabelSizes(); const r = t.autoSkipPadding || 0; const o = a ? a.widest.width + r : 0; const s = a ? a.highest.height + r : 0; return this.isHorizontal() ? s * i > o * n ? o / i : s / n : s * n < o * i ? s / i : o / n } }, { key: '_isVisible', value: function () { const t = this.options.display; return t !== 'auto' ? !!t : this.getMatchingVisibleMetas().length > 0 } }, { key: '_computeGridLineItems', value: function (t) { let e; let i; let n; let a; let r; let o; let s; let l; let h; let u; let c; let d; const f = this.axis; const v = this.chart; const g = this.options; const p = g.grid; const y = g.position; const m = p.offset; const b = this.isHorizontal(); const x = this.ticks; const _ = x.length + (m ? 1 : 0); const k = Kr(p); const w = []; const M = p.setContext(this.getContext()); const S = M.drawBorder ? M.borderWidth : 0; const P = S / 2; const C = function (t) { return Fe(v, t, S) }; if (y === 'top')e = C(this.bottom), o = this.bottom - k, l = e - P, u = C(t.top) + P, d = t.bottom; else if (y === 'bottom')e = C(this.top), u = t.top, d = C(t.bottom) - P, o = e + P, l = this.top + k; else if (y === 'left')e = C(this.right), r = this.right - k, s = e - P, h = C(t.left) + P, c = t.right; else if (y === 'right')e = C(this.left), h = t.left, c = C(t.right) - P, r = e + P, s = this.left + k; else if (f === 'x') { if (y === 'center')e = C((t.top + t.bottom) / 2 + 0.5); else if (R(y)) { const D = Object.keys(y)[0]; const O = y[D]; e = C(this.chart.scales[D].getPixelForValue(O)) }u = t.top, d = t.bottom, o = e + P, l = o + k } else if (f === 'y') { if (y === 'center')e = C((t.left + t.right) / 2); else if (R(y)) { const A = Object.keys(y)[0]; const T = y[A]; e = C(this.chart.scales[A].getPixelForValue(T)) }r = e - P, s = r - k, h = t.left, c = t.right } const L = Z(g.ticks.maxTicksLimit, _); const E = Math.max(1, Math.ceil(_ / L)); for (i = 0; i < _; i += E) { const I = p.setContext(this.getContext(i)); const z = I.lineWidth; const F = I.color; const B = p.borderDash || []; const V = I.borderDashOffset; const W = I.tickWidth; const N = I.tickColor; const H = I.tickBorderDash || []; const j = I.tickBorderDashOffset; n = Xr(this, i, m), void 0 !== n && (a = Fe(v, n, z), b ? r = s = h = c = a : o = l = u = d = a, w.push({ tx1: r, ty1: o, tx2: s, ty2: l, x1: h, y1: u, x2: c, y2: d, width: z, color: F, borderDash: B, borderDashOffset: V, tickWidth: W, tickColor: N, tickBorderDash: H, tickBorderDashOffset: j })) } return this._ticksLength = _, this._borderValue = e, w } }, { key: '_computeLabelItems', value: function (t) { let e; let i; let n; let a; let r; let o; let s; let l; let h; let u; let c; let d; const f = this.axis; const v = this.options; const g = v.position; const p = v.ticks; const y = this.isHorizontal(); const m = this.ticks; const b = p.align; const x = p.crossAlign; const _ = p.padding; const k = p.mirror; const w = Kr(v.grid); const M = w + _; const S = k ? -_ : M; const P = -bt(this.labelRotation); const C = []; let D = 'middle'; if (g === 'top')o = this.bottom - S, s = this._getXAxisLabelAlignment(); else if (g === 'bottom')o = this.top + S, s = this._getXAxisLabelAlignment(); else if (g === 'left') { const O = this._getYAxisLabelAlignment(w); s = O.textAlign, r = O.x } else if (g === 'right') { const A = this._getYAxisLabelAlignment(w); s = A.textAlign, r = A.x } else if (f === 'x') { if (g === 'center')o = (t.top + t.bottom) / 2 + M; else if (R(g)) { const T = Object.keys(g)[0]; const E = g[T]; o = this.chart.scales[T].getPixelForValue(E) + M }s = this._getXAxisLabelAlignment() } else if (f === 'y') { if (g === 'center')r = (t.left + t.right) / 2 - M; else if (R(g)) { const I = Object.keys(g)[0]; const Z = g[I]; r = this.chart.scales[I].getPixelForValue(Z) }s = this._getYAxisLabelAlignment(w).textAlign }f === 'y' && (b === 'start' ? D = 'top' : b === 'end' && (D = 'bottom')); const z = this._getLabelSizes(); for (e = 0, i = m.length; e < i; ++e) { n = m[e], a = n.label; const F = p.setContext(this.getContext(e)); l = this.getPixelForTick(e) + p.labelOffset, h = this._resolveTickFontOptions(e), u = h.lineHeight, c = L(a) ? a.length : 1; const B = c / 2; const V = F.color; const W = F.textStrokeColor; const N = F.textStrokeWidth; let H = s; y ? (r = l, s === 'inner' && (H = e === i - 1 ? this.options.reverse ? 'left' : 'right' : e === 0 ? this.options.reverse ? 'right' : 'left' : 'center'), d = g === 'top' ? x === 'near' || P !== 0 ? -c * u + u / 2 : x === 'center' ? -z.highest.height / 2 - B * u + u : -z.highest.height + u / 2 : x === 'near' || P !== 0 ? u / 2 : x === 'center' ? z.highest.height / 2 - B * u : z.highest.height - c * u, k && (d *= -1)) : (o = l, d = (1 - c) * u / 2); let j = void 0; if (F.showLabelBackdrop) { const $ = ai(F.backdropPadding); const Y = z.heights[e]; const U = z.widths[e]; let X = o + d - $.top; let q = r - $.left; switch (D) { case 'middle':X -= Y / 2; break; case 'bottom':X -= Y; break } switch (s) { case 'center':q -= U / 2; break; case 'right':q -= U; break }j = { left: q, top: X, width: U + $.width, height: Y + $.height, color: F.backdropColor } }C.push({ rotation: P, label: a, font: h, color: V, strokeColor: W, strokeWidth: N, textOffset: d, textAlign: H, textBaseline: D, translation: [r, o], backdrop: j }) } return C } }, { key: '_getXAxisLabelAlignment', value: function () { const t = this.options; const e = t.position; const i = t.ticks; const n = -bt(this.labelRotation); if (n) return e === 'top' ? 'left' : 'right'; let a = 'center'; return i.align === 'start' ? a = 'left' : i.align === 'end' ? a = 'right' : i.align === 'inner' && (a = 'inner'), a } }, { key: '_getYAxisLabelAlignment', value: function (t) { let e; let i; const n = this.options; const a = n.position; const r = n.ticks; const o = r.crossAlign; const s = r.mirror; const l = r.padding; const h = this._getLabelSizes(); const u = t + l; const c = h.widest.width; return a === 'left' ? s ? (i = this.right + l, o === 'near' ? e = 'left' : o === 'center' ? (e = 'center', i += c / 2) : (e = 'right', i += c)) : (i = this.right - u, o === 'near' ? e = 'right' : o === 'center' ? (e = 'center', i -= c / 2) : (e = 'left', i = this.left)) : a === 'right' ? s ? (i = this.left + l, o === 'near' ? e = 'right' : o === 'center' ? (e = 'center', i -= c / 2) : (e = 'left', i -= c)) : (i = this.left + u, o === 'near' ? e = 'left' : o === 'center' ? (e = 'center', i += c / 2) : (e = 'right', i = this.right)) : e = 'right', { textAlign: e, x: i } } }, { key: '_computeLabelArea', value: function () { if (!this.options.ticks.mirror) { const t = this.chart; const e = this.options.position; return e === 'left' || e === 'right' ? { top: 0, left: this.left, bottom: t.height, right: this.right } : e === 'top' || e === 'bottom' ? { top: this.top, left: 0, bottom: this.bottom, right: t.width } : void 0 } } }, { key: 'drawBackground', value: function () { const t = this.ctx; const e = this.options.backgroundColor; const i = this.left; const n = this.top; const a = this.width; const r = this.height; e && (t.save(), t.fillStyle = e, t.fillRect(i, n, a, r), t.restore()) } }, { key: 'getLineWidthForValue', value: function (t) { const e = this.options.grid; if (!this._isVisible() || !e.display) return 0; const i = this.ticks; const n = i.findIndex(function (e) { return e.value === t }); if (n >= 0) { const a = e.setContext(this.getContext(n)); return a.lineWidth } return 0 } }, { key: 'drawGrid', value: function (t) { let e; let i; const n = this.options.grid; const a = this.ctx; const r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); const o = function (t, e, i) { i.width && i.color && (a.save(), a.lineWidth = i.width, a.strokeStyle = i.color, a.setLineDash(i.borderDash || []), a.lineDashOffset = i.borderDashOffset, a.beginPath(), a.moveTo(t.x, t.y), a.lineTo(e.x, e.y), a.stroke(), a.restore()) }; if (n.display) for (e = 0, i = r.length; e < i; ++e) { const s = r[e]; n.drawOnChartArea && o({ x: s.x1, y: s.y1 }, { x: s.x2, y: s.y2 }, s), n.drawTicks && o({ x: s.tx1, y: s.ty1 }, { x: s.tx2, y: s.ty2 }, { color: s.tickColor, width: s.tickWidth, borderDash: s.tickBorderDash, borderDashOffset: s.tickBorderDashOffset }) } } }, { key: 'drawBorder', value: function () { const t = this.chart; const e = this.ctx; const i = this.options.grid; const n = i.setContext(this.getContext()); const a = i.drawBorder ? n.borderWidth : 0; if (a) { let r; let o; let s; let l; const h = i.setContext(this.getContext(0)).lineWidth; const u = this._borderValue; this.isHorizontal() ? (r = Fe(t, this.left, a) - a / 2, o = Fe(t, this.right, h) + h / 2, s = l = u) : (s = Fe(t, this.top, a) - a / 2, l = Fe(t, this.bottom, h) + h / 2, r = o = u), e.save(), e.lineWidth = n.borderWidth, e.strokeStyle = n.borderColor, e.beginPath(), e.moveTo(r, s), e.lineTo(o, l), e.stroke(), e.restore() } } }, { key: 'drawLabels', value: function (t) { const e = this.options.ticks; if (e.display) { const i = this.ctx; const n = this._computeLabelArea(); n && He(i, n); let a; let r; const o = this._labelItems || (this._labelItems = this._computeLabelItems(t)); for (a = 0, r = o.length; a < r; ++a) { const s = o[a]; const l = s.font; const h = s.label; s.backdrop && (i.fillStyle = s.backdrop.color, i.fillRect(s.backdrop.left, s.backdrop.top, s.backdrop.width, s.backdrop.height)); const u = s.textOffset; Ue(i, h, 0, u, l, s) }n && je(i) } } }, { key: 'drawTitle', value: function () { const t = this.ctx; const e = this.options; const i = e.position; const n = e.title; const a = e.reverse; if (n.display) { const r = ri(n.font); const o = ai(n.padding); const s = n.align; let l = r.lineHeight / 2; i === 'bottom' || i === 'center' || R(i) ? (l += o.bottom, L(n.text) && (l += r.lineHeight * (n.text.length - 1))) : l += o.top; const h = eo(this, l, i, s); const u = h.titleX; const c = h.titleY; const d = h.maxWidth; const f = h.rotation; Ue(t, n.text, 0, 0, r, { color: n.color, maxWidth: d, rotation: f, textAlign: to(s, i, a), textBaseline: 'middle', translation: [u, c] }) } } }, { key: 'draw', value: function (t) { this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } }, { key: '_layers', value: function () { const t = this; const e = this.options; const n = e.ticks && e.ticks.z || 0; const a = Z(e.grid && e.grid.z, -1); return this._isVisible() && this.draw === i.prototype.draw ? [{ z: a, draw: function (e) { t.drawBackground(), t.drawGrid(e), t.drawTitle() } }, { z: a + 1, draw: function () { t.drawBorder() } }, { z: n, draw: function (e) { t.drawLabels(e) } }] : [{ z: n, draw: function (e) { t.draw(e) } }] } }, { key: 'getMatchingVisibleMetas', value: function (t) { let e; let i; const n = this.chart.getSortedVisibleDatasetMetas(); const a = this.axis + 'AxisID'; const r = []; for (e = 0, i = n.length; e < i; ++e) { const o = n[e]; o[a] !== this.id || t && o.type !== t || r.push(o) } return r } }, { key: '_resolveTickFontOptions', value: function (t) { const e = this.options.ticks.setContext(this.getContext(t)); return ri(e.font) } }, { key: '_maxDigits', value: function () { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } }]), i }(Er)); const no = (function () { function t (e, i, n) { (0, _.Z)(this, t), this.type = e, this.scope = i, this.override = n, this.items = Object.create(null) } return (0, k.Z)(t, [{ key: 'isForType', value: function (t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } }, { key: 'register', value: function (t) { let e; const i = Object.getPrototypeOf(t); oo(i) && (e = this.register(i)); const n = this.items; const a = t.id; const r = this.scope + '.' + a; if (!a) throw new Error('class does not have id: ' + t); return a in n || (n[a] = t, ao(t, r, e), this.override && Ee.override(t.id, t.overrides)), r } }, { key: 'get', value: function (t) { return this.items[t] } }, { key: 'unregister', value: function (t) { const e = this.items; const i = t.id; const n = this.scope; i in e && delete e[i], n && i in Ee[n] && (delete Ee[n][i], this.override && delete Oe[i]) } }]), t }()); function ao (t, e, i) { const n = $(Object.create(null), [i ? Ee.get(i) : {}, Ee.get(e), t.defaults]); Ee.set(e, n), t.defaultRoutes && ro(e, t.defaultRoutes), t.descriptors && Ee.describe(e, t.descriptors) } function ro (t, e) { Object.keys(e).forEach(function (i) { const n = i.split('.'); const a = n.pop(); const r = [t].concat(n).join('.'); const o = e[i].split('.'); const s = o.pop(); const l = o.join('.'); Ee.route(r, a, l, s) }) } function oo (t) { return 'id' in t && 'defaults' in t } const so = (function () { function t () { (0, _.Z)(this, t), this.controllers = new no(ha, 'datasets', !0), this.elements = new no(Er, 'elements'), this.plugins = new no(Object, 'plugins'), this.scales = new no(io, 'scales'), this._typedRegistries = [this.controllers, this.scales, this.elements] } return (0, k.Z)(t, [{ key: 'add', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('register', e) } }, { key: 'remove', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('unregister', e) } }, { key: 'addControllers', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('register', e, this.controllers) } }, { key: 'addElements', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('register', e, this.elements) } }, { key: 'addPlugins', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('register', e, this.plugins) } }, { key: 'addScales', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('register', e, this.scales) } }, { key: 'getController', value: function (t) { return this._get(t, this.controllers, 'controller') } }, { key: 'getElement', value: function (t) { return this._get(t, this.elements, 'element') } }, { key: 'getPlugin', value: function (t) { return this._get(t, this.plugins, 'plugin') } }, { key: 'getScale', value: function (t) { return this._get(t, this.scales, 'scale') } }, { key: 'removeControllers', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('unregister', e, this.controllers) } }, { key: 'removeElements', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('unregister', e, this.elements) } }, { key: 'removePlugins', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('unregister', e, this.plugins) } }, { key: 'removeScales', value: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; this._each('unregister', e, this.scales) } }, { key: '_each', value: function (t, e, i) { const n = this; (0, c.Z)(e).forEach(function (e) { const a = i || n._getRegistryForType(e); i || a.isForType(e) || a === n.plugins && e.id ? n._exec(t, a, e) : V(e, function (e) { const a = i || n._getRegistryForType(e); n._exec(t, a, e) }) }) } }, { key: '_exec', value: function (t, e, i) { const n = J(t); B(i['before' + n], [], i), e[t](i), B(i['after' + n], [], i) } }, { key: '_getRegistryForType', value: function (t) { for (let e = 0; e < this._typedRegistries.length; e++) { const i = this._typedRegistries[e]; if (i.isForType(t)) return i } return this.plugins } }, { key: '_get', value: function (t, e, i) { const n = e.get(t); if (void 0 === n) throw new Error('"' + t + '" is not a registered ' + i + '.'); return n } }]), t }()); const lo = new so(); const ho = (function () { function t () { (0, _.Z)(this, t), this._init = [] } return (0, k.Z)(t, [{ key: 'notify', value: function (t, e, i, n) { e === 'beforeInit' && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, 'install')); const a = n ? this._descriptors(t).filter(n) : this._descriptors(t); const r = this._notify(a, t, e, i); return e === 'afterDestroy' && (this._notify(a, t, 'stop'), this._notify(this._init, t, 'uninstall')), r } }, { key: '_notify', value: function (t, e, i, n) { n = n || {}; let a; const r = (0, b.Z)(t); try { for (r.s(); !(a = r.n()).done;) { const o = a.value; const s = o.plugin; const l = s[i]; const h = [e, n, o.options]; if (!1 === B(l, h, s) && n.cancelable) return !1 } } catch (u) { r.e(u) } finally { r.f() } return !0 } }, { key: 'invalidate', value: function () { T(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } }, { key: '_descriptors', value: function (t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } }, { key: '_createDescriptors', value: function (t, e) { const i = t && t.config; const n = Z(i.options && i.options.plugins, {}); const a = uo(i); return !1 !== n || e ? fo(t, a, n, e) : [] } }, { key: '_notifyStateChanges', value: function (t) { const e = this._oldCache || []; const i = this._cache; const n = function (t, e) { return t.filter(function (t) { return !e.some(function (e) { return t.plugin.id === e.plugin.id }) }) }; this._notify(n(e, i), t, 'stop'), this._notify(n(i, e), t, 'start') } }]), t }()); function uo (t) { for (var e = {}, i = [], n = Object.keys(lo.plugins.items), a = 0; a < n.length; a++)i.push(lo.getPlugin(n[a])); for (let r = t.plugins || [], o = 0; o < r.length; o++) { const s = r[o]; i.indexOf(s) === -1 && (i.push(s), e[s.id] = !0) } return { plugins: i, localIds: e } } function co (t, e) { return e || !1 !== t ? !0 === t ? {} : t : null } function fo (t, e, i, n) { let a; const r = e.plugins; const o = e.localIds; const s = []; const l = t.getContext(); const h = (0, b.Z)(r); try { for (h.s(); !(a = h.n()).done;) { const u = a.value; const c = u.id; const d = co(i[c], n); d !== null && s.push({ plugin: u, options: vo(t.config, { plugin: u, local: o[c] }, d, l) }) } } catch (f) { h.e(f) } finally { h.f() } return s } function vo (t, e, i, n) { const a = e.plugin; const r = e.local; const o = t.pluginScopeKeys(a); const s = t.getOptionScopes(i, o); return r && a.defaults && s.push(a.defaults), t.createResolver(s, n, [''], { scriptable: !1, indexable: !1, allKeys: !0 }) } function go (t, e) { const i = Ee.datasets[t] || {}; const n = (e.datasets || {})[t] || {}; return n.indexAxis || e.indexAxis || i.indexAxis || 'x' } function po (t, e) { let i = t; return t === '_index_' ? i = e : t === '_value_' && (i = e === 'x' ? 'y' : 'x'), i } function yo (t, e) { return t === e ? '_index_' : '_value_' } function mo (t) { return t === 'top' || t === 'bottom' ? 'x' : t === 'left' || t === 'right' ? 'y' : void 0 } function bo (t, e) { return t === 'x' || t === 'y' ? t : e.axis || mo(e.position) || t.charAt(0).toLowerCase() } function xo (t, e) { const i = Oe[t.type] || { scales: {} }; const n = e.scales || {}; const a = go(t.type, e); const r = Object.create(null); const o = Object.create(null); return Object.keys(n).forEach(function (t) { const e = n[t]; if (!R(e)) return console.error('Invalid scale configuration for scale: '.concat(t)); if (e._proxy) return console.warn('Ignoring resolver passed as options for scale: '.concat(t)); const s = bo(t, e); const l = yo(s, a); const h = i.scales || {}; r[s] = r[s] || t, o[t] = Y(Object.create(null), [{ axis: s }, e, h[s], h[l]]) }), t.data.datasets.forEach(function (i) { const a = i.type || t.type; const s = i.indexAxis || go(a, e); const l = Oe[a] || {}; const h = l.scales || {}; Object.keys(h).forEach(function (t) { const e = po(t, s); const a = i[e + 'AxisID'] || r[e] || e; o[a] = o[a] || Object.create(null), Y(o[a], [{ axis: e }, n[a], h[t]]) }) }), Object.keys(o).forEach(function (t) { const e = o[t]; Y(e, [Ee.scales[e.type], Ee.scale]) }), o } function _o (t) { const e = t.options || (t.options = {}); e.plugins = Z(e.plugins, {}), e.scales = xo(t, e) } function ko (t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function wo (t) { return t = t || {}, t.data = ko(t.data), _o(t), t } const Mo = new Map(); const So = new Set(); function Po (t, e) { let i = Mo.get(t); return i || (i = e(), Mo.set(t, i), So.add(i)), i } const Co = function (t, e, i) { const n = G(e, i); void 0 !== n && t.add(n) }; const Do = (function () { function t (e) { (0, _.Z)(this, t), this._config = wo(e), this._scopeCache = new Map(), this._resolverCache = new Map() } return (0, k.Z)(t, [{ key: 'platform', get: function () { return this._config.platform } }, { key: 'type', get: function () { return this._config.type }, set: function (t) { this._config.type = t } }, { key: 'data', get: function () { return this._config.data }, set: function (t) { this._config.data = ko(t) } }, { key: 'options', get: function () { return this._config.options }, set: function (t) { this._config.options = t } }, { key: 'plugins', get: function () { return this._config.plugins } }, { key: 'update', value: function () { const t = this._config; this.clearCache(), _o(t) } }, { key: 'clearCache', value: function () { this._scopeCache.clear(), this._resolverCache.clear() } }, { key: 'datasetScopeKeys', value: function (t) { return Po(t, function () { return [['datasets.'.concat(t), '']] }) } }, { key: 'datasetAnimationScopeKeys', value: function (t, e) { return Po(''.concat(t, '.transition.').concat(e), function () { return [['datasets.'.concat(t, '.transitions.').concat(e), 'transitions.'.concat(e)], ['datasets.'.concat(t), '']] }) } }, { key: 'datasetElementScopeKeys', value: function (t, e) { return Po(''.concat(t, '-').concat(e), function () { return [['datasets.'.concat(t, '.elements.').concat(e), 'datasets.'.concat(t), 'elements.'.concat(e), '']] }) } }, { key: 'pluginScopeKeys', value: function (t) { const e = t.id; const i = this.type; return Po(''.concat(i, '-plugin-').concat(e), function () { return [['plugins.'.concat(e)].concat((0, c.Z)(t.additionalOptionScopes || []))] }) } }, { key: '_cachedScopes', value: function (t, e) { const i = this._scopeCache; let n = i.get(t); return n && !e || (n = new Map(), i.set(t, n)), n } }, { key: 'getOptionScopes', value: function (t, e, i) { const n = this.options; const a = this.type; const r = this._cachedScopes(t, i); const o = r.get(e); if (o) return o; const s = new Set(); e.forEach(function (e) { t && (s.add(t), e.forEach(function (e) { return Co(s, t, e) })), e.forEach(function (t) { return Co(s, n, t) }), e.forEach(function (t) { return Co(s, Oe[a] || {}, t) }), e.forEach(function (t) { return Co(s, Ee, t) }), e.forEach(function (t) { return Co(s, Ae, t) }) }); const l = Array.from(s); return l.length === 0 && l.push(Object.create(null)), So.has(e) && r.set(e, l), l } }, { key: 'chartOptionScopes', value: function () { const t = this.options; const e = this.type; return [t, Oe[e] || {}, Ee.datasets[e] || {}, { type: e }, Ee, Ae] } }, { key: 'resolveNamedOptions', value: function (t, e, i) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ['']; const a = { $shared: !0 }; const r = Oo(this._resolverCache, t, n); const o = r.resolver; const s = r.subPrefixes; let l = o; if (To(o, e)) { a.$shared = !1, i = tt(i) ? i() : i; const h = this.createResolver(t, i, s); l = mi(o, i, h) } let u; const c = (0, b.Z)(e); try { for (c.s(); !(u = c.n()).done;) { const d = u.value; a[d] = l[d] } } catch (f) { c.e(f) } finally { c.f() } return a } }, { key: 'createResolver', value: function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ['']; const n = arguments.length > 3 ? arguments[3] : void 0; const a = Oo(this._resolverCache, t, i); const r = a.resolver; return R(e) ? mi(r, e, void 0, n) : r } }]), t }()); function Oo (t, e, i) { let n = t.get(e); n || (n = new Map(), t.set(e, n)); const a = i.join(); let r = n.get(a); if (!r) { const o = yi(e, i); r = { resolver: o, subPrefixes: i.filter(function (t) { return !t.toLowerCase().includes('hover') }) }, n.set(a, r) } return r } const Ao = function (t) { return R(t) && Object.getOwnPropertyNames(t).reduce(function (e, i) { return e || tt(t[i]) }, !1) }; function To (t, e) { let i; const n = bi(t); const a = n.isScriptable; const r = n.isIndexable; const o = (0, b.Z)(e); try { for (o.s(); !(i = o.n()).done;) { const s = i.value; const l = a(s); const h = r(s); const u = (h || l) && t[s]; if (l && (tt(u) || Ao(u)) || h && L(u)) return !0 } } catch (c) { o.e(c) } finally { o.f() } return !1 } const Lo = '3.8.2'; const Ro = ['top', 'bottom', 'left', 'right', 'chartArea']; function Eo (t, e) { return t === 'top' || t === 'bottom' || Ro.indexOf(t) === -1 && e === 'x' } function Io (t, e) { return function (i, n) { return i[t] === n[t] ? i[e] - n[e] : i[t] - n[t] } } function Zo (t) { const e = t.chart; const i = e.options.animation; e.notifyPlugins('afterRender'), B(i && i.onComplete, [t], e) } function zo (t) { const e = t.chart; const i = e.options.animation; B(i && i.onProgress, [t], e) } function Fo (t) { return Ui() && typeof t === 'string' ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Bo = {}; const Vo = function (t) { const e = Fo(t); return Object.values(Bo).filter(function (t) { return t.canvas === e }).pop() }; function Wo (t, e, i) { for (let n = Object.keys(t), a = 0, r = n; a < r.length; a++) { const o = r[a]; const s = +o; if (s >= e) { const l = t[o]; delete t[o], (i > 0 || s > e) && (t[s + i] = l) } } } function No (t, e, i, n) { return i && t.type !== 'mouseout' ? n ? e : t : null } const Ho = (function () { function t (e, i) { const n = this; (0, _.Z)(this, t); const a = this.config = new Do(i); const r = Fo(e); const o = Vo(r); if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."); const s = a.createResolver(a.chartOptionScopes(), this.getContext()); this.platform = new (a.platform || Rr(r))(), this.platform.updateConfig(a); const l = this.platform.acquireContext(r, s.aspectRatio); const h = l && l.canvas; const u = h && h.height; const c = h && h.width; this.id = A(), this.ctx = l, this.canvas = h, this.width = c, this.height = u, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new ho(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = S(function (t) { return n.update(t) }, s.resizeDelay || 0), this._dataChanges = [], Bo[this.id] = this, l && h ? (En.listen(this, 'complete', Zo), En.listen(this, 'progress', zo), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } return (0, k.Z)(t, [{ key: 'aspectRatio', get: function () { const t = this.options; const e = t.aspectRatio; const i = t.maintainAspectRatio; const n = this.width; const a = this.height; const r = this._aspectRatio; return T(e) ? i && r ? r : a ? n / a : null : e } }, { key: 'data', get: function () { return this.config.data }, set: function (t) { this.config.data = t } }, { key: 'options', get: function () { return this._options }, set: function (t) { this.config.options = t } }, { key: '_initialize', value: function () { return this.notifyPlugins('beforeInit'), this.options.responsive ? this.resize() : sn(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins('afterInit'), this } }, { key: 'clear', value: function () { return Be(this.canvas, this.ctx), this } }, { key: 'stop', value: function () { return En.stop(this), this } }, { key: 'resize', value: function (t, e) { En.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } }, { key: '_resize', value: function (t, e) { const i = this.options; const n = this.canvas; const a = i.maintainAspectRatio && this.aspectRatio; const r = this.platform.getMaximumSize(n, t, e, a); const o = i.devicePixelRatio || this.platform.getDevicePixelRatio(); const s = this.width ? 'resize' : 'attach'; this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, sn(this, o, !0) && (this.notifyPlugins('resize', { size: r }), B(i.onResize, [this, r], this), this.attached && this._doResize(s) && this.render()) } }, { key: 'ensureScalesHaveIDs', value: function () { const t = this.options; const e = t.scales || {}; V(e, function (t, e) { t.id = e }) } }, { key: 'buildOrUpdateScales', value: function () { const t = this; const e = this.options; const i = e.scales; const n = this.scales; const a = Object.keys(n).reduce(function (t, e) { return t[e] = !1, t }, {}); let r = []; i && (r = r.concat(Object.keys(i).map(function (t) { const e = i[t]; const n = bo(t, e); const a = n === 'r'; const r = n === 'x'; return { options: e, dposition: a ? 'chartArea' : r ? 'bottom' : 'left', dtype: a ? 'radialLinear' : r ? 'category' : 'linear' } }))), V(r, function (i) { const r = i.options; const o = r.id; const s = bo(o, r); const l = Z(r.type, i.dtype); void 0 !== r.position && Eo(r.position, s) === Eo(i.dposition) || (r.position = i.dposition), a[o] = !0; let h = null; if (o in n && n[o].type === l)h = n[o]; else { const u = lo.getScale(l); h = new u({ id: o, type: l, ctx: t.ctx, chart: t }), n[h.id] = h }h.init(r, e) }), V(a, function (t, e) { t || delete n[e] }), V(n, function (e) { ur.configure(t, e, e.options), ur.addBox(t, e) }) } }, { key: '_updateMetasets', value: function () { const t = this._metasets; const e = this.data.datasets.length; const i = t.length; if (t.sort(function (t, e) { return t.index - e.index }), i > e) { for (let n = e; n < i; ++n) this._destroyDatasetMeta(n); t.splice(e, i - e) } this._sortedMetasets = t.slice(0).sort(Io('order', 'index')) } }, { key: '_removeUnreferencedMetasets', value: function () { const t = this; const e = this._metasets; const i = this.data.datasets; e.length > i.length && delete this._stacks, e.forEach(function (e, n) { i.filter(function (t) { return t === e._dataset }).length === 0 && t._destroyDatasetMeta(n) }) } }, { key: 'buildOrUpdateControllers', value: function () { let t; let e; const i = []; const n = this.data.datasets; for (this._removeUnreferencedMetasets(), t = 0, e = n.length; t < e; t++) { const a = n[t]; let r = this.getDatasetMeta(t); const o = a.type || this.config.type; if (r.type && r.type !== o && (this._destroyDatasetMeta(t), r = this.getDatasetMeta(t)), r.type = o, r.indexAxis = a.indexAxis || go(o, this.options), r.order = a.order || 0, r.index = t, r.label = '' + a.label, r.visible = this.isDatasetVisible(t), r.controller)r.controller.updateIndex(t), r.controller.linkScales(); else { const s = lo.getController(o); const l = Ee.datasets[o]; const h = l.datasetElementType; const u = l.dataElementType; Object.assign(s.prototype, { dataElementType: lo.getElement(u), datasetElementType: h && lo.getElement(h) }), r.controller = new s(this, t), i.push(r.controller) } } return this._updateMetasets(), i } }, { key: '_resetElements', value: function () { const t = this; V(this.data.datasets, function (e, i) { t.getDatasetMeta(i).controller.reset() }, this) } }, { key: 'reset', value: function () { this._resetElements(), this.notifyPlugins('reset') } }, { key: 'update', value: function (t) { const e = this.config; e.update(); const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()); const n = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 !== this.notifyPlugins('beforeUpdate', { mode: t, cancelable: !0 })) { const a = this.buildOrUpdateControllers(); this.notifyPlugins('beforeElementsUpdate'); for (var r = 0, o = 0, s = this.data.datasets.length; o < s; o++) { const l = this.getDatasetMeta(o); const h = l.controller; const u = !n && a.indexOf(h) === -1; h.buildOrUpdateElements(u), r = Math.max(+h.getMaxOverflow(), r) }r = this._minPadding = i.layout.autoPadding ? r : 0, this._updateLayout(r), n || V(a, function (t) { t.reset() }), this._updateDatasets(t), this.notifyPlugins('afterUpdate', { mode: t }), this._layers.sort(Io('z', '_idx')); const c = this._active; const d = this._lastEvent; d ? this._eventHandler(d, !0) : c.length && this._updateHoverStyles(c, c, !0), this.render() } } }, { key: '_updateScales', value: function () { const t = this; V(this.scales, function (e) { ur.removeBox(t, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } }, { key: '_checkEventBindings', value: function () { const t = this.options; const e = new Set(Object.keys(this._listeners)); const i = new Set(t.events); et(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents()) } }, { key: '_updateHiddenIndices', value: function () { let t; const e = this._hiddenIndices; const i = this._getUniformDataChanges() || []; const n = (0, b.Z)(i); try { for (n.s(); !(t = n.n()).done;) { const a = t.value; const r = a.method; const o = a.start; const s = a.count; const l = r === '_removeElements' ? -s : s; Wo(e, o, l) } } catch (h) { n.e(h) } finally { n.f() } } }, { key: '_getUniformDataChanges', value: function () { const t = this._dataChanges; if (t && t.length) { this._dataChanges = []; for (var e = this.data.datasets.length, i = function (e) { return new Set(t.filter(function (t) { return t[0] === e }).map(function (t, e) { return e + ',' + t.splice(1).join(',') })) }, n = i(0), a = 1; a < e; a++) if (!et(n, i(a))) return; return Array.from(n).map(function (t) { return t.split(',') }).map(function (t) { return { method: t[1], start: +t[2], count: +t[3] } }) } } }, { key: '_updateLayout', value: function (t) { const e = this; if (!1 !== this.notifyPlugins('beforeLayout', { cancelable: !0 })) { ur.update(this, this.width, this.height, t); const i = this.chartArea; const n = i.width <= 0 || i.height <= 0; this._layers = [], V(this.boxes, function (t) { let i; n && t.position === 'chartArea' || (t.configure && t.configure(), (i = e._layers).push.apply(i, (0, c.Z)(t._layers()))) }, this), this._layers.forEach(function (t, e) { t._idx = e }), this.notifyPlugins('afterLayout') } } }, { key: '_updateDatasets', value: function (t) { if (!1 !== this.notifyPlugins('beforeDatasetsUpdate', { mode: t, cancelable: !0 })) { for (let e = 0, i = this.data.datasets.length; e < i; ++e) this.getDatasetMeta(e).controller.configure(); for (let n = 0, a = this.data.datasets.length; n < a; ++n) this._updateDataset(n, tt(t) ? t({ datasetIndex: n }) : t); this.notifyPlugins('afterDatasetsUpdate', { mode: t }) } } }, { key: '_updateDataset', value: function (t, e) { const i = this.getDatasetMeta(t); const n = { meta: i, index: t, mode: e, cancelable: !0 }; !1 !== this.notifyPlugins('beforeDatasetUpdate', n) && (i.controller._update(e), n.cancelable = !1, this.notifyPlugins('afterDatasetUpdate', n)) } }, { key: 'render', value: function () { !1 !== this.notifyPlugins('beforeRender', { cancelable: !0 }) && (En.has(this) ? this.attached && !En.running(this) && En.start(this) : (this.draw(), Zo({ chart: this }))) } }, { key: 'draw', value: function () { let t; if (this._resizeBeforeDraw) { const e = this._resizeBeforeDraw; const i = e.width; const n = e.height; this._resize(i, n), this._resizeBeforeDraw = null } if (this.clear(), !(this.width <= 0 || this.height <= 0) && !1 !== this.notifyPlugins('beforeDraw', { cancelable: !0 })) { const a = this._layers; for (t = 0; t < a.length && a[t].z <= 0; ++t)a[t].draw(this.chartArea); for (this._drawDatasets(); t < a.length; ++t)a[t].draw(this.chartArea); this.notifyPlugins('afterDraw') } } }, { key: '_getSortedDatasetMetas', value: function (t) { let e; let i; const n = this._sortedMetasets; const a = []; for (e = 0, i = n.length; e < i; ++e) { const r = n[e]; t && !r.visible || a.push(r) } return a } }, { key: 'getSortedVisibleDatasetMetas', value: function () { return this._getSortedDatasetMetas(!0) } }, { key: '_drawDatasets', value: function () { if (!1 !== this.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 })) { for (let t = this.getSortedVisibleDatasetMetas(), e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]); this.notifyPlugins('afterDatasetsDraw') } } }, { key: '_drawDataset', value: function (t) { const e = this.ctx; const i = t._clip; const n = !i.disabled; const a = this.chartArea; const r = { meta: t, index: t.index, cancelable: !0 }; !1 !== this.notifyPlugins('beforeDatasetDraw', r) && (n && He(e, { left: !1 === i.left ? 0 : a.left - i.left, right: !1 === i.right ? this.width : a.right + i.right, top: !1 === i.top ? 0 : a.top - i.top, bottom: !1 === i.bottom ? this.height : a.bottom + i.bottom }), t.controller.draw(), n && je(e), r.cancelable = !1, this.notifyPlugins('afterDatasetDraw', r)) } }, { key: 'isPointInArea', value: function (t) { return Ne(t, this.chartArea, this._minPadding) } }, { key: 'getElementsAtEventForMode', value: function (t, e, i, n) { const a = Ua.modes[e]; return typeof a === 'function' ? a(this, t, i, n) : [] } }, { key: 'getDatasetMeta', value: function (t) { const e = this.data.datasets[t]; const i = this._metasets; let n = i.filter(function (t) { return t && t._dataset === e }).pop(); return n || (n = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(n)), n } }, { key: 'getContext', value: function () { return this.$context || (this.$context = li(null, { chart: this, type: 'chart' })) } }, { key: 'getVisibleDatasetCount', value: function () { return this.getSortedVisibleDatasetMetas().length } }, { key: 'isDatasetVisible', value: function (t) { const e = this.data.datasets[t]; if (!e) return !1; const i = this.getDatasetMeta(t); return typeof i.hidden === 'boolean' ? !i.hidden : !e.hidden } }, { key: 'setDatasetVisibility', value: function (t, e) { const i = this.getDatasetMeta(t); i.hidden = !e } }, { key: 'toggleDataVisibility', value: function (t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } }, { key: 'getDataVisibility', value: function (t) { return !this._hiddenIndices[t] } }, { key: '_updateVisibility', value: function (t, e, i) { const n = i ? 'show' : 'hide'; const a = this.getDatasetMeta(t); const r = a.controller._resolveAnimations(void 0, n); Q(e) ? (a.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), r.update(a, { visible: i }), this.update(function (e) { return e.datasetIndex === t ? n : void 0 })) } }, { key: 'hide', value: function (t, e) { this._updateVisibility(t, e, !1) } }, { key: 'show', value: function (t, e) { this._updateVisibility(t, e, !0) } }, { key: '_destroyDatasetMeta', value: function (t) { const e = this._metasets[t]; e && e.controller && e.controller._destroy(), delete this._metasets[t] } }, { key: '_stop', value: function () { let t, e; for (this.stop(), En.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t) } }, { key: 'destroy', value: function () { this.notifyPlugins('beforeDestroy'); const t = this.canvas; const e = this.ctx; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Be(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins('destroy'), delete Bo[this.id], this.notifyPlugins('afterDestroy') } }, { key: 'toBase64Image', value: function () { let t; return (t = this.canvas).toDataURL.apply(t, arguments) } }, { key: 'bindEvents', value: function () { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } }, { key: 'bindUserEvents', value: function () { const t = this; const e = this._listeners; const i = this.platform; const n = function (n, a) { i.addEventListener(t, n, a), e[n] = a }; const a = function (e, i, n) { e.offsetX = i, e.offsetY = n, t._eventHandler(e) }; V(this.options.events, function (t) { return n(t, a) }) } }, { key: 'bindResponsiveEvents', value: function () { const t = this; this._responsiveListeners || (this._responsiveListeners = {}); let e; const i = this._responsiveListeners; const n = this.platform; const a = function (e, a) { n.addEventListener(t, e, a), i[e] = a }; const r = function (e, a) { i[e] && (n.removeEventListener(t, e, a), delete i[e]) }; const o = function (e, i) { t.canvas && t.resize(e, i) }; const s = function i () { r('attach', i), t.attached = !0, t.resize(), a('resize', o), a('detach', e) }; e = function () { t.attached = !1, r('resize', o), t._stop(), t._resize(0, 0), a('attach', s) }, n.isAttached(this.canvas) ? s() : e() } }, { key: 'unbindEvents', value: function () { const t = this; V(this._listeners, function (e, i) { t.platform.removeEventListener(t, i, e) }), this._listeners = {}, V(this._responsiveListeners, function (e, i) { t.platform.removeEventListener(t, i, e) }), this._responsiveListeners = void 0 } }, { key: 'updateHoverStyle', value: function (t, e, i) { let n; let a; let r; let o; const s = i ? 'set' : 'remove'; for (e === 'dataset' && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller['_' + s + 'DatasetHoverStyle']()), r = 0, o = t.length; r < o; ++r) { a = t[r]; const l = a && this.getDatasetMeta(a.datasetIndex).controller; l && l[s + 'HoverStyle'](a.element, a.datasetIndex, a.index) } } }, { key: 'getActiveElements', value: function () { return this._active || [] } }, { key: 'setActiveElements', value: function (t) { const e = this; const i = this._active || []; const n = t.map(function (t) { const i = t.datasetIndex; const n = t.index; const a = e.getDatasetMeta(i); if (!a) throw new Error('No dataset found at index ' + i); return { datasetIndex: i, element: a.data[n], index: n } }); const a = !W(n, i); a && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, i)) } }, { key: 'notifyPlugins', value: function (t, e, i) { return this._plugins.notify(this, t, e, i) } }, { key: '_updateHoverStyles', value: function (t, e, i) { const n = this.options.hover; const a = function (t, e) { return t.filter(function (t) { return !e.some(function (e) { return t.datasetIndex === e.datasetIndex && t.index === e.index }) }) }; const r = a(e, t); const o = i ? t : a(t, e); r.length && this.updateHoverStyle(r, n.mode, !1), o.length && n.mode && this.updateHoverStyle(o, n.mode, !0) } }, { key: '_eventHandler', value: function (t, e) { const i = this; const n = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) }; const a = function (e) { return (e.options.events || i.options.events).includes(t.native.type) }; if (!1 !== this.notifyPlugins('beforeEvent', n, a)) { const r = this._handleEvent(t, e, n.inChartArea); return n.cancelable = !1, this.notifyPlugins('afterEvent', n, a), (r || n.changed) && this.render(), this } } }, { key: '_handleEvent', value: function (t, e, i) { const n = this._active; const a = void 0 === n ? [] : n; const r = this.options; const o = e; const s = this._getActiveElements(t, a, i, o); const l = it(t); const h = No(t, this._lastEvent, i, l); i && (this._lastEvent = null, B(r.onHover, [t, s, this], this), l && B(r.onClick, [t, s, this], this)); const u = !W(s, a); return (u || e) && (this._active = s, this._updateHoverStyles(s, a, e)), this._lastEvent = h, u } }, { key: '_getActiveElements', value: function (t, e, i, n) { if (t.type === 'mouseout') return []; if (!i) return e; const a = this.options.hover; return this.getElementsAtEventForMode(t, a.mode, a, n) } }]), t }()); const jo = function () { return V(Ho.instances, function (t) { return t._plugins.invalidate() }) }; const $o = !0; function Yo (t, e, i) { const n = e.startAngle; const a = e.pixelMargin; const r = e.x; const o = e.y; const s = e.outerRadius; const l = e.innerRadius; let h = a / s; t.beginPath(), t.arc(r, o, s, n - h, i + h), l > a ? (h = a / l, t.arc(r, o, l, i + h, n - h, !0)) : t.arc(r, o, a, i + lt, n - lt), t.closePath(), t.clip() } function Uo (t) { return ei(t, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']) } function Xo (t, e, i, n) { const a = Uo(t.options.borderRadius); const r = (i - e) / 2; const o = Math.min(r, n * e / 2); const s = function (t) { const e = (i - Math.min(r, t)) * n / 2; return Ct(t, 0, Math.min(r, e)) }; return { outerStart: s(a.outerStart), outerEnd: s(a.outerEnd), innerStart: Ct(a.innerStart, 0, o), innerEnd: Ct(a.innerEnd, 0, o) } } function qo (t, e, i, n) { return { x: i + t * Math.cos(e), y: n + t * Math.sin(e) } } function Ko (t, e, i, n, a) { const r = e.x; const o = e.y; const s = e.startAngle; const l = e.pixelMargin; const h = e.innerRadius; const u = Math.max(e.outerRadius + n + i - l, 0); const c = h > 0 ? h + n + i + l : 0; let d = 0; const f = a - s; if (n) { const v = h > 0 ? h - n : 0; const g = u > 0 ? u - n : 0; const p = (v + g) / 2; const y = p !== 0 ? f * p / (p + n) : f; d = (f - y) / 2 } const m = Math.max(0.001, f * u - i / nt) / u; const b = (f - m) / 2; const x = s + b + d; const _ = a - b - d; const k = Xo(e, c, u, _ - x); const w = k.outerStart; const M = k.outerEnd; const S = k.innerStart; const P = k.innerEnd; const C = u - w; const D = u - M; const O = x + w / C; const A = _ - M / D; const T = c + S; const L = c + P; const R = x + S / T; const E = _ - P / L; if (t.beginPath(), t.arc(r, o, u, O, A), M > 0) { const I = qo(D, A, r, o); t.arc(I.x, I.y, M, A, _ + lt) } const Z = qo(L, _, r, o); if (t.lineTo(Z.x, Z.y), P > 0) { const z = qo(L, E, r, o); t.arc(z.x, z.y, P, _ + lt, E + Math.PI) } if (t.arc(r, o, c, _ - P / c, x + S / c, !0), S > 0) { const F = qo(T, R, r, o); t.arc(F.x, F.y, S, R + Math.PI, x - lt) } const B = qo(C, x, r, o); if (t.lineTo(B.x, B.y), w > 0) { const V = qo(C, O, r, o); t.arc(V.x, V.y, w, x - lt, O) }t.closePath() } function Go (t, e, i, n) { const a = e.fullCircles; const r = e.startAngle; const o = e.circumference; let s = e.endAngle; if (a) { Ko(t, e, i, n, r + at); for (let l = 0; l < a; ++l)t.fill(); isNaN(o) || (s = r + o % at, o % at === 0 && (s += at)) } return Ko(t, e, i, n, s), t.fill(), s } function Jo (t, e, i) { let n; const a = e.x; const r = e.y; const o = e.startAngle; const s = e.pixelMargin; const l = e.fullCircles; const h = Math.max(e.outerRadius - s, 0); const u = e.innerRadius + s; for (i && Yo(t, e, o + at), t.beginPath(), t.arc(a, r, u, o + at, o, !0), n = 0; n < l; ++n)t.stroke(); for (t.beginPath(), t.arc(a, r, h, o, o + at), n = 0; n < l; ++n)t.stroke() } function Qo (t, e, i, n, a) { const r = e.options; const o = r.borderWidth; const s = r.borderJoinStyle; const l = r.borderAlign === 'inner'; o && (l ? (t.lineWidth = 2 * o, t.lineJoin = s || 'round') : (t.lineWidth = o, t.lineJoin = s || 'bevel'), e.fullCircles && Jo(t, e, l), l && Yo(t, e, a), Ko(t, e, i, n, a), t.stroke()) }Object.defineProperties(Ho, { defaults: { enumerable: $o, value: Ee }, instances: { enumerable: $o, value: Bo }, overrides: { enumerable: $o, value: Oe }, registry: { enumerable: $o, value: lo }, version: { enumerable: $o, value: Lo }, getChart: { enumerable: $o, value: Vo }, register: { enumerable: $o, value: function () { lo.add.apply(lo, arguments), jo() } }, unregister: { enumerable: $o, value: function () { lo.remove.apply(lo, arguments), jo() } } }); const ts = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.options = void 0, n.circumference = void 0, n.startAngle = void 0, n.endAngle = void 0, n.innerRadius = void 0, n.outerRadius = void 0, n.pixelMargin = 0, n.fullCircles = 0, t && Object.assign((0, d.Z)(n), t), n } return (0, k.Z)(i, [{ key: 'inRange', value: function (t, e, i) { const n = this.getProps(['x', 'y'], i); const a = kt(n, { x: t, y: e }); const r = a.angle; const o = a.distance; const s = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], i); const l = s.startAngle; const h = s.endAngle; const u = s.innerRadius; const c = s.outerRadius; const d = s.circumference; const f = this.options.spacing / 2; const v = Z(d, h - l); const g = v >= at || Pt(r, l, h); const p = Ot(o, u + f, c + f); return g && p } }, { key: 'getCenterPoint', value: function (t) { const e = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], t); const i = e.x; const n = e.y; const a = e.startAngle; const r = e.endAngle; const o = e.innerRadius; const s = e.outerRadius; const l = this.options; const h = l.offset; const u = l.spacing; const c = (a + r) / 2; const d = (o + s + u + h) / 2; return { x: i + Math.cos(c) * d, y: n + Math.sin(c) * d } } }, { key: 'tooltipPosition', value: function (t) { return this.getCenterPoint(t) } }, { key: 'draw', value: function (t) { const e = this.options; const i = this.circumference; const n = (e.offset || 0) / 2; const a = (e.spacing || 0) / 2; if (this.pixelMargin = e.borderAlign === 'inner' ? 0.33 : 0, this.fullCircles = i > at ? Math.floor(i / at) : 0, !(i === 0 || this.innerRadius < 0 || this.outerRadius < 0)) { t.save(); let r = 0; if (n) { r = n / 2; const o = (this.startAngle + this.endAngle) / 2; t.translate(Math.cos(o) * r, Math.sin(o) * r), this.circumference >= nt && (r = n) }t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor; const s = Go(t, this, r, a); Qo(t, this, r, a, s), t.restore() } } }]), i }(Er)); function es (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e; t.lineCap = Z(i.borderCapStyle, e.borderCapStyle), t.setLineDash(Z(i.borderDash, e.borderDash)), t.lineDashOffset = Z(i.borderDashOffset, e.borderDashOffset), t.lineJoin = Z(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = Z(i.borderWidth, e.borderWidth), t.strokeStyle = Z(i.borderColor, e.borderColor) } function is (t, e, i) { t.lineTo(i.x, i.y) } function ns (t) { return t.stepped ? $e : t.tension || t.cubicInterpolationMode === 'monotone' ? Ye : is } function as (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const n = t.length; const a = i.start; const r = void 0 === a ? 0 : a; const o = i.end; const s = void 0 === o ? n - 1 : o; const l = e.start; const h = e.end; const u = Math.max(r, l); const c = Math.min(s, h); const d = r < l && s < l || r > h && s > h; return { count: n, start: u, loop: e.loop, ilen: c < u && !d ? n + c - u : c - u } } function rs (t, e, i, n) { let a; let r; let o; const s = e.points; const l = e.options; const h = as(s, i, n); const u = h.count; const c = h.start; const d = h.loop; const f = h.ilen; const v = ns(l); const g = n || {}; const p = g.move; let y = void 0 === p || p; const m = g.reverse; for (a = 0; a <= f; ++a)r = s[(c + (m ? f - a : a)) % u], r.skip || (y ? (t.moveTo(r.x, r.y), y = !1) : v(t, o, r, m, l.stepped), o = r); return d && (r = s[(c + (m ? f : 0)) % u], v(t, o, r, m, l.stepped)), !!d } function os (t, e, i, n) { let a; let r; let o; let s; let l; let h; const u = e.points; const c = as(u, i, n); const d = c.count; const f = c.start; const v = c.ilen; const g = n || {}; const p = g.move; const y = void 0 === p || p; const m = g.reverse; let b = 0; let x = 0; const _ = function (t) { return (f + (m ? v - t : t)) % d }; const k = function () { s !== l && (t.lineTo(b, l), t.lineTo(b, s), t.lineTo(b, h)) }; for (y && (r = u[_(0)], t.moveTo(r.x, r.y)), a = 0; a <= v; ++a) if (r = u[_(a)], !r.skip) { const w = r.x; const M = r.y; const S = 0 | w; S === o ? (M < s ? s = M : M > l && (l = M), b = (x * b + w) / ++x) : (k(), t.lineTo(w, M), o = S, x = 0, s = l = M), h = M }k() } function ss (t) { const e = t.options; const i = e.borderDash && e.borderDash.length; const n = !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== 'monotone' && !e.stepped && !i; return n ? os : rs } function ls (t) { return t.stepped ? cn : t.tension || t.cubicInterpolationMode === 'monotone' ? dn : un } function hs (t, e, i, n) { let a = e._path; a || (a = e._path = new Path2D(), e.path(a, i, n) && a.closePath()), es(t, e.options), t.stroke(a) } function us (t, e, i, n) { let a; const r = e.segments; const o = e.options; const s = ss(e); const l = (0, b.Z)(r); try { for (l.s(); !(a = l.n()).done;) { const h = a.value; es(t, o, h.style), t.beginPath(), s(t, e, h, { start: i, end: i + n - 1 }) && t.closePath(), t.stroke() } } catch (u) { l.e(u) } finally { l.f() } }ts.id = 'arc', ts.defaults = { borderAlign: 'center', borderColor: '#fff', borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0 }, ts.defaultRoutes = { backgroundColor: 'backgroundColor' }; const cs = typeof Path2D === 'function'; function ds (t, e, i, n) { cs && !e.options.segment ? hs(t, e, i, n) : us(t, e, i, n) } const fs = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.animated = !0, n.options = void 0, n._chart = void 0, n._loop = void 0, n._fullLoop = void 0, n._path = void 0, n._points = void 0, n._segments = void 0, n._decimated = !1, n._pointsUpdated = !1, n._datasetIndex = void 0, t && Object.assign((0, d.Z)(n), t), n } return (0, k.Z)(i, [{ key: 'updateControlPoints', value: function (t, e) { const i = this.options; if ((i.tension || i.cubicInterpolationMode === 'monotone') && !i.stepped && !this._pointsUpdated) { const n = i.spanGaps ? this._loop : this._fullLoop; Yi(this._points, i, t, n, e), this._pointsUpdated = !0 } } }, { key: 'points', get: function () { return this._points }, set: function (t) { this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1 } }, { key: 'segments', get: function () { return this._segments || (this._segments = Dn(this, this.options.segment)) } }, { key: 'first', value: function () { const t = this.segments; const e = this.points; return t.length && e[t[0].start] } }, { key: 'last', value: function () { const t = this.segments; const e = this.points; const i = t.length; return i && e[t[i - 1].end] } }, { key: 'interpolate', value: function (t, e) { const i = this.options; const n = t[e]; const a = this.points; const r = Sn(this, { property: e, start: n, end: n }); if (r.length) { let o; let s; const l = []; const h = ls(i); for (o = 0, s = r.length; o < s; ++o) { const u = r[o]; const c = u.start; const d = u.end; const f = a[c]; const v = a[d]; if (f !== v) { const g = Math.abs((n - f[e]) / (v[e] - f[e])); const p = h(f, v, g, i.stepped); p[e] = t[e], l.push(p) } else l.push(f) } return l.length === 1 ? l[0] : l } } }, { key: 'pathSegment', value: function (t, e, i) { const n = ss(this); return n(t, this, e, i) } }, { key: 'path', value: function (t, e, i) { const n = this.segments; const a = ss(this); let r = this._loop; e = e || 0, i = i || this.points.length - e; let o; const s = (0, b.Z)(n); try { for (s.s(); !(o = s.n()).done;) { const l = o.value; r &= a(t, this, l, { start: e, end: e + i - 1 }) } } catch (h) { s.e(h) } finally { s.f() } return !!r } }, { key: 'draw', value: function (t, e, i, n) { const a = this.options || {}; const r = this.points || []; r.length && a.borderWidth && (t.save(), ds(t, this, i, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } }]), i }(Er)); function vs (t, e, i, n) { const a = t.options; const r = t.getProps([i], n); const o = r[i]; return Math.abs(e - o) < a.radius + a.hitRadius }fs.id = 'line', fs.defaults = { borderCapStyle: 'butt', borderDash: [], borderDashOffset: 0, borderJoinStyle: 'miter', borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: 'default', fill: !1, spanGaps: !1, stepped: !1, tension: 0 }, fs.defaultRoutes = { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }, fs.descriptors = { _scriptable: !0, _indexable: function (t) { return t !== 'borderDash' && t !== 'fill' } }; const gs = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.options = void 0, n.parsed = void 0, n.skip = void 0, n.stop = void 0, t && Object.assign((0, d.Z)(n), t), n } return (0, k.Z)(i, [{ key: 'inRange', value: function (t, e, i) { const n = this.options; const a = this.getProps(['x', 'y'], i); const r = a.x; const o = a.y; return Math.pow(t - r, 2) + Math.pow(e - o, 2) < Math.pow(n.hitRadius + n.radius, 2) } }, { key: 'inXRange', value: function (t, e) { return vs(this, t, 'x', e) } }, { key: 'inYRange', value: function (t, e) { return vs(this, t, 'y', e) } }, { key: 'getCenterPoint', value: function (t) { const e = this.getProps(['x', 'y'], t); const i = e.x; const n = e.y; return { x: i, y: n } } }, { key: 'size', value: function (t) { t = t || this.options || {}; let e = t.radius || 0; e = Math.max(e, e && t.hoverRadius || 0); const i = e && t.borderWidth || 0; return 2 * (e + i) } }, { key: 'draw', value: function (t, e) { const i = this.options; this.skip || i.radius < 0.1 || !Ne(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Ve(t, i, this.x, this.y)) } }, { key: 'getRange', value: function () { const t = this.options || {}; return t.radius + t.hitRadius } }]), i }(Er)); function ps (t, e) { let i; let n; let a; let r; let o; const s = t.getProps(['x', 'y', 'base', 'width', 'height'], e); const l = s.x; const h = s.y; const u = s.base; const c = s.width; const d = s.height; return t.horizontal ? (o = d / 2, i = Math.min(l, u), n = Math.max(l, u), a = h - o, r = h + o) : (o = c / 2, i = l - o, n = l + o, a = Math.min(h, u), r = Math.max(h, u)), { left: i, top: a, right: n, bottom: r } } function ys (t, e, i, n) { return t ? 0 : Ct(e, i, n) } function ms (t, e, i) { const n = t.options.borderWidth; const a = t.borderSkipped; const r = ii(n); return { t: ys(a.top, r.top, 0, i), r: ys(a.right, r.right, 0, e), b: ys(a.bottom, r.bottom, 0, i), l: ys(a.left, r.left, 0, e) } } function bs (t, e, i) { const n = t.getProps(['enableBorderRadius']); const a = n.enableBorderRadius; const r = t.options.borderRadius; const o = ni(r); const s = Math.min(e, i); const l = t.borderSkipped; const h = a || R(r); return { topLeft: ys(!h || l.top || l.left, o.topLeft, 0, s), topRight: ys(!h || l.top || l.right, o.topRight, 0, s), bottomLeft: ys(!h || l.bottom || l.left, o.bottomLeft, 0, s), bottomRight: ys(!h || l.bottom || l.right, o.bottomRight, 0, s) } } function xs (t) { const e = ps(t); const i = e.right - e.left; const n = e.bottom - e.top; const a = ms(t, i / 2, n / 2); const r = bs(t, i / 2, n / 2); return { outer: { x: e.left, y: e.top, w: i, h: n, radius: r }, inner: { x: e.left + a.l, y: e.top + a.t, w: i - a.l - a.r, h: n - a.t - a.b, radius: { topLeft: Math.max(0, r.topLeft - Math.max(a.t, a.l)), topRight: Math.max(0, r.topRight - Math.max(a.t, a.r)), bottomLeft: Math.max(0, r.bottomLeft - Math.max(a.b, a.l)), bottomRight: Math.max(0, r.bottomRight - Math.max(a.b, a.r)) } } } } function _s (t, e, i, n) { const a = e === null; const r = i === null; const o = a && r; const s = t && !o && ps(t, n); return s && (a || Ot(e, s.left, s.right)) && (r || Ot(i, s.top, s.bottom)) } function ks (t) { return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight } function ws (t, e) { t.rect(e.x, e.y, e.w, e.h) } function Ms (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const n = t.x !== i.x ? -e : 0; const a = t.y !== i.y ? -e : 0; const r = (t.x + t.w !== i.x + i.w ? e : 0) - n; const o = (t.y + t.h !== i.y + i.h ? e : 0) - a; return { x: t.x + n, y: t.y + a, w: t.w + r, h: t.h + o, radius: t.radius } }gs.id = 'point', gs.defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: 'circle', radius: 3, rotation: 0 }, gs.defaultRoutes = { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }; const Ss = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.options = void 0, n.horizontal = void 0, n.base = void 0, n.width = void 0, n.height = void 0, n.inflateAmount = void 0, t && Object.assign((0, d.Z)(n), t), n } return (0, k.Z)(i, [{ key: 'draw', value: function (t) { const e = this.inflateAmount; const i = this.options; const n = i.borderColor; const a = i.backgroundColor; const r = xs(this); const o = r.inner; const s = r.outer; const l = ks(s.radius) ? Ke : ws; t.save(), s.w === o.w && s.h === o.h || (t.beginPath(), l(t, Ms(s, e, o)), t.clip(), l(t, Ms(o, -e, s)), t.fillStyle = n, t.fill('evenodd')), t.beginPath(), l(t, Ms(o, e)), t.fillStyle = a, t.fill(), t.restore() } }, { key: 'inRange', value: function (t, e, i) { return _s(this, t, e, i) } }, { key: 'inXRange', value: function (t, e) { return _s(this, t, null, e) } }, { key: 'inYRange', value: function (t, e) { return _s(this, null, t, e) } }, { key: 'getCenterPoint', value: function (t) { const e = this.getProps(['x', 'y', 'base', 'horizontal'], t); const i = e.x; const n = e.y; const a = e.base; const r = e.horizontal; return { x: r ? (i + a) / 2 : i, y: r ? n : (n + a) / 2 } } }, { key: 'getRange', value: function (t) { return t === 'x' ? this.width / 2 : this.height / 2 } }]), i }(Er)); Ss.id = 'bar', Ss.defaults = { borderSkipped: 'start', borderWidth: 0, borderRadius: 0, inflateAmount: 'auto', pointStyle: void 0 }, Ss.defaultRoutes = { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }; const Ps = function (t, e) { const i = t.boxHeight; let n = void 0 === i ? e : i; const a = t.boxWidth; let r = void 0 === a ? e : a; return t.usePointStyle && (n = Math.min(n, e), r = t.pointStyleWidth || Math.min(r, e)), { boxWidth: r, boxHeight: n, itemHeight: Math.max(e, n) } }; const Cs = function (t, e) { return t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index }; const Ds = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n._added = !1, n.legendHitBoxes = [], n._hoveredItem = null, n.doughnutMode = !1, n.chart = t.chart, n.options = t.options, n.ctx = t.ctx, n.legendItems = void 0, n.columnSizes = void 0, n.lineWidths = void 0, n.maxHeight = void 0, n.maxWidth = void 0, n.top = void 0, n.bottom = void 0, n.left = void 0, n.right = void 0, n.height = void 0, n.width = void 0, n._margins = void 0, n.position = void 0, n.weight = void 0, n.fullSize = void 0, n } return (0, k.Z)(i, [{ key: 'update', value: function (t, e, i) { this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } }, { key: 'setDimensions', value: function () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } }, { key: 'buildLabels', value: function () { const t = this; const e = this.options.labels || {}; let i = B(e.generateLabels, [this.chart], this) || []; e.filter && (i = i.filter(function (i) { return e.filter(i, t.chart.data) })), e.sort && (i = i.sort(function (i, n) { return e.sort(i, n, t.chart.data) })), this.options.reverse && i.reverse(), this.legendItems = i } }, { key: 'fit', value: function () { const t = this.options; const e = this.ctx; if (t.display) { let i; let n; const a = t.labels; const r = ri(a.font); const o = r.size; const s = this._computeTitleHeight(); const l = Ps(a, o); const h = l.boxWidth; const u = l.itemHeight; e.font = r.string, this.isHorizontal() ? (i = this.maxWidth, n = this._fitRows(s, o, h, u) + 10) : (n = this.maxHeight, i = this._fitCols(s, o, h, u) + 10), this.width = Math.min(i, t.maxWidth || this.maxWidth), this.height = Math.min(n, t.maxHeight || this.maxHeight) } else this.width = this.height = 0 } }, { key: '_fitRows', value: function (t, e, i, n) { const a = this.ctx; const r = this.maxWidth; const o = this.options.labels.padding; const s = this.legendHitBoxes = []; const l = this.lineWidths = [0]; const h = n + o; let u = t; a.textAlign = 'left', a.textBaseline = 'middle'; let c = -1; let d = -h; return this.legendItems.forEach(function (t, f) { const v = i + e / 2 + a.measureText(t.text).width; (f === 0 || l[l.length - 1] + v + 2 * o > r) && (u += h, l[l.length - (f > 0 ? 0 : 1)] = 0, d += h, c++), s[f] = { left: 0, top: d, row: c, width: v, height: n }, l[l.length - 1] += v + o }), u } }, { key: '_fitCols', value: function (t, e, i, n) { const a = this.ctx; const r = this.maxHeight; const o = this.options.labels.padding; const s = this.legendHitBoxes = []; const l = this.columnSizes = []; const h = r - t; let u = o; let c = 0; let d = 0; let f = 0; let v = 0; return this.legendItems.forEach(function (t, r) { const g = i + e / 2 + a.measureText(t.text).width; r > 0 && d + n + 2 * o > h && (u += c + o, l.push({ width: c, height: d }), f += c + o, v++, c = d = 0), s[r] = { left: f, top: d, col: v, width: g, height: n }, c = Math.max(c, g), d += n + o }), u += c, l.push({ width: c, height: d }), u } }, { key: 'adjustHitBoxes', value: function () { if (this.options.display) { const t = this._computeTitleHeight(); const e = this.legendHitBoxes; const i = this.options; const n = i.align; const a = i.labels.padding; const r = i.rtl; const o = mn(r, this.left, this.width); if (this.isHorizontal()) { let s; let l = 0; let h = C(n, this.left + a, this.right - this.lineWidths[l]); const u = (0, b.Z)(e); try { for (u.s(); !(s = u.n()).done;) { const c = s.value; l !== c.row && (l = c.row, h = C(n, this.left + a, this.right - this.lineWidths[l])), c.top += this.top + t + a, c.left = o.leftForLtr(o.x(h), c.width), h += c.width + a } } catch (y) { u.e(y) } finally { u.f() } } else { let d; let f = 0; let v = C(n, this.top + t + a, this.bottom - this.columnSizes[f].height); const g = (0, b.Z)(e); try { for (g.s(); !(d = g.n()).done;) { const p = d.value; p.col !== f && (f = p.col, v = C(n, this.top + t + a, this.bottom - this.columnSizes[f].height)), p.top = v, p.left += this.left + a, p.left = o.leftForLtr(o.x(p.left), p.width), v += p.height + a } } catch (y) { g.e(y) } finally { g.f() } } } } }, { key: 'isHorizontal', value: function () { return this.options.position === 'top' || this.options.position === 'bottom' } }, { key: 'draw', value: function () { if (this.options.display) { const t = this.ctx; He(t, this), this._draw(), je(t) } } }, { key: '_draw', value: function () { let t; const e = this; const i = this.options; const n = this.columnSizes; const a = this.lineWidths; const r = this.ctx; const o = i.align; const s = i.labels; const l = Ee.color; const h = mn(i.rtl, this.left, this.width); const u = ri(s.font); const c = s.color; const d = s.padding; const f = u.size; const v = f / 2; this.drawTitle(), r.textAlign = h.textAlign('left'), r.textBaseline = 'middle', r.lineWidth = 0.5, r.font = u.string; const g = Ps(s, f); const p = g.boxWidth; const y = g.boxHeight; const m = g.itemHeight; const b = function (t, e, i) { if (!(isNaN(p) || p <= 0 || isNaN(y) || y < 0)) { r.save(); const n = Z(i.lineWidth, 1); if (r.fillStyle = Z(i.fillStyle, l), r.lineCap = Z(i.lineCap, 'butt'), r.lineDashOffset = Z(i.lineDashOffset, 0), r.lineJoin = Z(i.lineJoin, 'miter'), r.lineWidth = n, r.strokeStyle = Z(i.strokeStyle, l), r.setLineDash(Z(i.lineDash, [])), s.usePointStyle) { const a = { radius: y * Math.SQRT2 / 2, pointStyle: i.pointStyle, rotation: i.rotation, borderWidth: n }; const o = h.xPlus(t, p / 2); const u = e + v; We(r, a, o, u, p) } else { const c = e + Math.max((f - y) / 2, 0); const d = h.leftForLtr(t, p); const g = ni(i.borderRadius); r.beginPath(), Object.values(g).some(function (t) { return t !== 0 }) ? Ke(r, { x: d, y: c, w: p, h: y, radius: g }) : r.rect(d, c, p, y), r.fill(), n !== 0 && r.stroke() }r.restore() } }; const x = function (t, e, i) { Ue(r, i.text, t, e + m / 2, u, { strikethrough: i.hidden, textAlign: h.textAlign(i.textAlign) }) }; const _ = this.isHorizontal(); const k = this._computeTitleHeight(); t = _ ? { x: C(o, this.left + d, this.right - a[0]), y: this.top + d + k, line: 0 } : { x: this.left + d, y: C(o, this.top + k + d, this.bottom - n[0].height), line: 0 }, bn(this.ctx, i.textDirection); const w = m + d; this.legendItems.forEach(function (l, u) { r.strokeStyle = l.fontColor || c, r.fillStyle = l.fontColor || c; const f = r.measureText(l.text).width; const g = h.textAlign(l.textAlign || (l.textAlign = s.textAlign)); const y = p + v + f; let m = t.x; let M = t.y; h.setWidth(e.width), _ ? u > 0 && m + y + d > e.right && (M = t.y += w, t.line++, m = t.x = C(o, e.left + d, e.right - a[t.line])) : u > 0 && M + w > e.bottom && (m = t.x = m + n[t.line].width + d, t.line++, M = t.y = C(o, e.top + k + d, e.bottom - n[t.line].height)); const S = h.x(m); b(S, M, l), m = D(g, m + p + v, _ ? m + y : e.right, i.rtl), x(h.x(m), M, l), _ ? t.x += y + d : t.y += w }), xn(this.ctx, i.textDirection) } }, { key: 'drawTitle', value: function () { const t = this.options; const e = t.title; const i = ri(e.font); const n = ai(e.padding); if (e.display) { let a; const r = mn(t.rtl, this.left, this.width); const o = this.ctx; const s = e.position; const l = i.size / 2; const h = n.top + l; let u = this.left; let d = this.width; if (this.isHorizontal())d = Math.max.apply(Math, (0, c.Z)(this.lineWidths)), a = this.top + h, u = C(t.align, u, this.right - d); else { const f = this.columnSizes.reduce(function (t, e) { return Math.max(t, e.height) }, 0); a = h + C(t.align, this.top, this.bottom - f - t.labels.padding - this._computeTitleHeight()) } const v = C(s, u, u + d); o.textAlign = r.textAlign(P(s)), o.textBaseline = 'middle', o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ue(o, e.text, v, a, i) } } }, { key: '_computeTitleHeight', value: function () { const t = this.options.title; const e = ri(t.font); const i = ai(t.padding); return t.display ? e.lineHeight + i.height : 0 } }, { key: '_getLegendItemAt', value: function (t, e) { let i, n, a; if (Ot(t, this.left, this.right) && Ot(e, this.top, this.bottom)) for (a = this.legendHitBoxes, i = 0; i < a.length; ++i) if (n = a[i], Ot(t, n.left, n.left + n.width) && Ot(e, n.top, n.top + n.height)) return this.legendItems[i]; return null } }, { key: 'handleEvent', value: function (t) { const e = this.options; if (Os(t.type, e)) { const i = this._getLegendItemAt(t.x, t.y); if (t.type === 'mousemove' || t.type === 'mouseout') { const n = this._hoveredItem; const a = Cs(n, i); n && !a && B(e.onLeave, [t, n, this], this), this._hoveredItem = i, i && !a && B(e.onHover, [t, i, this], this) } else i && B(e.onClick, [t, i, this], this) } } }]), i }(Er)); function Os (t, e) { return !(t !== 'mousemove' && t !== 'mouseout' || !e.onHover && !e.onLeave) || !(!e.onClick || t !== 'click' && t !== 'mouseup') } const As = { id: 'legend', _element: Ds, start: function (t, e, i) { const n = t.legend = new Ds({ ctx: t.ctx, options: i, chart: t }); ur.configure(t, n, i), ur.addBox(t, n) }, stop: function (t) { ur.removeBox(t, t.legend), delete t.legend }, beforeUpdate: function (t, e, i) { const n = t.legend; ur.configure(t, n, i), n.options = i }, afterUpdate: function (t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent: function (t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: 'top', align: 'center', fullSize: !0, reverse: !1, weight: 1e3, onClick: function (t, e, i) { const n = e.datasetIndex; const a = i.chart; a.isDatasetVisible(n) ? (a.hide(n), e.hidden = !0) : (a.show(n), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: function (t) { return t.chart.options.color }, boxWidth: 40, padding: 10, generateLabels: function (t) { const e = t.data.datasets; const i = t.legend.options.labels; const n = i.usePointStyle; const a = i.pointStyle; const r = i.textAlign; const o = i.color; return t._getSortedDatasetMetas().map(function (t) { const i = t.controller.getStyle(n ? 0 : void 0); const s = ai(i.borderWidth); return { text: e[t.index].label, fillStyle: i.backgroundColor, fontColor: o, hidden: !t.visible, lineCap: i.borderCapStyle, lineDash: i.borderDash, lineDashOffset: i.borderDashOffset, lineJoin: i.borderJoinStyle, lineWidth: (s.width + s.height) / 4, strokeStyle: i.borderColor, pointStyle: a || i.pointStyle, rotation: i.rotation, textAlign: r || i.textAlign, borderRadius: 0, datasetIndex: t.index } }, this) } }, title: { color: function (t) { return t.chart.options.color }, display: !1, position: 'center', text: '' } }, descriptors: { _scriptable: function (t) { return !t.startsWith('on') }, labels: { _scriptable: function (t) { return !['generateLabels', 'filter', 'sort'].includes(t) } } } }; const Ts = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.chart = t.chart, n.options = t.options, n.ctx = t.ctx, n._padding = void 0, n.top = void 0, n.bottom = void 0, n.left = void 0, n.right = void 0, n.width = void 0, n.height = void 0, n.position = void 0, n.weight = void 0, n.fullSize = void 0, n } return (0, k.Z)(i, [{ key: 'update', value: function (t, e) { const i = this.options; if (this.left = 0, this.top = 0, i.display) { this.width = this.right = t, this.height = this.bottom = e; const n = L(i.text) ? i.text.length : 1; this._padding = ai(i.padding); const a = n * ri(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = a : this.width = a } else this.width = this.height = this.right = this.bottom = 0 } }, { key: 'isHorizontal', value: function () { const t = this.options.position; return t === 'top' || t === 'bottom' } }, { key: '_drawArgs', value: function (t) { let e; let i; let n; const a = this.top; const r = this.left; const o = this.bottom; const s = this.right; const l = this.options; const h = l.align; let u = 0; return this.isHorizontal() ? (i = C(h, r, s), n = a + t, e = s - r) : (l.position === 'left' ? (i = r + t, n = C(h, o, a), u = -0.5 * nt) : (i = s - t, n = C(h, a, o), u = 0.5 * nt), e = o - a), { titleX: i, titleY: n, maxWidth: e, rotation: u } } }, { key: 'draw', value: function () { const t = this.ctx; const e = this.options; if (e.display) { const i = ri(e.font); const n = i.lineHeight; const a = n / 2 + this._padding.top; const r = this._drawArgs(a); const o = r.titleX; const s = r.titleY; const l = r.maxWidth; const h = r.rotation; Ue(t, e.text, 0, 0, i, { color: e.color, maxWidth: l, rotation: h, textAlign: P(e.align), textBaseline: 'middle', translation: [o, s] }) } } }]), i }(Er)); function Ls (t, e) { const i = new Ts({ ctx: t.ctx, options: e, chart: t }); ur.configure(t, i, e), ur.addBox(t, i), t.titleBlock = i } const Rs = { id: 'title', _element: Ts, start: function (t, e, i) { Ls(t, i) }, stop: function (t) { const e = t.titleBlock; ur.removeBox(t, e), delete t.titleBlock }, beforeUpdate: function (t, e, i) { const n = t.titleBlock; ur.configure(t, n, i), n.options = i }, defaults: { align: 'center', display: !1, font: { weight: 'bold' }, fullSize: !0, padding: 10, position: 'top', text: '', weight: 2e3 }, defaultRoutes: { color: 'color' }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Es = (new WeakMap(), { average: function (t) { if (!t.length) return !1; let e; let i; let n = 0; let a = 0; let r = 0; for (e = 0, i = t.length; e < i; ++e) { const o = t[e].element; if (o && o.hasValue()) { const s = o.tooltipPosition(); n += s.x, a += s.y, ++r } } return { x: n / r, y: a / r } }, nearest: function (t, e) { if (!t.length) return !1; let i; let n; let a; let r = e.x; let o = e.y; let s = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { const l = t[i].element; if (l && l.hasValue()) { const h = l.getCenterPoint(); const u = wt(e, h); u < s && (s = u, a = l) } } if (a) { const c = a.tooltipPosition(); r = c.x, o = c.y } return { x: r, y: o } } }); function Is (t, e) { return e && (L(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function Zs (t) { return (typeof t === 'string' || t instanceof String) && t.indexOf('\n') > -1 ? t.split('\n') : t } function zs (t, e) { const i = e.element; const n = e.datasetIndex; const a = e.index; const r = t.getDatasetMeta(n).controller; const o = r.getLabelAndValue(a); const s = o.label; const l = o.value; return { chart: t, label: s, parsed: r.getParsed(a), raw: t.data.datasets[n].data[a], formattedValue: l, dataset: r.getDataset(), dataIndex: a, datasetIndex: n, element: i } } function Fs (t, e) { const i = t.chart.ctx; const n = t.body; const a = t.footer; const r = t.title; const o = e.boxWidth; const s = e.boxHeight; const l = ri(e.bodyFont); const h = ri(e.titleFont); const u = ri(e.footerFont); const c = r.length; const d = a.length; const f = n.length; const v = ai(e.padding); let g = v.height; let p = 0; let y = n.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0); if (y += t.beforeBody.length + t.afterBody.length, c && (g += c * h.lineHeight + (c - 1) * e.titleSpacing + e.titleMarginBottom), y) { const m = e.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight; g += f * m + (y - f) * l.lineHeight + (y - 1) * e.bodySpacing }d && (g += e.footerMarginTop + d * u.lineHeight + (d - 1) * e.footerSpacing); let b = 0; const x = function (t) { p = Math.max(p, i.measureText(t).width + b) }; return i.save(), i.font = h.string, V(t.title, x), i.font = l.string, V(t.beforeBody.concat(t.afterBody), x), b = e.displayColors ? o + 2 + e.boxPadding : 0, V(n, function (t) { V(t.before, x), V(t.lines, x), V(t.after, x) }), b = 0, i.font = u.string, V(t.footer, x), i.restore(), p += v.width, { width: p, height: g } } function Bs (t, e) { const i = e.y; const n = e.height; return i < n / 2 ? 'top' : i > t.height - n / 2 ? 'bottom' : 'center' } function Vs (t, e, i, n) { const a = n.x; const r = n.width; const o = i.caretSize + i.caretPadding; return t === 'left' && a + r + o > e.width || (t === 'right' && a - r - o < 0 || void 0) } function Ws (t, e, i, n) { const a = i.x; const r = i.width; const o = t.width; const s = t.chartArea; const l = s.left; const h = s.right; let u = 'center'; return n === 'center' ? u = a <= (l + h) / 2 ? 'left' : 'right' : a <= r / 2 ? u = 'left' : a >= o - r / 2 && (u = 'right'), Vs(u, t, e, i) && (u = 'center'), u } function Ns (t, e, i) { const n = i.yAlign || e.yAlign || Bs(t, i); return { xAlign: i.xAlign || e.xAlign || Ws(t, e, i, n), yAlign: n } } function Hs (t, e) { let i = t.x; const n = t.width; return e === 'right' ? i -= n : e === 'center' && (i -= n / 2), i } function js (t, e, i) { let n = t.y; const a = t.height; return e === 'top' ? n += i : n -= e === 'bottom' ? a + i : a / 2, n } function $s (t, e, i, n) { const a = t.caretSize; const r = t.caretPadding; const o = t.cornerRadius; const s = i.xAlign; const l = i.yAlign; const h = a + r; const u = ni(o); const c = u.topLeft; const d = u.topRight; const f = u.bottomLeft; const v = u.bottomRight; let g = Hs(e, s); const p = js(e, l, h); return l === 'center' ? s === 'left' ? g += h : s === 'right' && (g -= h) : s === 'left' ? g -= Math.max(c, f) + a : s === 'right' && (g += Math.max(d, v) + a), { x: Ct(g, 0, n.width - e.width), y: Ct(p, 0, n.height - e.height) } } function Ys (t, e, i) { const n = ai(i.padding); return e === 'center' ? t.x + t.width / 2 : e === 'right' ? t.x + t.width - n.right : t.x + n.left } function Us (t) { return Is([], Zs(t)) } function Xs (t, e, i) { return li(t, { tooltip: e, tooltipItems: i, type: 'tooltip' }) } function qs (t, e) { const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return i ? t.override(i) : t } const Ks = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this), n.opacity = 0, n._active = [], n._eventPosition = void 0, n._size = void 0, n._cachedAnimations = void 0, n._tooltipItems = [], n.$animations = void 0, n.$context = void 0, n.chart = t.chart || t._chart, n._chart = n.chart, n.options = t.options, n.dataPoints = void 0, n.title = void 0, n.beforeBody = void 0, n.body = void 0, n.afterBody = void 0, n.footer = void 0, n.xAlign = void 0, n.yAlign = void 0, n.x = void 0, n.y = void 0, n.height = void 0, n.width = void 0, n.caretX = void 0, n.caretY = void 0, n.labelColors = void 0, n.labelPointStyles = void 0, n.labelTextColors = void 0, n } return (0, k.Z)(i, [{ key: 'initialize', value: function (t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } }, { key: '_resolveAnimations', value: function () { const t = this._cachedAnimations; if (t) return t; const e = this.chart; const i = this.options.setContext(this.getContext()); const n = i.enabled && e.options.animation && i.animations; const a = new Wn(this.chart, n); return n._cacheable && (this._cachedAnimations = Object.freeze(a)), a } }, { key: 'getContext', value: function () { return this.$context || (this.$context = Xs(this.chart.getContext(), this, this._tooltipItems)) } }, { key: 'getTitle', value: function (t, e) { const i = e.callbacks; const n = i.beforeTitle.apply(this, [t]); const a = i.title.apply(this, [t]); const r = i.afterTitle.apply(this, [t]); let o = []; return o = Is(o, Zs(n)), o = Is(o, Zs(a)), o = Is(o, Zs(r)), o } }, { key: 'getBeforeBody', value: function (t, e) { return Us(e.callbacks.beforeBody.apply(this, [t])) } }, { key: 'getBody', value: function (t, e) { const i = this; const n = e.callbacks; const a = []; return V(t, function (t) { const e = { before: [], lines: [], after: [] }; const r = qs(n, t); Is(e.before, Zs(r.beforeLabel.call(i, t))), Is(e.lines, r.label.call(i, t)), Is(e.after, Zs(r.afterLabel.call(i, t))), a.push(e) }), a } }, { key: 'getAfterBody', value: function (t, e) { return Us(e.callbacks.afterBody.apply(this, [t])) } }, { key: 'getFooter', value: function (t, e) { const i = e.callbacks; const n = i.beforeFooter.apply(this, [t]); const a = i.footer.apply(this, [t]); const r = i.afterFooter.apply(this, [t]); let o = []; return o = Is(o, Zs(n)), o = Is(o, Zs(a)), o = Is(o, Zs(r)), o } }, { key: '_createItems', value: function (t) { let e; let i; const n = this; const a = this._active; const r = this.chart.data; const o = []; const s = []; const l = []; let h = []; for (e = 0, i = a.length; e < i; ++e)h.push(zs(this.chart, a[e])); return t.filter && (h = h.filter(function (e, i, n) { return t.filter(e, i, n, r) })), t.itemSort && (h = h.sort(function (e, i) { return t.itemSort(e, i, r) })), V(h, function (e) { const i = qs(t.callbacks, e); o.push(i.labelColor.call(n, e)), s.push(i.labelPointStyle.call(n, e)), l.push(i.labelTextColor.call(n, e)) }), this.labelColors = o, this.labelPointStyles = s, this.labelTextColors = l, this.dataPoints = h, h } }, { key: 'update', value: function (t, e) { let i; const n = this.options.setContext(this.getContext()); const a = this._active; let r = []; if (a.length) { const o = Es[n.position].call(this, a, this._eventPosition); r = this._createItems(n), this.title = this.getTitle(r, n), this.beforeBody = this.getBeforeBody(r, n), this.body = this.getBody(r, n), this.afterBody = this.getAfterBody(r, n), this.footer = this.getFooter(r, n); const s = this._size = Fs(this, n); const l = Object.assign({}, o, s); const h = Ns(this.chart, n, l); const u = $s(n, l, h, this.chart); this.xAlign = h.xAlign, this.yAlign = h.yAlign, i = { opacity: 1, x: u.x, y: u.y, width: s.width, height: s.height, caretX: o.x, caretY: o.y } } else this.opacity !== 0 && (i = { opacity: 0 }); this._tooltipItems = r, this.$context = void 0, i && this._resolveAnimations().update(this, i), t && n.external && n.external.call(this, { chart: this.chart, tooltip: this, replay: e }) } }, { key: 'drawCaret', value: function (t, e, i, n) { const a = this.getCaretPosition(t, i, n); e.lineTo(a.x1, a.y1), e.lineTo(a.x2, a.y2), e.lineTo(a.x3, a.y3) } }, { key: 'getCaretPosition', value: function (t, e, i) { let n; let a; let r; let o; let s; let l; const h = this.xAlign; const u = this.yAlign; const c = i.caretSize; const d = i.cornerRadius; const f = ni(d); const v = f.topLeft; const g = f.topRight; const p = f.bottomLeft; const y = f.bottomRight; const m = t.x; const b = t.y; const x = e.width; const _ = e.height; return u === 'center' ? (s = b + _ / 2, h === 'left' ? (n = m, a = n - c, o = s + c, l = s - c) : (n = m + x, a = n + c, o = s - c, l = s + c), r = n) : (a = h === 'left' ? m + Math.max(v, p) + c : h === 'right' ? m + x - Math.max(g, y) - c : this.caretX, u === 'top' ? (o = b, s = o - c, n = a - c, r = a + c) : (o = b + _, s = o + c, n = a + c, r = a - c), l = o), { x1: n, x2: a, x3: r, y1: o, y2: s, y3: l } } }, { key: 'drawTitle', value: function (t, e, i) { let n; let a; let r; const o = this.title; const s = o.length; if (s) { const l = mn(i.rtl, this.x, this.width); for (t.x = Ys(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = 'middle', n = ri(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = n.string, r = 0; r < s; ++r)e.fillText(o[r], l.x(t.x), t.y + n.lineHeight / 2), t.y += n.lineHeight + a, r + 1 === s && (t.y += i.titleMarginBottom - a) } } }, { key: '_drawColorBox', value: function (t, e, i, n, a) { const r = this.labelColors[i]; const o = this.labelPointStyles[i]; const s = a.boxHeight; const l = a.boxWidth; const h = a.boxPadding; const u = ri(a.bodyFont); const d = Ys(this, 'left', a); const f = n.x(d); const v = s < u.lineHeight ? (u.lineHeight - s) / 2 : 0; const g = e.y + v; if (a.usePointStyle) { const p = { radius: Math.min(l, s) / 2, pointStyle: o.pointStyle, rotation: o.rotation, borderWidth: 1 }; const y = n.leftForLtr(f, l) + l / 2; const m = g + s / 2; t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, Ve(t, p, y, m), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Ve(t, p, y, m) } else { t.lineWidth = R(r.borderWidth) ? Math.max.apply(Math, (0, c.Z)(Object.values(r.borderWidth))) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0; const b = n.leftForLtr(f, l - h); const x = n.leftForLtr(n.xPlus(f, 1), l - h - 2); const _ = ni(r.borderRadius); Object.values(_).some(function (t) { return t !== 0 }) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, Ke(t, { x: b, y: g, w: l, h: s, radius: _ }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), Ke(t, { x: x, y: g + 1, w: l - 2, h: s - 2, radius: _ }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(b, g, l, s), t.strokeRect(b, g, l, s), t.fillStyle = r.backgroundColor, t.fillRect(x, g + 1, l - 2, s - 2)) }t.fillStyle = this.labelTextColors[i] } }, { key: 'drawBody', value: function (t, e, i) { let n; let a; let r; let o; let s; let l; let h; const u = this.body; const c = i.bodySpacing; const d = i.bodyAlign; const f = i.displayColors; const v = i.boxHeight; const g = i.boxWidth; const p = i.boxPadding; const y = ri(i.bodyFont); let m = y.lineHeight; let b = 0; const x = mn(i.rtl, this.x, this.width); const _ = function (i) { e.fillText(i, x.x(t.x + b), t.y + m / 2), t.y += m + c }; const k = x.textAlign(d); for (e.textAlign = d, e.textBaseline = 'middle', e.font = y.string, t.x = Ys(this, k, i), e.fillStyle = i.bodyColor, V(this.beforeBody, _), b = f && k !== 'right' ? d === 'center' ? g / 2 + p : g + 2 + p : 0, o = 0, l = u.length; o < l; ++o) { for (n = u[o], a = this.labelTextColors[o], e.fillStyle = a, V(n.before, _), r = n.lines, f && r.length && (this._drawColorBox(e, t, o, x, i), m = Math.max(y.lineHeight, v)), s = 0, h = r.length; s < h; ++s)_(r[s]), m = y.lineHeight; V(n.after, _) }b = 0, m = y.lineHeight, V(this.afterBody, _), t.y -= c } }, { key: 'drawFooter', value: function (t, e, i) { let n; let a; const r = this.footer; const o = r.length; if (o) { const s = mn(i.rtl, this.x, this.width); for (t.x = Ys(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = s.textAlign(i.footerAlign), e.textBaseline = 'middle', n = ri(i.footerFont), e.fillStyle = i.footerColor, e.font = n.string, a = 0; a < o; ++a)e.fillText(r[a], s.x(t.x), t.y + n.lineHeight / 2), t.y += n.lineHeight + i.footerSpacing } } }, { key: 'drawBackground', value: function (t, e, i, n) { const a = this.xAlign; const r = this.yAlign; const o = t.x; const s = t.y; const l = i.width; const h = i.height; const u = ni(n.cornerRadius); const c = u.topLeft; const d = u.topRight; const f = u.bottomLeft; const v = u.bottomRight; e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(o + c, s), r === 'top' && this.drawCaret(t, e, i, n), e.lineTo(o + l - d, s), e.quadraticCurveTo(o + l, s, o + l, s + d), r === 'center' && a === 'right' && this.drawCaret(t, e, i, n), e.lineTo(o + l, s + h - v), e.quadraticCurveTo(o + l, s + h, o + l - v, s + h), r === 'bottom' && this.drawCaret(t, e, i, n), e.lineTo(o + f, s + h), e.quadraticCurveTo(o, s + h, o, s + h - f), r === 'center' && a === 'left' && this.drawCaret(t, e, i, n), e.lineTo(o, s + c), e.quadraticCurveTo(o, s, o + c, s), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke() } }, { key: '_updateAnimationTarget', value: function (t) { const e = this.chart; const i = this.$animations; const n = i && i.x; const a = i && i.y; if (n || a) { const r = Es[t.position].call(this, this._active, this._eventPosition); if (!r) return; const o = this._size = Fs(this, t); const s = Object.assign({}, r, this._size); const l = Ns(e, t, s); const h = $s(t, s, l, e); n._to === h.x && a._to === h.y || (this.xAlign = l.xAlign, this.yAlign = l.yAlign, this.width = o.width, this.height = o.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h)) } } }, { key: '_willRender', value: function () { return !!this.opacity } }, { key: 'draw', value: function (t) { const e = this.options.setContext(this.getContext()); let i = this.opacity; if (i) { this._updateAnimationTarget(e); const n = { width: this.width, height: this.height }; const a = { x: this.x, y: this.y }; i = Math.abs(i) < 0.001 ? 0 : i; const r = ai(e.padding); const o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; e.enabled && o && (t.save(), t.globalAlpha = i, this.drawBackground(a, t, n, e), bn(t, e.textDirection), a.y += r.top, this.drawTitle(a, t, e), this.drawBody(a, t, e), this.drawFooter(a, t, e), xn(t, e.textDirection), t.restore()) } } }, { key: 'getActiveElements', value: function () { return this._active || [] } }, { key: 'setActiveElements', value: function (t, e) { const i = this; const n = this._active; const a = t.map(function (t) { const e = t.datasetIndex; const n = t.index; const a = i.chart.getDatasetMeta(e); if (!a) throw new Error('Cannot find a dataset at index ' + e); return { datasetIndex: e, element: a.data[n], index: n } }); const r = !W(n, a); const o = this._positionChanged(a, e); (r || o) && (this._active = a, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0)) } }, { key: 'handleEvent', value: function (t, e) { const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (e && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const n = this.options; const a = this._active || []; const r = this._getActiveElements(t, a, e, i); const o = this._positionChanged(r, t); const s = e || !W(r, a) || o; return s && (this._active = r, (n.enabled || n.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0, e))), s } }, { key: '_getActiveElements', value: function (t, e, i, n) { const a = this.options; if (t.type === 'mouseout') return []; if (!n) return e; const r = this.chart.getElementsAtEventForMode(t, a.mode, a, i); return a.reverse && r.reverse(), r } }, { key: '_positionChanged', value: function (t, e) { const i = this.caretX; const n = this.caretY; const a = this.options; const r = Es[a.position].call(this, t, e); return !1 !== r && (i !== r.x || n !== r.y) } }]), i }(Er)); Ks.positioners = Es; const Gs = { id: 'tooltip', _element: Ks, positioners: Es, afterInit: function (t, e, i) { i && (t.tooltip = new Ks({ chart: t, options: i })) }, beforeUpdate: function (t, e, i) { t.tooltip && t.tooltip.initialize(i) }, reset: function (t, e, i) { t.tooltip && t.tooltip.initialize(i) }, afterDraw: function (t) { const e = t.tooltip; if (e && e._willRender()) { const i = { tooltip: e }; if (!1 === t.notifyPlugins('beforeTooltipDraw', i)) return; e.draw(t.ctx), t.notifyPlugins('afterTooltipDraw', i) } }, afterEvent: function (t, e) { if (t.tooltip) { const i = e.replay; t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: 'average', backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#fff', titleFont: { weight: 'bold' }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: 'left', bodyColor: '#fff', bodySpacing: 2, bodyFont: {}, bodyAlign: 'left', footerColor: '#fff', footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: 'bold' }, footerAlign: 'left', padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: function (t, e) { return e.bodyFont.size }, boxWidth: function (t, e) { return e.bodyFont.size }, multiKeyBackground: '#fff', displayColors: !0, boxPadding: 0, borderColor: 'rgba(0,0,0,0)', borderWidth: 0, animation: { duration: 400, easing: 'easeOutQuart' }, animations: { numbers: { type: 'number', properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'] }, opacity: { easing: 'linear', duration: 200 } }, callbacks: { beforeTitle: O, title: function (t) { if (t.length > 0) { const e = t[0]; const i = e.chart.data.labels; const n = i ? i.length : 0; if (this && this.options && this.options.mode === 'dataset') return e.dataset.label || ''; if (e.label) return e.label; if (n > 0 && e.dataIndex < n) return i[e.dataIndex] } return '' }, afterTitle: O, beforeBody: O, beforeLabel: O, label: function (t) { if (this && this.options && this.options.mode === 'dataset') return t.label + ': ' + t.formattedValue || t.formattedValue; let e = t.dataset.label || ''; e && (e += ': '); const i = t.formattedValue; return T(i) || (e += i), e }, labelColor: function (t) { const e = t.chart.getDatasetMeta(t.datasetIndex); const i = e.controller.getStyle(t.dataIndex); return { borderColor: i.borderColor, backgroundColor: i.backgroundColor, borderWidth: i.borderWidth, borderDash: i.borderDash, borderDashOffset: i.borderDashOffset, borderRadius: 0 } }, labelTextColor: function () { return this.options.bodyColor }, labelPointStyle: function (t) { const e = t.chart.getDatasetMeta(t.datasetIndex); const i = e.controller.getStyle(t.dataIndex); return { pointStyle: i.pointStyle, rotation: i.rotation } }, afterLabel: O, afterBody: O, beforeFooter: O, footer: O, afterFooter: O } }, defaultRoutes: { bodyFont: 'font', footerFont: 'font', titleFont: 'font' }, descriptors: { _scriptable: function (t) { return t !== 'filter' && t !== 'itemSort' && t !== 'external' }, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: 'animation' } }, additionalOptionScopes: ['interaction'] }; const Js = function (t, e, i, n) { return typeof e === 'string' ? (i = t.push(e) - 1, n.unshift({ index: i, label: e })) : isNaN(e) && (i = null), i }; function Qs (t, e, i, n) { const a = t.indexOf(e); if (a === -1) return Js(t, e, i, n); const r = t.lastIndexOf(e); return a !== r ? i : a } const tl = function (t, e) { return t === null ? null : Ct(Math.round(t), 0, e) }; const el = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n._startValue = void 0, n._valueRange = 0, n._addedLabels = [], n } return (0, k.Z)(i, [{ key: 'init', value: function (t) { const e = this._addedLabels; if (e.length) { let n; const a = this.getLabels(); const r = (0, b.Z)(e); try { for (r.s(); !(n = r.n()).done;) { const o = n.value; const s = o.index; const l = o.label; a[s] === l && a.splice(s, 1) } } catch (h) { r.e(h) } finally { r.f() } this._addedLabels = [] }(0, f.Z)((0, v.Z)(i.prototype), 'init', this).call(this, t) } }, { key: 'parse', value: function (t, e) { if (T(t)) return null; const i = this.getLabels(); return e = isFinite(e) && i[e] === t ? e : Qs(i, t, Z(e, t), this._addedLabels), tl(e, i.length - 1) } }, { key: 'determineDataLimits', value: function () { const t = this.getUserBounds(); const e = t.minDefined; const i = t.maxDefined; const n = this.getMinMax(!0); let a = n.min; let r = n.max; this.options.bounds === 'ticks' && (e || (a = 0), i || (r = this.getLabels().length - 1)), this.min = a, this.max = r } }, { key: 'buildTicks', value: function () { const t = this.min; const e = this.max; const i = this.options.offset; const n = []; let a = this.getLabels(); a = t === 0 && e === a.length - 1 ? a : a.slice(t, e + 1), this._valueRange = Math.max(a.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0); for (let r = t; r <= e; r++)n.push({ value: r }); return n } }, { key: 'getLabelForValue', value: function (t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } }, { key: 'configure', value: function () { (0, f.Z)((0, v.Z)(i.prototype), 'configure', this).call(this), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } }, { key: 'getPixelForValue', value: function (t) { return typeof t !== 'number' && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } }, { key: 'getPixelForTick', value: function (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } }, { key: 'getValueForPixel', value: function (t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } }, { key: 'getBasePixel', value: function () { return this.bottom } }]), i }(io)); function il (t, e) { let i; let n; let a; let r; const o = []; const s = 1e-14; const l = t.bounds; const h = t.step; const u = t.min; const c = t.max; const d = t.precision; const f = t.count; const v = t.maxTicks; const g = t.maxDigits; const p = t.includeBounds; const y = h || 1; const m = v - 1; const b = e.min; const x = e.max; const _ = !T(u); const k = !T(c); const w = !T(f); const M = (x - b) / (g + 1); let S = ft((x - b) / m / y) * y; if (S < s && !_ && !k) return [{ value: b }, { value: x }]; r = Math.ceil(x / S) - Math.floor(b / S), r > m && (S = ft(r * S / m / y) * y), T(d) || (i = Math.pow(10, d), S = Math.ceil(S * i) / i), l === 'ticks' ? (n = Math.floor(b / S) * S, a = Math.ceil(x / S) * S) : (n = b, a = x), _ && k && h && yt((c - u) / h, S / 1e3) ? (r = Math.round(Math.min((c - u) / S, v)), S = (c - u) / r, n = u, a = c) : w ? (n = _ ? u : n, a = k ? c : a, r = f - 1, S = (a - n) / r) : (r = (a - n) / S, r = pt(r, Math.round(r), S / 1e3) ? Math.round(r) : Math.ceil(r)); const P = Math.max(_t(S), _t(n)); i = Math.pow(10, T(d) ? P : d), n = Math.round(n * i) / i, a = Math.round(a * i) / i; let C = 0; for (_ && (p && n !== u ? (o.push({ value: u }), n < u && C++, pt(Math.round((n + C * S) * i) / i, u, nl(u, M, t)) && C++) : n < u && C++); C < r; ++C)o.push({ value: Math.round((n + C * S) * i) / i }); return k && p && a !== c ? o.length && pt(o[o.length - 1].value, c, nl(c, M, t)) ? o[o.length - 1].value = c : o.push({ value: c }) : k && a !== c || o.push({ value: a }), o } function nl (t, e, i) { const n = i.horizontal; const a = i.minRotation; const r = bt(a); const o = (n ? Math.sin(r) : Math.cos(r)) || 0.001; const s = 0.75 * e * ('' + t).length; return Math.min(e / o, s) }el.id = 'category', el.defaults = { ticks: { callback: el.prototype.getLabelForValue } }; const al = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n.start = void 0, n.end = void 0, n._startValue = void 0, n._endValue = void 0, n._valueRange = 0, n } return (0, k.Z)(i, [{ key: 'parse', value: function (t, e) { return T(t) || (typeof t === 'number' || t instanceof Number) && !isFinite(+t) ? null : +t } }, { key: 'handleTickRangeOptions', value: function () { const t = this.options.beginAtZero; const e = this.getUserBounds(); const i = e.minDefined; const n = e.maxDefined; let a = this.min; let r = this.max; const o = function (t) { return a = i ? a : t }; const s = function (t) { return r = n ? r : t }; if (t) { const l = dt(a); const h = dt(r); l < 0 && h < 0 ? s(0) : l > 0 && h > 0 && o(0) } if (a === r) { let u = 1; (r >= Number.MAX_SAFE_INTEGER || a <= Number.MIN_SAFE_INTEGER) && (u = Math.abs(0.05 * r)), s(r + u), t || o(a - u) } this.min = a, this.max = r } }, { key: 'getTickLimit', value: function () { let t; const e = this.options.ticks; let i = e.maxTicksLimit; const n = e.stepSize; return n ? (t = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, t > 1e3 && (console.warn('scales.'.concat(this.id, '.ticks.stepSize: ').concat(n, ' would result generating up to ').concat(t, ' ticks. Limiting to 1000.')), t = 1e3)) : (t = this.computeTickLimit(), i = i || 11), i && (t = Math.min(i, t)), t } }, { key: 'computeTickLimit', value: function () { return Number.POSITIVE_INFINITY } }, { key: 'buildTicks', value: function () { const t = this.options; const e = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const n = { maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: !1 !== e.includeBounds }; const a = this._range || this; const r = il(n, a); return t.bounds === 'ticks' && mt(r, this, 'value'), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r } }, { key: 'configure', value: function () { const t = this.ticks; let e = this.min; let n = this.max; if ((0, f.Z)((0, v.Z)(i.prototype), 'configure', this).call(this), this.options.offset && t.length) { const a = (n - e) / Math.max(t.length - 1, 1) / 2; e -= a, n += a } this._startValue = e, this._endValue = n, this._valueRange = n - e } }, { key: 'getLabelForValue', value: function (t) { return gn(t, this.chart.options.locale, this.options.ticks.format) } }]), i }(io)); const rl = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i () { return (0, _.Z)(this, i), e.apply(this, arguments) } return (0, k.Z)(i, [{ key: 'determineDataLimits', value: function () { const t = this.getMinMax(!0); const e = t.min; const i = t.max; this.min = E(e) ? e : 0, this.max = E(i) ? i : 1, this.handleTickRangeOptions() } }, { key: 'computeTickLimit', value: function () { const t = this.isHorizontal(); const e = t ? this.width : this.height; const i = bt(this.options.ticks.minRotation); const n = (t ? Math.sin(i) : Math.cos(i)) || 0.001; const a = this._resolveTickFontOptions(0); return Math.ceil(e / Math.min(40, a.lineHeight / n)) } }, { key: 'getPixelForValue', value: function (t) { return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } }, { key: 'getValueForPixel', value: function (t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } }]), i }(al)); function ol (t) { const e = t / Math.pow(10, Math.floor(ct(t))); return e === 1 } function sl (t, e) { const i = Math.floor(ct(e.max)); const n = Math.ceil(e.max / Math.pow(10, i)); const a = []; let r = I(t.min, Math.pow(10, Math.floor(ct(e.min)))); let o = Math.floor(ct(r)); let s = Math.floor(r / Math.pow(10, o)); let l = o < 0 ? Math.pow(10, Math.abs(o)) : 1; do { a.push({ value: r, major: ol(r) }), ++s, s === 10 && (s = 1, ++o, l = o >= 0 ? 1 : l), r = Math.round(s * Math.pow(10, o) * l) / l } while (o < i || o === i && s < n); const h = I(t.max, r); return a.push({ value: h, major: ol(r) }), a }rl.id = 'linear', rl.defaults = { ticks: { callback: zr.formatters.numeric } }; const ll = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n.start = void 0, n.end = void 0, n._startValue = void 0, n._valueRange = 0, n } return (0, k.Z)(i, [{ key: 'parse', value: function (t, e) { const i = al.prototype.parse.apply(this, [t, e]); if (i !== 0) return E(i) && i > 0 ? i : null; this._zero = !0 } }, { key: 'determineDataLimits', value: function () { const t = this.getMinMax(!0); const e = t.min; const i = t.max; this.min = E(e) ? Math.max(0, e) : null, this.max = E(i) ? Math.max(0, i) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions() } }, { key: 'handleTickRangeOptions', value: function () { const t = this.getUserBounds(); const e = t.minDefined; const i = t.maxDefined; let n = this.min; let a = this.max; const r = function (t) { return n = e ? n : t }; const o = function (t) { return a = i ? a : t }; const s = function (t, e) { return Math.pow(10, Math.floor(ct(t)) + e) }; n === a && (n <= 0 ? (r(1), o(10)) : (r(s(n, -1)), o(s(a, 1)))), n <= 0 && r(s(a, -1)), a <= 0 && o(s(n, 1)), this._zero && this.min !== this._suggestedMin && n === s(this.min, 0) && r(s(n, -1)), this.min = n, this.max = a } }, { key: 'buildTicks', value: function () { const t = this.options; const e = { min: this._userMin, max: this._userMax }; const i = sl(e, this); return t.bounds === 'ticks' && mt(i, this, 'value'), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } }, { key: 'getLabelForValue', value: function (t) { return void 0 === t ? '0' : gn(t, this.chart.options.locale, this.options.ticks.format) } }, { key: 'configure', value: function () { const t = this.min; (0, f.Z)((0, v.Z)(i.prototype), 'configure', this).call(this), this._startValue = ct(t), this._valueRange = ct(this.max) - ct(t) } }, { key: 'getPixelForValue', value: function (t) { return void 0 !== t && t !== 0 || (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (ct(t) - this._startValue) / this._valueRange) } }, { key: 'getValueForPixel', value: function (t) { const e = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + e * this._valueRange) } }]), i }(io)); function hl (t) { const e = t.ticks; if (e.display && t.display) { const i = ai(e.backdropPadding); return Z(e.font && e.font.size, Ee.font.size) + i.height } return 0 } function ul (t, e, i) { return i = L(i) ? i : [i], { w: ze(t, e.string, i), h: i.length * e.lineHeight } } function cl (t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i, end: e } : { start: e, end: e + i } } function dl (t) { for (var e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, i = Object.assign({}, e), n = [], a = [], r = t._pointLabels.length, o = t.options.pointLabels, s = o.centerPointLabels ? nt / r : 0, l = 0; l < r; l++) { const h = o.setContext(t.getPointLabelContext(l)); a[l] = h.padding; const u = t.getPointPosition(l, t.drawingArea + a[l], s); const c = ri(h.font); const d = ul(t.ctx, c, t._pointLabels[l]); n[l] = d; const f = St(t.getIndexAngle(l) + s); const v = Math.round(xt(f)); const g = cl(v, u.x, d.w, 0, 180); const p = cl(v, u.y, d.h, 90, 270); fl(i, e, f, g, p) }t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = vl(t, n, a) } function fl (t, e, i, n, a) { const r = Math.abs(Math.sin(i)); const o = Math.abs(Math.cos(i)); let s = 0; let l = 0; n.start < e.l ? (s = (e.l - n.start) / r, t.l = Math.min(t.l, e.l - s)) : n.end > e.r && (s = (n.end - e.r) / r, t.r = Math.max(t.r, e.r + s)), a.start < e.t ? (l = (e.t - a.start) / o, t.t = Math.min(t.t, e.t - l)) : a.end > e.b && (l = (a.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function vl (t, e, i) { for (var n = [], a = t._pointLabels.length, r = t.options, o = hl(r) / 2, s = t.drawingArea, l = r.pointLabels.centerPointLabels ? nt / a : 0, h = 0; h < a; h++) { const u = t.getPointPosition(h, s + o + i[h], l); const c = Math.round(xt(St(u.angle + lt))); const d = e[h]; const f = yl(u.y, d.h, c); const v = gl(c); const g = pl(u.x, d.w, v); n.push({ x: u.x, y: f, textAlign: v, left: g, top: f, right: g + d.w, bottom: f + d.h }) } return n } function gl (t) { return t === 0 || t === 180 ? 'center' : t < 180 ? 'left' : 'right' } function pl (t, e, i) { return i === 'right' ? t -= e : i === 'center' && (t -= e / 2), t } function yl (t, e, i) { return i === 90 || i === 270 ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t } function ml (t, e) { for (let i = t.ctx, n = t.options.pointLabels, a = e - 1; a >= 0; a--) { const r = n.setContext(t.getPointLabelContext(a)); const o = ri(r.font); const s = t._pointLabelItems[a]; const l = s.x; const h = s.y; const u = s.textAlign; const c = s.left; const d = s.top; const f = s.right; const v = s.bottom; const g = r.backdropColor; if (!T(g)) { const p = ni(r.borderRadius); const y = ai(r.backdropPadding); i.fillStyle = g; const m = c - y.left; const b = d - y.top; const x = f - c + y.width; const _ = v - d + y.height; Object.values(p).some(function (t) { return t !== 0 }) ? (i.beginPath(), Ke(i, { x: m, y: b, w: x, h: _, radius: p }), i.fill()) : i.fillRect(m, b, x, _) }Ue(i, t._pointLabels[a], l, h + o.lineHeight / 2, o, { color: r.color, textAlign: u, textBaseline: 'middle' }) } } function bl (t, e, i, n) { const a = t.ctx; if (i)a.arc(t.xCenter, t.yCenter, e, 0, at); else { let r = t.getPointPosition(0, e); a.moveTo(r.x, r.y); for (let o = 1; o < n; o++)r = t.getPointPosition(o, e), a.lineTo(r.x, r.y) } } function xl (t, e, i, n) { const a = t.ctx; const r = e.circular; const o = e.color; const s = e.lineWidth; !r && !n || !o || !s || i < 0 || (a.save(), a.strokeStyle = o, a.lineWidth = s, a.setLineDash(e.borderDash), a.lineDashOffset = e.borderDashOffset, a.beginPath(), bl(t, i, r, n), a.closePath(), a.stroke(), a.restore()) } function _l (t, e, i) { return li(t, { label: i, index: e, type: 'pointLabel' }) }ll.id = 'logarithmic', ll.defaults = { ticks: { callback: zr.formatters.logarithmic, major: { enabled: !0 } } }; const kl = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n.xCenter = void 0, n.yCenter = void 0, n.drawingArea = void 0, n._pointLabels = [], n._pointLabelItems = [], n } return (0, k.Z)(i, [{ key: 'setDimensions', value: function () { const t = this._padding = ai(hl(this.options) / 2); const e = this.width = this.maxWidth - t.width; const i = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2) } }, { key: 'determineDataLimits', value: function () { const t = this.getMinMax(!1); const e = t.min; const i = t.max; this.min = E(e) && !isNaN(e) ? e : 0, this.max = E(i) && !isNaN(i) ? i : 0, this.handleTickRangeOptions() } }, { key: 'computeTickLimit', value: function () { return Math.ceil(this.drawingArea / hl(this.options)) } }, { key: 'generateTickLabels', value: function (t) { const e = this; al.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(function (t, i) { const n = B(e.options.pointLabels.callback, [t, i], e); return n || n === 0 ? n : '' }).filter(function (t, i) { return e.chart.getDataVisibility(i) }) } }, { key: 'fit', value: function () { const t = this.options; t.display && t.pointLabels.display ? dl(this) : this.setCenterPoint(0, 0, 0, 0) } }, { key: 'setCenterPoint', value: function (t, e, i, n) { this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, n)) } }, { key: 'getIndexAngle', value: function (t) { const e = at / (this._pointLabels.length || 1); const i = this.options.startAngle || 0; return St(t * e + bt(i)) } }, { key: 'getDistanceFromCenterForValue', value: function (t) { if (T(t)) return NaN; const e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e } }, { key: 'getValueForDistanceFromCenter', value: function (t) { if (T(t)) return NaN; const e = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - e : this.min + e } }, { key: 'getPointLabelContext', value: function (t) { const e = this._pointLabels || []; if (t >= 0 && t < e.length) { const i = e[t]; return _l(this.getContext(), t, i) } } }, { key: 'getPointPosition', value: function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const n = this.getIndexAngle(t) - lt + i; return { x: Math.cos(n) * e + this.xCenter, y: Math.sin(n) * e + this.yCenter, angle: n } } }, { key: 'getPointPositionForValue', value: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } }, { key: 'getBasePosition', value: function (t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } }, { key: 'getPointLabelPosition', value: function (t) { const e = this._pointLabelItems[t]; const i = e.left; const n = e.top; const a = e.right; const r = e.bottom; return { left: i, top: n, right: a, bottom: r } } }, { key: 'drawBackground', value: function () { const t = this.options; const e = t.backgroundColor; const i = t.grid.circular; if (e) { const n = this.ctx; n.save(), n.beginPath(), bl(this, this.getDistanceFromCenterForValue(this._endValue), i, this._pointLabels.length), n.closePath(), n.fillStyle = e, n.fill(), n.restore() } } }, { key: 'drawGrid', value: function () { let t; let e; let i; const n = this; const a = this.ctx; const r = this.options; const o = r.angleLines; const s = r.grid; const l = this._pointLabels.length; if (r.pointLabels.display && ml(this, l), s.display && this.ticks.forEach(function (t, i) { if (i !== 0) { e = n.getDistanceFromCenterForValue(t.value); const a = s.setContext(n.getContext(i - 1)); xl(n, a, e, l) } }), o.display) { for (a.save(), t = l - 1; t >= 0; t--) { const h = o.setContext(this.getPointLabelContext(t)); const u = h.color; const c = h.lineWidth; c && u && (a.lineWidth = c, a.strokeStyle = u, a.setLineDash(h.borderDash), a.lineDashOffset = h.borderDashOffset, e = this.getDistanceFromCenterForValue(r.ticks.reverse ? this.min : this.max), i = this.getPointPosition(t, e), a.beginPath(), a.moveTo(this.xCenter, this.yCenter), a.lineTo(i.x, i.y), a.stroke()) }a.restore() } } }, { key: 'drawBorder', value: function () {} }, { key: 'drawLabels', value: function () { const t = this; const e = this.ctx; const i = this.options; const n = i.ticks; if (n.display) { let a; let r; const o = this.getIndexAngle(0); e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(o), e.textAlign = 'center', e.textBaseline = 'middle', this.ticks.forEach(function (o, s) { if (s !== 0 || i.reverse) { const l = n.setContext(t.getContext(s)); const h = ri(l.font); if (a = t.getDistanceFromCenterForValue(t.ticks[s].value), l.showLabelBackdrop) { e.font = h.string, r = e.measureText(o.label).width, e.fillStyle = l.backdropColor; const u = ai(l.backdropPadding); e.fillRect(-r / 2 - u.left, -a - h.size / 2 - u.top, r + u.width, h.size + u.height) }Ue(e, o.label, 0, -a, h, { color: l.color }) } }), e.restore() } } }, { key: 'drawTitle', value: function () {} }]), i }(al)); kl.id = 'radialLinear', kl.defaults = { display: !0, animate: !0, position: 'chartArea', angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: zr.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: function (t) { return t }, padding: 5, centerPointLabels: !1 } }, kl.defaultRoutes = { 'angleLines.color': 'borderColor', 'pointLabels.color': 'color', 'ticks.color': 'color' }, kl.descriptors = { angleLines: { _fallback: 'grid' } }; const wl = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }; const Ml = Object.keys(wl); function Sl (t, e) { return t - e } function Pl (t, e) { if (T(e)) return null; const i = t._adapter; const n = t._parseOpts; const a = n.parser; const r = n.round; const o = n.isoWeekday; let s = e; return typeof a === 'function' && (s = a(s)), E(s) || (s = typeof a === 'string' ? i.parse(s, a) : i.parse(s)), s === null ? null : (r && (s = r !== 'week' || !gt(o) && !0 !== o ? i.startOf(s, r) : i.startOf(s, 'isoWeek', o)), +s) } function Cl (t, e, i, n) { for (var a = Ml.length, r = Ml.indexOf(t); r < a - 1; ++r) { const o = wl[Ml[r]]; const s = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((i - e) / (s * o.size)) <= n) return Ml[r] } return Ml[a - 1] } function Dl (t, e, i, n, a) { for (let r = Ml.length - 1; r >= Ml.indexOf(i); r--) { const o = Ml[r]; if (wl[o].common && t._adapter.diff(a, n, o) >= e - 1) return o } return Ml[i ? Ml.indexOf(i) : 0] } function Ol (t) { for (let e = Ml.indexOf(t) + 1, i = Ml.length; e < i; ++e) if (wl[Ml[e]].common) return Ml[e] } function Al (t, e, i) { if (i) { if (i.length) { const n = hi(i, e); const a = n.lo; const r = n.hi; const o = i[a] >= e ? i[a] : i[r]; t[o] = !0 } } else t[e] = !0 } function Tl (t, e, i, n) { let a; let r; const o = t._adapter; const s = +o.startOf(e[0].value, n); const l = e[e.length - 1].value; for (a = s; a <= l; a = +o.add(a, 1, n))r = i[a], r >= 0 && (e[r].major = !0); return e } function Ll (t, e, i) { let n; let a; const r = []; const o = {}; const s = e.length; for (n = 0; n < s; ++n)a = e[n], o[a] = n, r.push({ value: a, major: !1 }); return s !== 0 && i ? Tl(t, r, o, i) : r } const Rl = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n._cache = { data: [], labels: [], all: [] }, n._unit = 'day', n._majorUnit = void 0, n._offsets = {}, n._normalized = !1, n._parseOpts = void 0, n } return (0, k.Z)(i, [{ key: 'init', value: function (t, e) { const n = t.time || (t.time = {}); const a = this._adapter = new Fa._date(t.adapters.date); Y(n.displayFormats, a.formats()), this._parseOpts = { parser: n.parser, round: n.round, isoWeekday: n.isoWeekday }, (0, f.Z)((0, v.Z)(i.prototype), 'init', this).call(this, t), this._normalized = e.normalized } }, { key: 'parse', value: function (t, e) { return void 0 === t ? null : Pl(this, t) } }, { key: 'beforeLayout', value: function () { (0, f.Z)((0, v.Z)(i.prototype), 'beforeLayout', this).call(this), this._cache = { data: [], labels: [], all: [] } } }, { key: 'determineDataLimits', value: function () { const t = this.options; const e = this._adapter; const i = t.time.unit || 'day'; const n = this.getUserBounds(); let a = n.min; let r = n.max; const o = n.minDefined; const s = n.maxDefined; function l (t) { o || isNaN(t.min) || (a = Math.min(a, t.min)), s || isNaN(t.max) || (r = Math.max(r, t.max)) }o && s || (l(this._getLabelBounds()), t.bounds === 'ticks' && t.ticks.source === 'labels' || l(this.getMinMax(!1))), a = E(a) && !isNaN(a) ? a : +e.startOf(Date.now(), i), r = E(r) && !isNaN(r) ? r : +e.endOf(Date.now(), i) + 1, this.min = Math.min(a, r - 1), this.max = Math.max(a + 1, r) } }, { key: '_getLabelBounds', value: function () { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY; let i = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], i = t[t.length - 1]), { min: e, max: i } } }, { key: 'buildTicks', value: function () { const t = this.options; const e = t.time; const i = t.ticks; const n = i.source === 'labels' ? this.getLabelTimestamps() : this._generate(); t.bounds === 'ticks' && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]); const a = this.min; const r = this.max; const o = di(n, a, r); return this._unit = e.unit || (i.autoSkip ? Cl(e.minUnit, this.min, this.max, this._getLabelCapacity(a)) : Dl(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && this._unit !== 'year' ? Ol(this._unit) : void 0, this.initOffsets(n), t.reverse && o.reverse(), Ll(this, o, this._majorUnit) } }, { key: 'afterAutoSkip', value: function () { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(function (t) { return +t.value })) } }, { key: 'initOffsets', value: function (t) { let e; let i; let n = 0; let a = 0; this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), n = t.length === 1 ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), a = t.length === 1 ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2); const r = t.length < 3 ? 0.5 : 0.25; n = Ct(n, 0, r), a = Ct(a, 0, r), this._offsets = { start: n, end: a, factor: 1 / (n + 1 + a) } } }, { key: '_generate', value: function () { let t; let e; const i = this._adapter; const n = this.min; const a = this.max; const r = this.options; const o = r.time; const s = o.unit || Cl(o.minUnit, n, a, this._getLabelCapacity(n)); const l = Z(o.stepSize, 1); const h = s === 'week' && o.isoWeekday; const u = gt(h) || !0 === h; const c = {}; let d = n; if (u && (d = +i.startOf(d, 'isoWeek', h)), d = +i.startOf(d, u ? 'day' : s), i.diff(a, n, s) > 1e5 * l) throw new Error(n + ' and ' + a + ' are too far apart with stepSize of ' + l + ' ' + s); const f = r.ticks.source === 'data' && this.getDataTimestamps(); for (t = d, e = 0; t < a; t = +i.add(t, l, s), e++)Al(c, t, f); return t !== a && r.bounds !== 'ticks' && e !== 1 || Al(c, t, f), Object.keys(c).sort(function (t, e) { return t - e }).map(function (t) { return +t }) } }, { key: 'getLabelForValue', value: function (t) { const e = this._adapter; const i = this.options.time; return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime) } }, { key: '_tickFormatFunction', value: function (t, e, i, n) { const a = this.options; const r = a.time.displayFormats; const o = this._unit; const s = this._majorUnit; const l = o && r[o]; const h = s && r[s]; const u = i[e]; const c = s && h && u && u.major; const d = this._adapter.format(t, n || (c ? h : l)); const f = a.ticks.callback; return f ? B(f, [d, e, i], this) : d } }, { key: 'generateTickLabels', value: function (t) { let e, i, n; for (e = 0, i = t.length; e < i; ++e)n = t[e], n.label = this._tickFormatFunction(n.value, e, t) } }, { key: 'getDecimalForValue', value: function (t) { return t === null ? NaN : (t - this.min) / (this.max - this.min) } }, { key: 'getPixelForValue', value: function (t) { const e = this._offsets; const i = this.getDecimalForValue(t); return this.getPixelForDecimal((e.start + i) * e.factor) } }, { key: 'getValueForPixel', value: function (t) { const e = this._offsets; const i = this.getDecimalForPixel(t) / e.factor - e.end; return this.min + i * (this.max - this.min) } }, { key: '_getLabelSize', value: function (t) { const e = this.options.ticks; const i = this.ctx.measureText(t).width; const n = bt(this.isHorizontal() ? e.maxRotation : e.minRotation); const a = Math.cos(n); const r = Math.sin(n); const o = this._resolveTickFontOptions(0).size; return { w: i * a + o * r, h: i * r + o * a } } }, { key: '_getLabelCapacity', value: function (t) { const e = this.options.time; const i = e.displayFormats; const n = i[e.unit] || i.millisecond; const a = this._tickFormatFunction(t, 0, Ll(this, [t], this._majorUnit), n); const r = this._getLabelSize(a); const o = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1; return o > 0 ? o : 1 } }, { key: 'getDataTimestamps', value: function () { let t; let e; let i = this._cache.data || []; if (i.length) return i; const n = this.getMatchingVisibleMetas(); if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this); for (t = 0, e = n.length; t < e; ++t)i = i.concat(n[t].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(i) } }, { key: 'getLabelTimestamps', value: function () { let t; let e; const i = this._cache.labels || []; if (i.length) return i; const n = this.getLabels(); for (t = 0, e = n.length; t < e; ++t)i.push(Pl(this, n[t])); return this._cache.labels = this._normalized ? i : this.normalize(i) } }, { key: 'normalize', value: function (t) { return pi(t.sort(Sl)) } }]), i }(io)); function El (t, e, i) { let n; let a; let r; let o; let s = 0; let l = t.length - 1; if (i) { if (e >= t[s].pos && e <= t[l].pos) { const h = ui(t, 'pos', e); s = h.lo, l = h.hi } const u = t[s]; n = u.pos, r = u.time; const c = t[l]; a = c.pos, o = c.time } else { if (e >= t[s].time && e <= t[l].time) { const d = ui(t, 'time', e); s = d.lo, l = d.hi } const f = t[s]; n = f.time, r = f.pos; const v = t[l]; a = v.time, o = v.pos } const g = a - n; return g ? r + (o - r) * (e - n) / g : r }Rl.id = 'time', Rl.defaults = { bounds: 'data', adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: 'millisecond', displayFormats: {} }, ticks: { source: 'auto', major: { enabled: !1 } } }; const Il = (function (t) { (0, g.Z)(i, t); const e = (0, p.Z)(i); function i (t) { let n; return (0, _.Z)(this, i), n = e.call(this, t), n._table = [], n._minPos = void 0, n._tableRange = void 0, n } return (0, k.Z)(i, [{ key: 'initOffsets', value: function () { const t = this._getTimestampsForTable(); const e = this._table = this.buildLookupTable(t); this._minPos = El(e, this.min), this._tableRange = El(e, this.max) - this._minPos, (0, f.Z)((0, v.Z)(i.prototype), 'initOffsets', this).call(this, t) } }, { key: 'buildLookupTable', value: function (t) { let e; let i; let n; let a; let r; const o = this.min; const s = this.max; const l = []; const h = []; for (e = 0, i = t.length; e < i; ++e)a = t[e], a >= o && a <= s && l.push(a); if (l.length < 2) return [{ time: o, pos: 0 }, { time: s, pos: 1 }]; for (e = 0, i = l.length; e < i; ++e)r = l[e + 1], n = l[e - 1], a = l[e], Math.round((r + n) / 2) !== a && h.push({ time: a, pos: e / (i - 1) }); return h } }, { key: '_getTimestampsForTable', value: function () { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(); const i = this.getLabelTimestamps(); return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t } }, { key: 'getDecimalForValue', value: function (t) { return (El(this._table, t) - this._minPos) / this._tableRange } }, { key: 'getValueForPixel', value: function (t) { const e = this._offsets; const i = this.getDecimalForPixel(t) / e.factor - e.end; return El(this._table, i * this._tableRange + this._minPos, !0) } }]), i }(Rl)); Il.id = 'timeseries', Il.defaults = Rl.defaults; let Zl; function zl (t, e, i, n) { t(e, i), void 0 !== n && n.emit(Zl.ChartRendered) } function Fl (t, e) { t.update(), void 0 !== e && e.emit(Zl.ChartUpdated) } function Bl (t, e) { t.destroy(), void 0 !== e && e.emit(Zl.ChartDestroyed) } function Vl (t, e) { const i = { labels: typeof t.labels === 'undefined' ? [] : (0, c.Z)(t.labels), datasets: [] }; return Wl(i, (0, u.Z)({}, t), e), i } function Wl (t, e, i) { const n = []; t.datasets = e.datasets.map(function (e) { const a = t.datasets.find(function (t) { return t[i] === e[i] }); return a && e.data && !n.includes(a) ? (n.push(a), Object.assign(a, e), a) : (0, u.Z)({}, e) }) } function Nl (t, e, i) { t.data.labels = e, void 0 !== i && i.emit(Zl.LabelsUpdated) } function Hl (t, e) { t.options = (0, u.Z)({}, e) } function jl (t, e) { const i = t.datasets.map(function (t) { return t.label }); const n = e.datasets.map(function (t) { return t.label }); return e.datasets.length === t.datasets.length && i.every(function (t, e) { return t === n[e] }) }(function (t) { t.ChartRendered = 'chart:rendered', t.ChartUpdated = 'chart:updated', t.ChartDestroyed = 'chart:destroyed', t.LabelsUpdated = 'labels:updated' })(Zl || (Zl = {})); const $l = 'Please remove the <template></template> tags from your chart component. See https://vue-chartjs.org/guide/#vue-single-file-components'; const Yl = 'annotation'; function Ul (t, e, i) { let n = null; return { props: { chartData: { type: Object, required: !0 }, chartOptions: { type: Object, default: function () {} }, datasetIdKey: { type: String, default: 'label' }, chartId: { type: String, default: t }, width: { type: Number, default: 400 }, height: { type: Number, default: 400 }, cssClasses: { type: String, default: '' }, styles: { type: Object, default: function () {} }, plugins: { type: Array, default: function () { return [] } } }, data: function () { return { _chart: null } }, computed: { hasAnnotationPlugin: function () { let t; let e; const i = (t = this.chartOptions) === null || void 0 === t || (e = t.plugins) === null || void 0 === e ? void 0 : e[Yl]; return typeof i !== 'undefined' } }, created: function () { Ho.register(i) }, mounted: function () { n = { current: null }, 'datasets' in this.chartData && this.chartData.datasets.length > 0 && (zl(this.renderChart, this.chartData, this.chartOptions), this.$emit(Zl.ChartRendered)) }, watch: { chartData: { handler: function (t, e) { this.chartDataHandler(t, e) }, deep: !0 }, chartOptions: { handler: function (t) { this.chartOptionsHandler(t) }, deep: !0 } }, methods: { renderChart: function (t, i) { const n = this.getCurrentChart(); if (n !== null && (Bl(n), this.$emit(Zl.ChartDestroyed)), !this.$refs.canvas) throw new Error($l); const a = Vl(t, this.datasetIdKey); const r = this.$refs.canvas.getContext('2d'); r !== null && this.setCurrentChart(new Ho(r, { type: e, data: a, options: i, plugins: this.plugins })) }, chartDataHandler: function (t, e) { const i = (0, u.Z)({}, t); const n = (0, u.Z)({}, e); const a = this.getCurrentChart(); if (Object.keys(n).length > 0) { const r = jl(i, n); r && a !== null ? (Wl(a.data, i, this.datasetIdKey), void 0 !== i.labels && (Nl(a, i.labels), this.$emit(Zl.LabelsUpdated)), this.updateChart(), this.$emit(Zl.ChartUpdated)) : (a !== null && (Bl(a), this.$emit(Zl.ChartDestroyed)), zl(this.renderChart, this.chartData, this.chartOptions), this.$emit(Zl.ChartRendered)) } else a !== null && (Bl(a), this.$emit(Zl.ChartDestroyed)), zl(this.renderChart, this.chartData, this.chartOptions), this.$emit(Zl.ChartRendered) }, chartOptionsHandler: function (t) { const e = this.getCurrentChart(); e !== null ? (Hl(e, t), this.updateChart()) : zl(this.renderChart, this.chartData, this.chartOptions) }, updateChart: function () { const t = this.getCurrentChart(); Fl(t) }, getCurrentChart: function () { return this.hasAnnotationPlugin ? n.current : this.$data._chart }, setCurrentChart: function (t) { this.hasAnnotationPlugin ? n.current = t : this.$data._chart = t } }, beforeDestroy: function () { const t = this.getCurrentChart(); t !== null && (Bl(t), this.$emit(Zl.ChartDestroyed)) }, render: function (t) { return t('div', { style: this.styles, class: this.cssClasses }, [t('canvas', { attrs: { id: this.chartId, width: this.width, height: this.height }, ref: 'canvas' })]) } } } const Xl = Ul('pie-chart', 'pie', Ra); const ql = (i(15218), (function () { if (typeof window !== 'undefined') { if (window.devicePixelRatio) return window.devicePixelRatio; const t = window.screen; if (t) return (t.deviceXDPI || 1) / (t.logicalXDPI || 1) } return 1 }())); const Kl = { toTextLines: function (t) { let e; const i = []; t = [].concat(t); while (t.length)e = t.pop(), typeof e === 'string' ? i.unshift.apply(i, e.split('\n')) : Array.isArray(e) ? t.push.apply(t, e) : T(t) || i.unshift('' + e); return i }, textSize: function (t, e, i) { let n; const a = [].concat(e); const r = a.length; const o = t.font; let s = 0; for (t.font = i.string, n = 0; n < r; ++n)s = Math.max(t.measureText(a[n]).width, s); return t.font = o, { height: r * i.lineHeight, width: s } }, bound: function (t, e, i) { return Math.max(t, Math.min(e, i)) }, arrayDiff: function (t, e) { let i; let n; let a; let r; const o = t.slice(); const s = []; for (i = 0, a = e.length; i < a; ++i)r = e[i], n = o.indexOf(r), n === -1 ? s.push([r, 1]) : o.splice(n, 1); for (i = 0, a = o.length; i < a; ++i)s.push([o[i], -1]); return s }, rasterize: function (t) { return Math.round(t * ql) / ql } }; function Gl (t, e) { const i = e.x; const n = e.y; if (i === null) return { x: 0, y: -1 }; if (n === null) return { x: 1, y: 0 }; const a = t.x - i; const r = t.y - n; const o = Math.sqrt(a * a + r * r); return { x: o ? a / o : 0, y: o ? r / o : -1 } } function Jl (t, e, i, n, a) { switch (a) { case 'center':i = n = 0; break; case 'bottom':i = 0, n = 1; break; case 'right':i = 1, n = 0; break; case 'left':i = -1, n = 0; break; case 'top':i = 0, n = -1; break; case 'start':i = -i, n = -n; break; case 'end':break; default:a *= Math.PI / 180, i = Math.cos(a), n = Math.sin(a); break } return { x: t, y: e, vx: i, vy: n } } const Ql = 0; const th = 1; const eh = 2; const ih = 4; const nh = 8; function ah (t, e, i) { let n = Ql; return t < i.left ? n |= th : t > i.right && (n |= eh), e < i.top ? n |= nh : e > i.bottom && (n |= ih), n } function rh (t, e) { let i; let n; let a; let r = t.x0; let o = t.y0; let s = t.x1; let l = t.y1; let h = ah(r, o, e); let u = ah(s, l, e); while (1) { if (!(h | u) || h & u) break; i = h || u, i & nh ? (n = r + (s - r) * (e.top - o) / (l - o), a = e.top) : i & ih ? (n = r + (s - r) * (e.bottom - o) / (l - o), a = e.bottom) : i & eh ? (a = o + (l - o) * (e.right - r) / (s - r), n = e.right) : i & th && (a = o + (l - o) * (e.left - r) / (s - r), n = e.left), i === h ? (r = n, o = a, h = ah(r, o, e)) : (s = n, l = a, u = ah(s, l, e)) } return { x0: r, x1: s, y0: o, y1: l } } function oh (t, e) { let i; let n; const a = e.anchor; let r = t; return e.clamp && (r = rh(r, e.area)), a === 'start' ? (i = r.x0, n = r.y0) : a === 'end' ? (i = r.x1, n = r.y1) : (i = (r.x0 + r.x1) / 2, n = (r.y0 + r.y1) / 2), Jl(i, n, t.vx, t.vy, e.align) } const sh = { arc: function (t, e) { const i = (t.startAngle + t.endAngle) / 2; const n = Math.cos(i); const a = Math.sin(i); const r = t.innerRadius; const o = t.outerRadius; return oh({ x0: t.x + n * r, y0: t.y + a * r, x1: t.x + n * o, y1: t.y + a * o, vx: n, vy: a }, e) }, point: function (t, e) { const i = Gl(t, e.origin); const n = i.x * t.options.radius; const a = i.y * t.options.radius; return oh({ x0: t.x - n, y0: t.y - a, x1: t.x + n, y1: t.y + a, vx: i.x, vy: i.y }, e) }, bar: function (t, e) { const i = Gl(t, e.origin); let n = t.x; let a = t.y; let r = 0; let o = 0; return t.horizontal ? (n = Math.min(t.x, t.base), r = Math.abs(t.base - t.x)) : (a = Math.min(t.y, t.base), o = Math.abs(t.base - t.y)), oh({ x0: n, y0: a + o, x1: n + r, y1: a, vx: i.x, vy: i.y }, e) }, fallback: function (t, e) { const i = Gl(t, e.origin); return oh({ x0: t.x, y0: t.y, x1: t.x, y1: t.y, vx: i.x, vy: i.y }, e) } }; const lh = Kl.rasterize; function hh (t) { const e = t.borderWidth || 0; const i = t.padding; const n = t.size.height; const a = t.size.width; const r = -a / 2; const o = -n / 2; return { frame: { x: r - i.left - e, y: o - i.top - e, w: a + i.width + 2 * e, h: n + i.height + 2 * e }, text: { x: r, y: o, w: a, h: n } } } function uh (t, e) { const i = e.chart.getDatasetMeta(e.datasetIndex).vScale; if (!i) return null; if (void 0 !== i.xCenter && void 0 !== i.yCenter) return { x: i.xCenter, y: i.yCenter }; const n = i.getBasePixel(); return t.horizontal ? { x: n, y: null } : { x: null, y: n } } function ch (t) { return t instanceof ts ? sh.arc : t instanceof gs ? sh.point : t instanceof Ss ? sh.bar : sh.fallback } function dh (t, e, i, n, a, r) { const o = Math.PI / 2; if (r) { const s = Math.min(r, a / 2, n / 2); const l = e + s; const h = i + s; const u = e + n - s; const c = i + a - s; t.moveTo(e, h), l < u && h < c ? (t.arc(l, h, s, -Math.PI, -o), t.arc(u, h, s, -o, 0), t.arc(u, c, s, 0, o), t.arc(l, c, s, o, Math.PI)) : l < u ? (t.moveTo(l, i), t.arc(u, h, s, -o, o), t.arc(l, h, s, o, Math.PI + o)) : h < c ? (t.arc(l, h, s, -Math.PI, 0), t.arc(l, c, s, 0, Math.PI)) : t.arc(l, h, s, -Math.PI, Math.PI), t.closePath(), t.moveTo(e, i) } else t.rect(e, i, n, a) } function fh (t, e, i) { const n = i.backgroundColor; const a = i.borderColor; const r = i.borderWidth; (n || a && r) && (t.beginPath(), dh(t, lh(e.x) + r / 2, lh(e.y) + r / 2, lh(e.w) - r, lh(e.h) - r, i.borderRadius), t.closePath(), n && (t.fillStyle = n, t.fill()), a && r && (t.strokeStyle = a, t.lineWidth = r, t.lineJoin = 'miter', t.stroke())) } function vh (t, e, i) { const n = i.lineHeight; const a = t.w; let r = t.x; const o = t.y + n / 2; return e === 'center' ? r += a / 2 : e !== 'end' && e !== 'right' || (r += a), { h: n, w: a, x: r, y: o } } function gh (t, e, i) { const n = t.shadowBlur; const a = i.stroked; const r = lh(i.x); const o = lh(i.y); const s = lh(i.w); a && t.strokeText(e, r, o, s), i.filled && (n && a && (t.shadowBlur = 0), t.fillText(e, r, o, s), n && a && (t.shadowBlur = n)) } function ph (t, e, i, n) { let a; const r = n.textAlign; const o = n.color; const s = !!o; const l = n.font; let h = e.length; const u = n.textStrokeColor; const c = n.textStrokeWidth; const d = u && c; if (h && (s || d)) for (i = vh(i, r, l), t.font = l.string, t.textAlign = r, t.textBaseline = 'middle', t.shadowBlur = n.textShadowBlur, t.shadowColor = n.textShadowColor, s && (t.fillStyle = o), d && (t.lineJoin = 'round', t.lineWidth = c, t.strokeStyle = u), a = 0, h = e.length; a < h; ++a)gh(t, e[a], { stroked: d, filled: s, w: i.w, x: i.x, y: i.y + i.h * a }) } const yh = function (t, e, i, n) { const a = this; a._config = t, a._index = n, a._model = null, a._rects = null, a._ctx = e, a._el = i }; $(yh.prototype, { _modelize: function (t, e, i, n) { const a = this; const r = a._index; const o = ri(oi([i.font, {}], n, r)); const s = oi([i.color, Ee.color], n, r); return { align: oi([i.align, 'center'], n, r), anchor: oi([i.anchor, 'center'], n, r), area: n.chart.chartArea, backgroundColor: oi([i.backgroundColor, null], n, r), borderColor: oi([i.borderColor, null], n, r), borderRadius: oi([i.borderRadius, 0], n, r), borderWidth: oi([i.borderWidth, 0], n, r), clamp: oi([i.clamp, !1], n, r), clip: oi([i.clip, !1], n, r), color: s, display: t, font: o, lines: e, offset: oi([i.offset, 0], n, r), opacity: oi([i.opacity, 1], n, r), origin: uh(a._el, n), padding: ai(oi([i.padding, 0], n, r)), positioner: ch(a._el), rotation: oi([i.rotation, 0], n, r) * (Math.PI / 180), size: Kl.textSize(a._ctx, e, o), textAlign: oi([i.textAlign, 'start'], n, r), textShadowBlur: oi([i.textShadowBlur, 0], n, r), textShadowColor: oi([i.textShadowColor, s], n, r), textStrokeColor: oi([i.textStrokeColor, s], n, r), textStrokeWidth: oi([i.textStrokeWidth, 0], n, r) } }, update: function (t) { let e; let i; let n; const a = this; let r = null; let o = null; const s = a._index; const l = a._config; const h = oi([l.display, !0], t, s); h && (e = t.dataset.data[s], i = Z(B(l.formatter, [e, t]), e), n = T(i) ? [] : Kl.toTextLines(i), n.length && (r = a._modelize(h, n, l, t), o = hh(r))), a._model = r, a._rects = o }, geometry: function () { return this._rects ? this._rects.frame : {} }, rotation: function () { return this._model ? this._model.rotation : 0 }, visible: function () { return this._model && this._model.opacity }, model: function () { return this._model }, draw: function (t, e) { let i; const n = this; const a = t.ctx; const r = n._model; const o = n._rects; this.visible() && (a.save(), r.clip && (i = r.area, a.beginPath(), a.rect(i.left, i.top, i.right - i.left, i.bottom - i.top), a.clip()), a.globalAlpha = Kl.bound(0, r.opacity, 1), a.translate(lh(e.x), lh(e.y)), a.rotate(r.rotation), fh(a, o.frame, r), ph(a, r.lines, o.text, r), a.restore()) } }); const mh = Number.MIN_SAFE_INTEGER || -9007199254740991; const bh = Number.MAX_SAFE_INTEGER || 9007199254740991; function xh (t, e, i) { const n = Math.cos(i); const a = Math.sin(i); const r = e.x; const o = e.y; return { x: r + n * (t.x - r) - a * (t.y - o), y: o + a * (t.x - r) + n * (t.y - o) } } function _h (t, e) { let i; let n; let a; let r; let o; let s = bh; let l = mh; const h = e.origin; for (i = 0; i < t.length; ++i)n = t[i], a = n.x - h.x, r = n.y - h.y, o = e.vx * a + e.vy * r, s = Math.min(s, o), l = Math.max(l, o); return { min: s, max: l } } function kh (t, e) { const i = e.x - t.x; const n = e.y - t.y; const a = Math.sqrt(i * i + n * n); return { vx: (e.x - t.x) / a, vy: (e.y - t.y) / a, origin: t, ln: a } } const wh = function () { this._rotation = 0, this._rect = { x: 0, y: 0, w: 0, h: 0 } }; function Mh (t, e, i) { const n = e.positioner(t, e); const a = n.vx; const r = n.vy; if (!a && !r) return { x: n.x, y: n.y }; const o = i.w; const s = i.h; const l = e.rotation; let h = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)); let u = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)); const c = 1 / Math.max(Math.abs(a), Math.abs(r)); return h *= a * c, u *= r * c, h += e.offset * a, u += e.offset * r, { x: n.x + h, y: n.y + u } } function Sh (t, e) { let i, n, a, r; for (i = t.length - 1; i >= 0; --i) for (a = t[i].$layout, n = i - 1; n >= 0 && a._visible; --n)r = t[n].$layout, r._visible && a._box.intersects(r._box) && e(a, r); return t } function Ph (t) { let e, i, n, a, r, o, s; for (e = 0, i = t.length; e < i; ++e)n = t[e], a = n.$layout, a._visible && (s = new Proxy(n._el, { get: function (t, e) { return t.getProps([e], !0)[e] } }), r = n.geometry(), o = Mh(s, n.model(), r), a._box.update(o, r, n.rotation())); return Sh(t, function (t, e) { const i = t._hidable; const n = e._hidable; i && n || n ? e._visible = !1 : i && (t._visible = !1) }) }$(wh.prototype, { center: function () { const t = this._rect; return { x: t.x + t.w / 2, y: t.y + t.h / 2 } }, update: function (t, e, i) { this._rotation = i, this._rect = { x: e.x + t.x, y: e.y + t.y, w: e.w, h: e.h } }, contains: function (t) { const e = this; const i = 1; const n = e._rect; return t = xh(t, e.center(), -e._rotation), !(t.x < n.x - i || t.y < n.y - i || t.x > n.x + n.w + 2 * i || t.y > n.y + n.h + 2 * i) }, intersects: function (t) { let e; let i; let n; const a = this._points(); const r = t._points(); const o = [kh(a[0], a[1]), kh(a[0], a[3])]; for (this._rotation !== t._rotation && o.push(kh(r[0], r[1]), kh(r[0], r[3])), e = 0; e < o.length; ++e) if (i = _h(a, o[e]), n = _h(r, o[e]), i.max < n.min || n.max < i.min) return !1; return !0 }, _points: function () { const t = this; const e = t._rect; const i = t._rotation; const n = t.center(); return [xh({ x: e.x, y: e.y }, n, i), xh({ x: e.x + e.w, y: e.y }, n, i), xh({ x: e.x + e.w, y: e.y + e.h }, n, i), xh({ x: e.x, y: e.y + e.h }, n, i)] } }); const Ch = { prepare: function (t) { let e; let i; let n; let a; let r; const o = []; for (e = 0, n = t.length; e < n; ++e) for (i = 0, a = t[e].length; i < a; ++i)r = t[e][i], o.push(r), r.$layout = { _box: new wh(), _hidable: !1, _visible: !0, _set: e, _idx: i }; return o.sort(function (t, e) { const i = t.$layout; const n = e.$layout; return i._idx === n._idx ? n._set - i._set : n._idx - i._idx }), this.update(o), o }, update: function (t) { let e; let i; let n; let a; let r; let o = !1; for (e = 0, i = t.length; e < i; ++e)n = t[e], a = n.model(), r = n.$layout, r._hidable = a && a.display === 'auto', r._visible = n.visible(), o |= r._hidable; o && Ph(t) }, lookup: function (t, e) { let i, n; for (i = t.length - 1; i >= 0; --i) if (n = t[i].$layout, n && n._visible && n._box.contains(e)) return t[i]; return null }, draw: function (t, e) { let i, n, a, r, o, s; for (i = 0, n = e.length; i < n; ++i)a = e[i], r = a.$layout, r._visible && (o = a.geometry(), s = Mh(a._el, a.model(), o), r._box.update(s, o, a.rotation()), a.draw(t, s)) } }; const Dh = function (t) { if (T(t)) return null; let e; let i; let n; let a = t; if (R(t)) if (T(t.label)) if (T(t.r)) for (a = '', e = Object.keys(t), n = 0, i = e.length; n < i; ++n)a += (n !== 0 ? ', ' : '') + e[n] + ': ' + t[e[n]]; else a = t.r; else a = t.label; return '' + a }; const Oh = { align: 'center', anchor: 'center', backgroundColor: null, borderColor: null, borderRadius: 0, borderWidth: 0, clamp: !1, clip: !1, color: void 0, display: !0, font: { family: void 0, lineHeight: 1.2, size: void 0, style: void 0, weight: null }, formatter: Dh, labels: void 0, listeners: {}, offset: 4, opacity: 1, padding: { top: 4, right: 4, bottom: 4, left: 4 }, rotation: 0, textAlign: 'start', textStrokeColor: void 0, textStrokeWidth: 0, textShadowBlur: 0, textShadowColor: void 0 }; const Ah = '$datalabels'; const Th = '$default'; function Lh (t, e) { let i; let n; let a = t.datalabels; let r = {}; const o = []; return !1 === a ? null : (!0 === a && (a = {}), e = $({}, [e, a]), i = e.labels || {}, n = Object.keys(i), delete e.labels, n.length ? n.forEach(function (t) { i[t] && o.push($({}, [e, i[t], { _key: t }])) }) : o.push(e), r = o.reduce(function (t, e) { return V(e.listeners || {}, function (i, n) { t[n] = t[n] || {}, t[n][e._key || Th] = i }), delete e.listeners, t }, {}), { labels: o, listeners: r }) } function Rh (t, e, i) { if (e) { let n; const a = i.$context; const r = i.$groups; e[r._set] && (n = e[r._set][r._key], n && !0 === B(n, [a]) && (t[Ah]._dirty = !0, i.update(a))) } } function Eh (t, e, i, n) { let a, r; (i || n) && (i ? n ? i !== n && (r = a = !0) : r = !0 : a = !0, r && Rh(t, e.leave, i), a && Rh(t, e.enter, n)) } function Ih (t, e) { let i; let n; const a = t[Ah]; const r = a._listeners; if (r.enter || r.leave) { if (e.type === 'mousemove')n = Ch.lookup(a._labels, e); else if (e.type !== 'mouseout') return; i = a._hovered, a._hovered = n, Eh(t, r, i, n) } } function Zh (t, e) { const i = t[Ah]; const n = i._listeners.click; const a = n && Ch.lookup(i._labels, e); a && Rh(t, n, a) } const zh = { id: 'datalabels', defaults: Oh, beforeInit: function (t) { t[Ah] = { _actives: [] } }, beforeUpdate: function (t) { const e = t[Ah]; e._listened = !1, e._listeners = {}, e._datasets = [], e._labels = [] }, afterDatasetUpdate: function (t, e, i) { let n; let a; let r; let o; let s; let l; let h; let u; const c = e.index; const d = t[Ah]; const f = d._datasets[c] = []; const v = t.isDatasetVisible(c); const g = t.data.datasets[c]; const p = Lh(g, i); const y = e.meta.data || []; const m = t.ctx; for (m.save(), n = 0, r = y.length; n < r; ++n) if (h = y[n], h[Ah] = [], v && h && t.getDataVisibility(n) && !h.skip) for (a = 0, o = p.labels.length; a < o; ++a)s = p.labels[a], l = s._key, u = new yh(s, m, h, n), u.$groups = { _set: c, _key: l || Th }, u.$context = { active: !1, chart: t, dataIndex: n, dataset: g, datasetIndex: c }, u.update(u.$context), h[Ah].push(u), f.push(u); m.restore(), $(d._listeners, p.listeners, { merger: function (t, i, n) { i[t] = i[t] || {}, i[t][e.index] = n[t], d._listened = !0 } }) }, afterUpdate: function (t, e) { t[Ah]._labels = Ch.prepare(t[Ah]._datasets, e) }, afterDatasetsDraw: function (t) { Ch.draw(t, t[Ah]._labels) }, beforeEvent: function (t, e) { if (t[Ah]._listened) { const i = e.event; switch (i.type) { case 'mousemove':case 'mouseout':Ih(t, i); break; case 'click':Zh(t, i); break } } }, afterEvent: function (t) { let e; let i; let n; let a; let r; let o; let s; const l = t[Ah]; const h = l._actives; const u = l._actives = t.getActiveElements(); const c = Kl.arrayDiff(h, u); for (e = 0, i = c.length; e < i; ++e) if (r = c[e], r[1]) for (s = r[0].element[Ah] || [], n = 0, a = s.length; n < a; ++n)o = s[n], o.$context.active = r[1] === 1, o.update(o.$context); (l._dirty || c.length) && (Ch.update(l._labels), t.render()), delete l._dirty } }; const Fh = zh; const Bh = i(34665); const Vh = i(14511); const Wh = i(9677); const Nh = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'm-label' }, [i('div', { staticClass: 'm-label__point', style: { backgroundColor: t.color } }, [i('b-icon', { attrs: { icon: 'circle' } })], 1), i('div', { staticClass: 'm-label__body' }, [i('p', { staticClass: 'm-label__title' }, [t._v(t._s(t.label) + ' ')]), i('p', { staticClass: 'm-label__value' }, [t._v('$ ' + t._s(t.valueFormat) + ' ')]), t.showPercentage ? i('p', { staticClass: 'm-label__perc' }, [t._v(t._s(t.percentage))]) : t._e()])]) }; const Hh = []; const jh = { props: { color: { type: String, default: '' }, label: { type: String, default: '' }, value: { type: [String, Number], default: '' }, total: { type: Number, default: 1 }, showPercentage: { type: Boolean, default: !1 } }, computed: { percentage: function () { return (100 * this.value / this.total).toFixed(0) + '%' }, valueFormat: function () { return Vh.P.formatNumber(this.value) } } }; const $h = jh; const Yh = i(1001); const Uh = (0, Yh.Z)($h, Nh, Hh, !1, null, null, null); const Xh = Uh.exports; Ho.register(Rs, Gs, As, ts, el, Fh); const qh = { name: 'PieChart', components: { Pie: Xl, LabelChart: Xh }, props: { chartId: { type: String, default: 'pie-chart' }, datasetIdKey: { type: String, default: 'label' }, width: { type: Number, default: 150 }, height: { type: Number, default: 150 }, cssClasses: { default: '', type: String }, styles: { type: Object, default: function () {} }, plugins: { type: Array, default: function () { return [] } } }, data: function () { return { chartData: { labels: ['VueJs', 'EmberJs', 'ReactJs', 'AngularJs'], datasets: [{ backgroundColor: ['#41B883', '#E46651', '#00D8FF', '#DD1B16'], data: [40, 20, 80, 10] }] }, chartOptions: { responsive: !0, maintainAspectRatio: !1, plugins: { legend: { display: !1 }, tooltip: { callbacks: { label: function (t) { let e = t.label || ''; e = e.split(','); const i = parseInt(e[1]); let n = 0; t.dataset.data.forEach(function (t) { n += t }); const a = (100 * i / n).toFixed(0) + '%'; return ''.concat(e[0], ' ').concat(a) } } }, datalabels: { color: '#FFF', formatter: function (t, e) { let i = 0; return e.dataset.data.forEach(function (t) { i += t }), (100 * t / i).toFixed(0) + '%' }, font: { size: 10 } } } }, categoriesArr: [], type: 'credit' } }, watch: { currentPeriod: function () { this.setGraph() } }, computed: (0, u.Z)((0, u.Z)({ expenses: function () { return this.accounts[0].getExpenses(this.currentPeriod) }, totalArr: function () { let t = 0; return this.categoriesArr.forEach(function (e) { t += parseInt(e.total) }), t } }, (0, Bh.rn)('accountsStore', ['accounts'])), (0, Bh.rn)('expensesStore', ['currentPeriod'])), methods: { setGraph: function () { const t = this; return (0, h.Z)((0, l.Z)().mark(function e () { let i, n, a, r, o; return (0, l.Z)().wrap(function (e) { while (1) switch (e.prev = e.next) { case 0:return e.next = 2, (new Wh.Z()).getAccounts(); case 2:i = e.sent, n = i[0].getExpenses(t.currentPeriod), a = Vh.P.getFirstDay(t.currentPeriod), r = Vh.P.getLastDay(t.currentPeriod), o = [], n.forEach(function (e) { if (e.type === t.type) { const n = e.category; o[n.detail] || (o[n.detail] = { total: 0, backgroundColor: n.backgroundColor, label: n.detail }); const s = i[0].totalExpense(e, a, r); o[n.detail].total = parseInt(o[n.detail].total) + parseInt(s.totalAll) } }), t.categoriesArr = Object.values(o), t.setChartData(o); case 10:case 'end':return e.stop() } }, e) }))() }, setChartData: function (t) { const e = []; const i = []; const n = Object.values(t); const a = Object.keys(t); n.forEach(function (t, n) { e.push(t.backgroundColor), i.push(t.total), a[n] = ''.concat(a[n], ',').concat(t.total) }), this.chartData = { labels: a, datasets: [{ backgroundColor: e, data: i }] } }, setType: function (t) { this.type = t, this.setGraph() } }, created: function () { const t = this; return (0, h.Z)((0, l.Z)().mark(function e () { return (0, l.Z)().wrap(function (e) { while (1) switch (e.prev = e.next) { case 0:t.setGraph(); case 1:case 'end':return e.stop() } }, e) }))() } }; const Kh = qh; const Gh = (0, Yh.Z)(Kh, o, s, !1, null, null, null); const Jh = Gh.exports; const Qh = { components: { PieChart: Jh, SelectPeriod: r.Z }, name: 'StatisticsView' }; const tu = Qh; const eu = (0, Yh.Z)(tu, n, a, !1, null, null, null); var iu = eu.exports
  },
  20403: function (t) { const e = Math.log; const i = Math.LOG10E; t.exports = Math.log10 || function (t) { return e(t) * i } },
  64310: function (t) { t.exports = Math.sign || function (t) { const e = +t; return e == 0 || e != e ? e : e < 0 ? -1 : 1 } },
  40658: function (t, e, i) { const n = i(82109); const a = i(20403); n({ target: 'Math', stat: !0 }, { log10: a }) },
  52420: function (t, e, i) { const n = i(82109); const a = i(64310); n({ target: 'Math', stat: !0 }, { sign: a }) },
  93299: function (t, e, i) { const n = i(82109); n({ target: 'Number', stat: !0 }, { EPSILON: Math.pow(2, -52) }) },
  95683: function (t, e, i) { const n = i(82109); const a = i(19781); const r = i(19670); const o = i(31236); n({ target: 'Reflect', stat: !0, sham: !a }, { getOwnPropertyDescriptor: function (t, e) { return o.f(r(t), e) } }) },
  39361: function (t, e, i) { const n = i(82109); const a = i(19670); const r = i(79518); const o = i(49920); n({ target: 'Reflect', stat: !0, sham: !o }, { getPrototypeOf: function (t) { return r(a(t)) } }) },
  51037: function (t, e, i) { const n = i(82109); n({ target: 'Reflect', stat: !0 }, { has: function (t, e) { return e in t } }) },
  15218: function (t, e, i) { 'use strict'; const n = i(82109); const a = i(14230); const r = i(43429); n({ target: 'String', proto: !0, forced: r('anchor') }, { anchor: function (t) { return a(this, 'a', 'name', t) } }) },
  27852: function (t, e, i) { 'use strict'; const n = i(82109); const a = i(1702); const r = i(31236).f; const o = i(17466); const s = i(41340); const l = i(3929); const h = i(84488); const u = i(84964); const c = i(31913); const d = a(''.endsWith); const f = a(''.slice); const v = Math.min; const g = u('endsWith'); const p = !c && !g && !!(function () { const t = r(String.prototype, 'endsWith'); return t && !t.writable }()); n({ target: 'String', proto: !0, forced: !p && !g }, { endsWith: function (t) { const e = s(h(this)); l(t); const i = arguments.length > 1 ? arguments[1] : void 0; const n = e.length; const a = void 0 === i ? n : v(o(i), n); const r = s(t); return d ? d(e, r, a) : f(e, a - r.length, a) === r } }) }
}])
// # sourceMappingURL=statistics-legacy.cc91f677.js.map
